{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\u2699\ufe0f Axium","text":"<p>Axium: structure for your terminal.</p> <p>Axium is a context-aware DevOps assistant built to make your shell environments cohesive and intelligent. It provides a lightweight daemon, intuitive CLI, dynamic HUD, and extensible plugin system (\"Spokes\") \u2014 all designed for engineers who live in tmux and terminals.</p>"},{"location":"#features","title":"\ud83e\udded Features","text":"Component Description Daemon (axiumd) Async background process maintaining session state, env context, and plugin registry CLI (axium) Typer-based command interface with structured sub-commands and fast completions HUD Prints a one-line status segment ideal for tmux/shell prompts Palette Curses-based quick launcher; triggers common commands or plugin actions interactively Spokes Lightweight plugin system for commands and event handlers Gears Privileged automation extensions with tmux integration and enhanced permissions"},{"location":"#architecture-overview","title":"\ud83e\uddf1 Architecture Overview","text":"<p>Shell \u2192 CLI \u2192 Daemon \u2192 State</p> <p>Each layer communicates via JSON over a UNIX socket:</p> <pre><code>Shell (bash/zsh/tmux)\n    \u2193\nAxium CLI (Typer)\n    \u2193\nAxium Daemon (asyncio)\n    \u2193\nState / Config / Spokes\n</code></pre>"},{"location":"#directory-structure","title":"\ud83e\udde9 Directory Structure","text":"<pre><code>axium/core/\n    cli.py        \u2192 Typer CLI entrypoint\n    daemon.py     \u2192 Async background service\n    ipc.py        \u2192 JSON IPC utilities\n    hud.py        \u2192 Status line generator\n    palette.py    \u2192 Interactive TUI launcher\n    spokes.py     \u2192 Spoke discovery/loader\nbash/init.sh      \u2192 Shell alias + integration\ntests/            \u2192 Pytest suite\n</code></pre>"},{"location":"#design-principles","title":"\ud83e\udea9 Design Principles","text":"<ul> <li>Async-first \u2014 everything that can await, does</li> <li>Minimal dependencies \u2014 stdlib + Typer + YAML</li> <li>Predictable UX \u2014 axium <code>&lt;noun&gt;</code> <code>&lt;verb&gt;</code> pattern</li> <li>Invisible until needed \u2014 helps, never interrupts</li> <li>Composable \u2014 Daemon, HUD, and Spokes work independently</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Getting Started - Installation and quickstart</li> <li>Core Concepts - Understanding Axium's architecture</li> <li>Writing Spokes - Lightweight plugin development</li> <li>Writing Gears - Privileged automation extensions</li> <li>Contributing - Join the development</li> </ul> <p>\"Structure for your terminal.\"</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Get up and running with Axium in minutes.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>Install in editable mode:</p> <pre><code>pip install -e .\n</code></pre>"},{"location":"getting-started/#shell-integration","title":"Shell Integration","text":"<p>Load Axium shell integration (adds the <code>ax</code> alias):</p> <pre><code>source bash/init.sh\n</code></pre> <p>Add this to your <code>.bashrc</code> or <code>.zshrc</code> to load automatically:</p> <pre><code># Axium shell integration\n[ -f ~/path/to/axium/bash/init.sh ] &amp;&amp; source ~/path/to/axium/bash/init.sh\n</code></pre>"},{"location":"getting-started/#first-steps","title":"First Steps","text":""},{"location":"getting-started/#1-set-an-environment-daemon-auto-starts","title":"1. Set an Environment (Daemon Auto-Starts)","text":"<p>The daemon automatically starts when you run any <code>axium</code> command:</p> <pre><code>axium env set prod\n</code></pre> <p>The daemon runs in the background and maintains your session state, handling IPC operations, events, and completion cache updates.</p> <p>Note: You don't need to manually start the daemon - it starts automatically when needed.</p>"},{"location":"getting-started/#2-verify-daemon-is-running","title":"2. Verify Daemon is Running","text":"<p>Check daemon status:</p> <pre><code>axium daemon status\n</code></pre>"},{"location":"getting-started/#3-view-the-hud","title":"3. View the HUD","text":"<pre><code>axium hud\n</code></pre> <p>Output: <pre><code>[axium] env:prod aws:- uptime:5m\n</code></pre></p>"},{"location":"getting-started/#4-test-shell-completions","title":"4. Test Shell Completions","text":"<p>Axium provides fast shell completions that auto-update:</p> <pre><code>axium env &lt;TAB&gt;      # Shows: get  list  set  show\naxium daemon &lt;TAB&gt;   # Shows: logs  reload  start  status  stop\n</code></pre> <p>See Shell Completions for installation.</p>"},{"location":"getting-started/#5-launch-the-palette","title":"5. Launch the Palette","text":"<pre><code>axium palette\n</code></pre> <p>The interactive palette provides quick access to common commands and Spoke actions.</p>"},{"location":"getting-started/#configuration","title":"Configuration","text":"<p>Axium automatically creates its configuration directory at <code>~/.config/axium/</code> on first run.</p> <p>Contents:</p> <ul> <li><code>axiumd.log</code> \u2014 daemon log file</li> <li><code>state.json</code> \u2014 daemon state (env, aws profile, etc.)</li> <li><code>spokes/</code> \u2014 installed plugin folders</li> <li><code>envs.yaml</code> \u2014 environment definitions</li> <li><code>prefixes.yaml</code> \u2014 command prefix mappings</li> </ul>"},{"location":"getting-started/#environment-variables","title":"Environment Variables","text":"<ul> <li><code>AXIUM_DEBUG=1</code> \u2014 enables verbose debug logs</li> <li><code>AXIUM_HOME</code> \u2014 override default config directory</li> </ul>"},{"location":"getting-started/#example-workflows","title":"Example Workflows","text":""},{"location":"getting-started/#switch-environment","title":"Switch Environment","text":"<pre><code>axium env set builder\naxium hud\n</code></pre> <p>Output: <pre><code>[axium] env:builder aws:- uptime:5m\n</code></pre></p>"},{"location":"getting-started/#reload-daemon","title":"Reload Daemon","text":"<p>Reload daemon configuration without restart:</p> <pre><code>axium daemon reload\n</code></pre>"},{"location":"getting-started/#view-logs","title":"View Logs","text":"<pre><code>axium daemon logs -f\n</code></pre>"},{"location":"getting-started/#development-setup","title":"Development Setup","text":"<p>Requirements:</p> <ul> <li>Python \u2265 3.9</li> <li>Typer</li> <li>PyYAML</li> <li>pytest</li> </ul> <p>Setup:</p> <pre><code>git clone https://github.com/axium-tools/axium.git\ncd axium\npip install -e .[dev]\npytest -q\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Understanding Environments</li> <li>Command Prefixes</li> <li>Writing Your First Spoke</li> <li>Configuration Reference</li> </ul>"},{"location":"concepts/completions/","title":"Shell Completions","text":"<p>Axium provides a fast, hierarchical shell completion system for instant command discovery across core commands, Spokes, and Gears.</p>"},{"location":"concepts/completions/#overview","title":"Overview","text":"<p>The completion system offers:</p> <ul> <li>Fast lookups - Target &lt;50ms response time via cached command registry</li> <li>Hierarchical matching - Multi-word commands (<code>daemon start</code>, <code>env set prod</code>)</li> <li>Dynamic updates - Automatically refreshes when Spokes/Gears load</li> <li>Shell agnostic - Works with zsh, bash, and fish</li> <li>No external dependencies - Pure Python implementation</li> </ul>"},{"location":"concepts/completions/#architecture","title":"Architecture","text":"<pre><code>Shell Tab Press\n    \u2193\nShell Completion Function\n    \u2193\naxium completions list \"prefix\"\n    \u2193\nLoad Cache (~/.config/axium/completions.json)\n    \u2193\nFilter Matches\n    \u2193\nReturn to Shell (&lt;50ms total)\n</code></pre>"},{"location":"concepts/completions/#command-registry","title":"Command Registry","text":"<p>All commands are registered in a central registry:</p> <pre><code># Core commands registered on startup\nregistry.introspect_typer_app(app, source=\"core\")\n\n# Spoke commands registered when loaded\nregistry.introspect_typer_app(spoke_app, source=\"aws-spoke\")\n\n# Gear commands registered when loaded\nregistry.introspect_typer_app(gear_app, source=\"ansible-gear\")\n</code></pre>"},{"location":"concepts/completions/#completion-cache","title":"Completion Cache","text":"<p>The registry is serialized to <code>~/.config/axium/completions.json</code>:</p> <pre><code>{\n  \"commands\": [\n    \"bootstrap\",\n    \"config edit\",\n    \"config path\",\n    \"config show\",\n    \"daemon logs\",\n    \"daemon reload\",\n    \"daemon start\",\n    \"daemon status\",\n    \"daemon stop\",\n    \"env get\",\n    \"env list\",\n    \"env set\",\n    \"env show\",\n    \"gear list\",\n    \"gear perms-edit\",\n    \"gear perms-show\"\n  ],\n  \"generated_at\": \"2025-10-13T17:30:00Z\",\n  \"command_count\": 42\n}\n</code></pre>"},{"location":"concepts/completions/#installation","title":"Installation","text":""},{"location":"concepts/completions/#auto-detection","title":"Auto-Detection","text":"<p>axium completions install</p> <p>Detects your shell from <code>$SHELL</code> and outputs installation instructions.</p>"},{"location":"concepts/completions/#manual-shell-selection","title":"Manual Shell Selection","text":"<pre><code># ZSH\naxium completions install --shell zsh\n\n# Bash\naxium completions install --shell bash\n\n# Fish\naxium completions install --shell fish\n</code></pre>"},{"location":"concepts/completions/#shell-integration","title":"Shell Integration","text":""},{"location":"concepts/completions/#zsh","title":"ZSH","text":"<p>Add to <code>~/.zshrc</code>:</p> <pre><code># Axium shell completion for zsh\n_axium_completion() {\n  local prefix current\n  current=\"${words[CURRENT]}\"\n\n  # Build prefix from all axium arguments up to current position\n  if [[ $CURRENT -eq 2 ]]; then\n    # Completing first argument after 'axium'\n    prefix=\"$current\"\n  else\n    # Completing subsequent arguments\n    # Join all previous words (2 to CURRENT-1) with spaces\n    prefix=\"${(j: :)words[2,CURRENT-1]}\"\n    # Add trailing space if current word is empty (user pressed space before tab)\n    [[ -z \"$current\" ]] &amp;&amp; prefix=\"$prefix \" || prefix=\"$prefix $current\"\n  fi\n\n  local -a completions\n  completions=($(axium completions list --shell zsh \"$prefix\" 2&gt;/dev/null))\n  compadd -Q -- \"${completions[@]}\"\n}\ncompdef _axium_completion axium\n\n# Then run: source ~/.zshrc\n</code></pre>"},{"location":"concepts/completions/#bash","title":"Bash","text":"<p>Add to <code>~/.bashrc</code>:</p> <pre><code># Axium shell completion for bash\n_axium_completion() {\n  local cur prev words cword\n  _init_completion || return\n  COMPREPLY=($(axium completions list --shell bash \"$cur\" 2&gt;/dev/null))\n}\ncomplete -F _axium_completion axium\n\n# Then run: source ~/.bashrc\n</code></pre>"},{"location":"concepts/completions/#fish","title":"Fish","text":"<p>Create <code>~/.config/fish/completions/axium.fish</code>:</p> <pre><code># Axium shell completion for fish\ncomplete -c axium -f -a '(axium completions list --shell fish (commandline -ct) 2&gt;/dev/null)'\n\n# Completions available immediately\n</code></pre>"},{"location":"concepts/completions/#usage","title":"Usage","text":""},{"location":"concepts/completions/#basic-completion","title":"Basic Completion","text":"<pre><code>axium &lt;TAB&gt;\n# Shows: bootstrap  config  daemon  env  gear  hud  ...\n\naxium d&lt;TAB&gt;\n# Completes to: axium daemon\n\naxium daemon &lt;TAB&gt;\n# Shows: logs  reload  start  status  stop\n</code></pre>"},{"location":"concepts/completions/#hierarchical-completion","title":"Hierarchical Completion","text":"<pre><code>axium env &lt;TAB&gt;\n# Shows: get  list  set  show\n\naxium env s&lt;TAB&gt;\n# Shows: set  show\n\naxium daemon sta&lt;TAB&gt;\n# Completes to: axium daemon start\n</code></pre>"},{"location":"concepts/completions/#multi-word-commands","title":"Multi-Word Commands","text":"<pre><code>axium gear perms&lt;TAB&gt;\n# Shows: perms-edit  perms-show\n\naxium config &lt;TAB&gt;\n# Shows: edit  path  show\n</code></pre>"},{"location":"concepts/completions/#cache-management","title":"Cache Management","text":""},{"location":"concepts/completions/#automatic-regeneration","title":"Automatic Regeneration","text":"<p>The completion cache regenerates automatically when:</p> <ul> <li>Spokes are loaded, reloaded, or unloaded</li> <li>Gears are loaded or unloaded</li> <li>Daemon configuration is reloaded</li> <li>Command registry changes</li> </ul>"},{"location":"concepts/completions/#manual-refresh","title":"Manual Refresh","text":"<pre><code># Force regeneration\naxium completions refresh\n\n# Output:\n\u2713 Regenerated completion cache (42 commands)\n</code></pre>"},{"location":"concepts/completions/#cache-location","title":"Cache Location","text":"<pre><code>~/.config/axium/completions.json\n</code></pre>"},{"location":"concepts/completions/#viewing-cache","title":"Viewing Cache","text":"<pre><code># List all completions\naxium completions list \"\"\n\n# Filter completions\naxium completions list \"env\"\n# Output:\nenv get\nenv list\nenv set\nenv show\n\n# Multi-word filter\naxium completions list \"daemon s\"\n# Output:\ndaemon start\ndaemon status\n</code></pre>"},{"location":"concepts/completions/#implementation-details","title":"Implementation Details","text":""},{"location":"concepts/completions/#completion-algorithm","title":"Completion Algorithm","text":"<pre><code>def get_completions(prefix: str) -&gt; list[str]:\n    \"\"\"\n    Get matching completions for prefix.\n\n    Args:\n        prefix: Command prefix to match (e.g., \"env\", \"daemon s\")\n\n    Returns:\n        List of matching command strings\n    \"\"\"\n    cache = load_completion_cache()\n\n    if not prefix:\n        # Return all commands\n        return cache\n\n    # Filter commands that start with prefix\n    prefix_lower = prefix.lower()\n    matches = [\n        cmd for cmd in cache\n        if cmd.lower().startswith(prefix_lower)\n    ]\n\n    return sorted(matches)\n</code></pre>"},{"location":"concepts/completions/#performance","title":"Performance","text":"<ul> <li>Cache load: ~5-10ms</li> <li>Filtering: ~5-10ms for 100+ commands</li> <li>Total time: ~20-30ms typical, &lt;50ms target</li> </ul>"},{"location":"concepts/completions/#registry-structure","title":"Registry Structure","text":"<p>Commands stored with metadata:</p> <pre><code>{\n    \"daemon start\": {\n        \"source\": \"core\",\n        \"help\": \"Start the Axium daemon process\",\n        \"path\": [\"daemon\", \"start\"]\n    },\n    \"spoke list\": {\n        \"source\": \"core\",\n        \"help\": \"List all installed Spokes\",\n        \"path\": [\"spoke\", \"list\"]\n    },\n    \"aws-whoami\": {\n        \"source\": \"aws-spoke\",\n        \"help\": \"Show current AWS identity\",\n        \"path\": [\"aws-whoami\"]\n    }\n}\n</code></pre>"},{"location":"concepts/completions/#troubleshooting","title":"Troubleshooting","text":""},{"location":"concepts/completions/#completions-not-working","title":"Completions Not Working","text":"<p>Check installation:</p> <pre><code># Verify completion function is defined\ntypeset -f _axium_completion  # zsh\ndeclare -f _axium_completion  # bash\n\n# Reload shell config\nsource ~/.zshrc  # or ~/.bashrc\n</code></pre> <p>Check cache exists:</p> <pre><code>ls ~/.config/axium/completions.json\n\n# If missing, regenerate\naxium completions refresh\n</code></pre>"},{"location":"concepts/completions/#slow-completions","title":"Slow Completions","text":"<p>Check response time:</p> <pre><code>time axium completions list \"env\"\n# Should be &lt;50ms\n</code></pre> <p>If slow: - Check cache file size (should be &lt;100KB) - Verify no network calls in completion path - Check for slow disk I/O</p>"},{"location":"concepts/completions/#missing-commands","title":"Missing Commands","text":"<p>Regenerate cache:</p> <pre><code>axium completions refresh\n</code></pre> <p>Check command registered:</p> <pre><code>axium completions list \"\" | grep my-command\n</code></pre> <p>Check registry:</p> <pre><code>from axium.core import registry\ncommands = registry.list_all_commands()\nprint([cmd for cmd in commands if \"my-command\" in cmd])\n</code></pre>"},{"location":"concepts/completions/#duplicate-completions","title":"Duplicate Completions","text":"<p>Check for duplicate registrations:</p> <pre><code>axium completions list \"\" | sort | uniq -d\n</code></pre> <p>Solution: - Ensure spokes/gears don't register same command - Check for naming conflicts</p>"},{"location":"concepts/completions/#advanced-usage","title":"Advanced Usage","text":""},{"location":"concepts/completions/#custom-completion-in-spokes","title":"Custom Completion in Spokes","text":"<p>Spokes can register commands that appear in completions:</p> <pre><code>def register(app, events):\n    @app.command(\"my-spoke-cmd\")\n    def my_cmd():\n        \"\"\"This appears in completions.\"\"\"\n        pass\n\n    # Completion cache auto-regenerates when spoke loads\n</code></pre>"},{"location":"concepts/completions/#completion-filtering","title":"Completion Filtering","text":"<pre><code># Show only env commands\naxium completions list \"env\" | wc -l\n# 4\n\n# Show only daemon commands\naxium completions list \"daemon\" | wc -l\n# 5\n\n# Show all commands\naxium completions list \"\" | wc -l\n# 42\n</code></pre>"},{"location":"concepts/completions/#debugging-completions","title":"Debugging Completions","text":"<pre><code># Enable debug logging\nAXIUM_DEBUG=1 axium completions list \"env\" 2&gt;&amp;1 | grep completion\n\n# Check cache generation\nAXIUM_DEBUG=1 axium completions refresh\n</code></pre>"},{"location":"concepts/completions/#comparison-with-typer-built-in-completions","title":"Comparison with Typer Built-in Completions","text":"Feature Axium Completions Typer Built-in Speed &lt;50ms (cached) Slow (shell startup) Multi-word \u2713 \u2717 Dynamic updates \u2713 Auto Manual Spoke/Gear discovery \u2713 \u2717 Shell support zsh, bash, fish zsh, bash Installation Simple Complex"},{"location":"concepts/completions/#api-reference","title":"API Reference","text":""},{"location":"concepts/completions/#cli-commands","title":"CLI Commands","text":"<pre><code># Install completions (print instructions)\naxium completions install [--shell SHELL]\n\n# List matching completions\naxium completions list [PREFIX]\n\n# Regenerate cache\naxium completions refresh\n</code></pre>"},{"location":"concepts/completions/#python-api","title":"Python API","text":"<pre><code>from axium.core.completions import (\n    generate_completion_cache,\n    load_completion_cache,\n    get_completions\n)\n\n# Generate cache\nsuccess = generate_completion_cache()\n\n# Load cache\ncommands = load_completion_cache()  # list[str]\n\n# Get matches\nmatches = get_completions(\"env\")  # [\"env get\", \"env list\", ...]\n</code></pre>"},{"location":"concepts/completions/#see-also","title":"See Also","text":"<ul> <li>CLI Reference - Complete command documentation</li> <li>Spokes - Plugin system that extends completions</li> <li>Gears - Privileged extensions in completions</li> <li>Command Registry - Central command tracking</li> </ul>"},{"location":"concepts/config/","title":"Configuration System","text":"<p>Axium provides a centralized configuration system for Spokes with support for user overrides, environment-specific settings, and automatic value expansion.</p>"},{"location":"concepts/config/#overview","title":"Overview","text":"<p>The config system separates base configuration (bundled with spokes) from user overrides (in <code>~/.config/axium/overrides/</code>), allowing users to customize spoke behavior without modifying the spoke itself.</p>"},{"location":"concepts/config/#key-features","title":"Key Features","text":"<ul> <li>Centralized Loading - All spokes use <code>load_spoke_config()</code> for uniform config handling</li> <li>Deep Merging - Override values merge recursively with base config</li> <li>Path Expansion - Automatic expansion of <code>~</code>, <code>$VAR</code>, and <code>${env.key}</code></li> <li>Environment Awareness - Config sections can vary by active environment</li> <li>Config Caching - Efficient caching with automatic invalidation</li> <li>Override Pattern - Small focused overrides, not full config copies</li> </ul>"},{"location":"concepts/config/#file-locations","title":"File Locations","text":"<pre><code>~/.config/axium/\n\u251c\u2500\u2500 spokes/\n\u2502   \u2514\u2500\u2500 &lt;spoke-name&gt;/\n\u2502       \u2514\u2500\u2500 &lt;spoke-name&gt;.yaml    # Base config (bundled with spoke)\n\u2514\u2500\u2500 overrides/\n    \u2514\u2500\u2500 &lt;spoke-name&gt;.yaml        # User overrides (optional)\n</code></pre>"},{"location":"concepts/config/#config-structure","title":"Config Structure","text":""},{"location":"concepts/config/#base-config-bundled-with-spoke","title":"Base Config (Bundled with Spoke)","text":"<p>Located in <code>~/.config/axium/spokes/&lt;spoke&gt;/config.yaml</code>, this is the default configuration shipped with the spoke.</p> <p>Example: <code>~/.config/axium/spokes/creds/creds.yaml</code> <pre><code># Base configuration for creds spoke\ndefault:\n  check:\n    type: mtime\n    path: ~/.aws/credentials\n    max_age: 86400  # 24 hours\n  refresh:\n    command: aws sso login\n  auto_refresh: false\n\nprod:\n  check:\n    type: command\n    command: aws sts get-caller-identity --profile prod\n    expect_output: Account\n  refresh:\n    command: aws sso login --profile prod\n</code></pre></p>"},{"location":"concepts/config/#override-config-user-editable","title":"Override Config (User Editable)","text":"<p>Located in <code>~/.config/axium/overrides/&lt;spoke&gt;.yaml</code>, this contains only the values you want to change.</p> <p>Example: <code>~/.config/axium/overrides/creds.yaml</code> <pre><code># Override only what you need\ndefault:\n  auto_refresh: true    # Enable auto-refresh\n  check:\n    max_age: 43200      # Change to 12 hours\n\nstaging:\n  check:\n    type: mtime\n    path: ~/.aws/credentials-staging\n</code></pre></p> <p>Important: Do NOT copy the entire base config. Only include values you want to override.</p>"},{"location":"concepts/config/#merge-behavior","title":"Merge Behavior","text":"<p>The config system uses deep merge semantics:</p> <ul> <li>Dictionaries: Merge recursively</li> <li>Scalars (strings, numbers, booleans): Override replaces base</li> <li>Lists: Override replaces base (no union)</li> </ul>"},{"location":"concepts/config/#merge-examples","title":"Merge Examples","text":"<p>Base: <pre><code>default:\n  timeout: 30\n  retries: 3\n  nested:\n    a: 1\n    b: 2\n</code></pre></p> <p>Override: <pre><code>default:\n  timeout: 60\n  nested:\n    b: 20\n    c: 3\n</code></pre></p> <p>Result: <pre><code>default:\n  timeout: 60      # Overridden\n  retries: 3       # From base\n  nested:\n    a: 1           # From base\n    b: 20          # Overridden\n    c: 3           # From override\n</code></pre></p>"},{"location":"concepts/config/#environment-aware-config","title":"Environment-Aware Config","text":"<p>When <code>env_aware=True</code>, the config system merges sections based on the active environment:</p> <ol> <li>Load base config</li> <li>Load override config</li> <li>Merge <code>default</code> section</li> <li>Merge <code>&lt;active_env&gt;</code> section (if exists)</li> <li>Expand variables</li> </ol> <p>Example with <code>env=prod</code>: <pre><code># Base\ndefault:\n  timeout: 30\nprod:\n  timeout: 60\n\n# Result when env=prod:\n{\n  \"timeout\": 60,    # From prod section\n  ...other values from default...\n}\n</code></pre></p>"},{"location":"concepts/config/#value-expansion","title":"Value Expansion","text":"<p>The config system automatically expands:</p>"},{"location":"concepts/config/#tilde-expansion","title":"Tilde Expansion","text":"<pre><code>path: ~/data/file.txt\n# Expands to: /home/user/data/file.txt\n</code></pre>"},{"location":"concepts/config/#environment-variables","title":"Environment Variables","text":"<pre><code># Using $VAR\npath: /opt/$USER/data\n\n# Using ${VAR}\nurl: https://${REGION}.example.com\n</code></pre>"},{"location":"concepts/config/#axium-environment-values","title":"Axium Environment Values","text":"<pre><code># Reference values from active Axium environment\nbucket: s3://${env.region}/data\naccount: ${env.account_id}\n</code></pre>"},{"location":"concepts/config/#cli-commands","title":"CLI Commands","text":""},{"location":"concepts/config/#view-config-paths","title":"View Config Paths","text":"<pre><code>$ axium config path creds\nBase config (bundled):\n  ~/.config/axium/spokes/creds/creds.yaml \u2713\n\nOverride config (user editable):\n  ~/.config/axium/overrides/creds.yaml \u2717 (not found)\n\nTo create override: axium config edit creds\n</code></pre>"},{"location":"concepts/config/#show-merged-config","title":"Show Merged Config","text":"<p>The <code>axium config show</code> command queries the daemon via IPC to display configuration. The daemon is the single source of truth for all config data, ensuring consistency and security.</p> <pre><code># Show full merged config\n$ axium config show creds\nMerged Configuration (creds):\n{\n  \"check\": {\n    \"type\": \"mtime\",\n    \"path\": \"/home/user/.aws/credentials\",\n    \"max_age\": 86400\n  },\n  ...\n}\n\n# Show specific key path\n$ axium config show creds --key check.path\nMerged Configuration (creds, key: check.path):\n/home/user/.aws/credentials\n\n# Redact sensitive values (passwords, tokens, keys)\n$ axium config show creds --redact\nMerged Configuration (creds):\n{\n  \"api_key\": \"***REDACTED***\",\n  \"check\": {\n    \"type\": \"mtime\",\n    \"path\": \"/home/user/.aws/credentials\"\n  }\n}\n</code></pre> <p>Key path syntax: Use dot notation to navigate nested config: - <code>check.type</code> \u2192 <code>config[\"check\"][\"type\"]</code> - <code>nested.deep.value</code> \u2192 <code>config[\"nested\"][\"deep\"][\"value\"]</code></p> <p>Redaction patterns: The <code>--redact</code> flag masks values for keys matching: - password, passwd, pwd - secret, token, key, api_key, apikey - credential, cred, auth, authorization</p>"},{"location":"concepts/config/#edit-override-config","title":"Edit Override Config","text":"<pre><code>$ axium config edit creds\n# Opens ~/.config/axium/overrides/creds.yaml in $EDITOR\n# Creates file and template if it doesn't exist\n</code></pre>"},{"location":"concepts/config/#using-config-in-spokes","title":"Using Config in Spokes","text":""},{"location":"concepts/config/#loading-config","title":"Loading Config","text":"<pre><code>from axium.core.config import load_spoke_config\n\ndef register(app, events):\n    # Load config (env-aware)\n    config = load_spoke_config(\"creds\", \"creds.yaml\", env_aware=True)\n\n    # Access values\n    check_type = config[\"check\"][\"type\"]\n    path = config[\"check\"][\"path\"]  # Already expanded\n</code></pre>"},{"location":"concepts/config/#querying-config-via-ipc-recommended-for-spokes","title":"Querying Config via IPC (Recommended for Spokes)","text":"<p>Spokes can query config through the daemon instead of loading files directly:</p> <pre><code>from axium.core.ipc import send_request_sync\n\n# Get full config via daemon\nresp = send_request_sync({\n    \"cmd\": \"get_config\",\n    \"spoke\": \"creds\"\n})\n\nif resp[\"ok\"]:\n    config = resp[\"config\"]\n    check_type = config[\"check\"][\"type\"]\n\n# Get specific key path\nresp = send_request_sync({\n    \"cmd\": \"get_config\",\n    \"spoke\": \"creds\",\n    \"key\": \"check.path\"\n})\n\nif resp[\"ok\"]:\n    path = resp[\"config\"]  # Direct value\n</code></pre> <p>Benefits of IPC approach: - Single source of truth (daemon) - Automatic caching - Security auditing - Consistent with other spoke operations</p>"},{"location":"concepts/config/#getting-specific-values-direct-access","title":"Getting Specific Values (Direct Access)","text":"<pre><code>from axium.core.config import get_spoke_config_value\n\n# Get nested value with default (bypasses daemon)\nmax_age = get_spoke_config_value(\n    \"creds\",\n    \"check.max_age\",\n    default=86400\n)\n</code></pre>"},{"location":"concepts/config/#config-paths-helper","title":"Config Paths Helper","text":"<pre><code>from axium.core.config import get_config_paths\n\npaths = get_config_paths(\"creds\", \"creds.yaml\")\nif paths[\"override\"][\"exists\"]:\n    print(f\"Override found: {paths['override']['path']}\")\n</code></pre>"},{"location":"concepts/config/#cache-management","title":"Cache Management","text":"<p>Config is cached per <code>(spoke_name, env_name)</code> tuple for performance.</p>"},{"location":"concepts/config/#automatic-invalidation","title":"Automatic Invalidation","text":"<p>Cache is automatically invalidated on: - Spoke reload: <code>axium spoke reload &lt;spoke&gt;</code> - Environment change: <code>axium env set &lt;env&gt;</code> - Daemon restart: <code>axium daemon restart</code></p>"},{"location":"concepts/config/#manual-invalidation","title":"Manual Invalidation","text":"<pre><code>from axium.core.config import invalidate_cache\n\n# Invalidate specific spoke\ninvalidate_cache(\"creds\")\n\n# Invalidate all\ninvalidate_cache()\n</code></pre>"},{"location":"concepts/config/#best-practices","title":"Best Practices","text":""},{"location":"concepts/config/#do","title":"DO","text":"<p>\u2705 Keep overrides minimal <pre><code># Good - only override what you need\ndefault:\n  auto_refresh: true\n</code></pre></p> <p>\u2705 Use environment sections <pre><code>default:\n  timeout: 30\nprod:\n  timeout: 120\n</code></pre></p> <p>\u2705 Document your overrides <pre><code># Increase timeout for slow network\ndefault:\n  timeout: 120\n</code></pre></p>"},{"location":"concepts/config/#dont","title":"DON'T","text":"<p>\u274c Don't copy entire base config <pre><code># Bad - this is a maintenance nightmare\ndefault:\n  check:\n    type: mtime\n    path: ~/.aws/credentials\n    max_age: 86400\n  refresh:\n    command: aws sso login\n  auto_refresh: false\n  # ... 50 more lines ...\n</code></pre></p> <p>\u274c Don't hardcode paths <pre><code># Bad - not portable\npath: /Users/jdoe/my-data\n\n# Good - use tilde\npath: ~/my-data\n</code></pre></p> <p>\u274c Don't duplicate logic <pre><code># Bad - logic should be in spoke code\ndefault:\n  if_condition: true\n  then_value: x\n  else_value: y\n</code></pre></p>"},{"location":"concepts/config/#example-complete-config-workflow","title":"Example: Complete Config Workflow","text":""},{"location":"concepts/config/#1-spoke-ships-with-base-config","title":"1. Spoke Ships with Base Config","text":"<p><code>~/.config/axium/spokes/creds/creds.yaml</code>: <pre><code>default:\n  check:\n    type: mtime\n    path: ~/.aws/credentials\n    max_age: 86400\n  auto_refresh: false\n</code></pre></p>"},{"location":"concepts/config/#2-user-wants-to-customize","title":"2. User Wants to Customize","text":"<pre><code>$ axium config edit creds\n# Opens editor with template\n</code></pre>"},{"location":"concepts/config/#3-user-creates-minimal-override","title":"3. User Creates Minimal Override","text":"<p><code>~/.config/axium/overrides/creds.yaml</code>: <pre><code>default:\n  auto_refresh: true\n  check:\n    max_age: 43200  # 12 hours instead of 24\n</code></pre></p>"},{"location":"concepts/config/#4-spoke-loads-merged-config","title":"4. Spoke Loads Merged Config","text":"<pre><code>config = load_spoke_config(\"creds\", \"creds.yaml\", env_aware=True)\n# Result:\n# {\n#   \"check\": {\n#     \"type\": \"mtime\",              # From base\n#     \"path\": \"~/.aws/credentials\", # From base\n#     \"max_age\": 43200              # From override\n#   },\n#   \"auto_refresh\": true            # From override\n# }\n</code></pre>"},{"location":"concepts/config/#5-user-inspects-result","title":"5. User Inspects Result","text":"<pre><code>$ axium config show creds\nMerged Configuration (creds):\n{\n  \"check\": {\n    \"type\": \"mtime\",\n    \"path\": \"/home/user/.aws/credentials\",\n    \"max_age\": 43200\n  },\n  \"auto_refresh\": true\n}\n</code></pre>"},{"location":"concepts/config/#see-also","title":"See Also","text":"<ul> <li>Spokes - Spoke development guide</li> <li>Environments - Environment management</li> <li>Permissions - Permission system (if you create this)</li> </ul>"},{"location":"concepts/environments/","title":"Environments","text":"<p>Axium's environment system provides flexible, YAML-based context management for your terminal sessions.</p>"},{"location":"concepts/environments/#overview","title":"Overview","text":"<p>Environments allow you to define arbitrary properties and switch between different contexts seamlessly. Each environment can have any properties you need \u2014 prefix, AWS profile, region, color, etc.</p>"},{"location":"concepts/environments/#configuration","title":"Configuration","text":"<p>Environments are defined in <code>~/.config/axium/envs.yaml</code>:</p> <pre><code>envs:\n  root:\n    prefix: enva-root\n    aws_profile: root\n    color: teal\n    region: eu-west-1\n\n  builder:\n    prefix: enva-builder\n    aws_profile: builder\n    color: cyan\n    region: eu-west-2\n\n  prod:\n    prefix: enva-prod\n    aws_profile: production\n    color: red\n    region: us-east-1\n</code></pre>"},{"location":"concepts/environments/#template-variables","title":"Template Variables","text":"<p>Access environment properties using <code>${env.&lt;key&gt;}</code> syntax in configuration files:</p> <pre><code># prefixes.yaml\nprefixes:\n  - command: aws\n    prefix: ${env.prefix}\n\n  - command: terraform\n    prefix: ${env.prefix}\n</code></pre> <p>When you run <code>aws s3 ls</code>, Axium automatically expands to: <pre><code>enva-root aws s3 ls  # if active env is 'root'\n</code></pre></p>"},{"location":"concepts/environments/#cli-commands","title":"CLI Commands","text":""},{"location":"concepts/environments/#list-environments","title":"List Environments","text":"<pre><code>axium env list\n</code></pre> <p>Output: <pre><code>Available environments:\n  * root (prefix, aws_profile, color, region)\n    builder (prefix, aws_profile, color, region)\n    prod (prefix, aws_profile, color, region)\n</code></pre></p> <p>The <code>*</code> indicates the active environment.</p>"},{"location":"concepts/environments/#show-environment","title":"Show Environment","text":"<p>Show properties for a specific environment:</p> <pre><code>axium env show builder\n</code></pre> <p>Output: <pre><code>Environment: builder\n  prefix: enva-builder\n  aws_profile: builder\n  color: cyan\n  region: eu-west-2\n</code></pre></p> <p>Show active environment (no argument):</p> <pre><code>axium env show\n</code></pre>"},{"location":"concepts/environments/#set-environment","title":"Set Environment","text":"<p>Switch to a different environment:</p> <pre><code>axium env set prod\n</code></pre> <p>This updates the active environment and triggers the <code>env_change</code> event for Spokes to react.</p>"},{"location":"concepts/environments/#get-property","title":"Get Property","text":"<p>Get a specific property from the active environment:</p> <pre><code>axium env get region\n</code></pre> <p>Output: <pre><code>eu-west-1\n</code></pre></p>"},{"location":"concepts/environments/#python-api","title":"Python API","text":""},{"location":"concepts/environments/#in-spokes","title":"In Spokes","text":"<p>Import the <code>env</code> module directly:</p> <pre><code>from axium.core import env\n\ndef my_command():\n    # Get active environment name\n    env_name = env.get_active_env_name()\n    print(f\"Active environment: {env_name}\")\n\n    # Get specific property\n    region = env.get_env_value(\"region\")\n    print(f\"Region: {region}\")\n\n    # Get all environment properties\n    env_data = env.get_active_env()\n    print(f\"AWS Profile: {env_data.get('aws_profile')}\")\n</code></pre>"},{"location":"concepts/environments/#core-functions","title":"Core Functions","text":"<pre><code>from axium.core import env\n\n# Load all environments from envs.yaml\nenvs = env.load_envs()\n\n# Get active environment name\nactive_name = env.get_active_env_name()\n\n# Get all properties for active environment\nactive_env = env.get_active_env()\n\n# Get specific property from active environment\nvalue = env.get_env_value(\"prefix\")\n</code></pre>"},{"location":"concepts/environments/#event-system","title":"Event System","text":"<p>When the environment changes, Axium emits an <code>env_change</code> event:</p> <pre><code>def register(app, events):\n    def on_env_change(new_env, old_env):\n        print(f\"Environment changed: {old_env} \u2192 {new_env}\")\n\n    events.on(\"env_change\", on_env_change)\n</code></pre> <p>This allows Spokes to react to environment changes (e.g., refresh AWS credentials, update UI).</p>"},{"location":"concepts/environments/#best-practices","title":"Best Practices","text":"<ol> <li>Arbitrary Properties: Define any properties your workflow needs \u2014 Axium doesn't enforce a schema</li> <li>Consistent Naming: Use consistent property names across environments for predictable template expansion</li> <li>Color Coding: Use the <code>color</code> property for visual distinction in HUD/palette</li> <li>Prefix Convention: Use prefixes to namespace commands (e.g., <code>enva-prod</code>, <code>enva-dev</code>)</li> </ol>"},{"location":"concepts/environments/#example-use-cases","title":"Example Use Cases","text":""},{"location":"concepts/environments/#aws-multi-account-management","title":"AWS Multi-Account Management","text":"<pre><code>envs:\n  dev:\n    prefix: enva-dev\n    aws_profile: dev-account\n    aws_account_id: \"123456789012\"\n    region: eu-west-1\n\n  prod:\n    prefix: enva-prod\n    aws_profile: prod-account\n    aws_account_id: \"987654321098\"\n    region: us-east-1\n</code></pre>"},{"location":"concepts/environments/#regional-deployments","title":"Regional Deployments","text":"<pre><code>envs:\n  eu:\n    prefix: deploy-eu\n    region: eu-west-1\n    cluster: eu-prod-cluster\n\n  us:\n    prefix: deploy-us\n    region: us-east-1\n    cluster: us-prod-cluster\n</code></pre>"},{"location":"concepts/environments/#team-environments","title":"Team Environments","text":"<pre><code>envs:\n  alice:\n    prefix: dev-alice\n    namespace: alice-dev\n\n  bob:\n    prefix: dev-bob\n    namespace: bob-dev\n</code></pre>"},{"location":"concepts/environments/#see-also","title":"See Also","text":"<ul> <li>Command Prefixes - Using <code>${env.&lt;key&gt;}</code> in prefix configuration</li> <li>Writing Spokes - Reacting to environment changes</li> <li>Configuration Reference - Complete envs.yaml schema</li> </ul>"},{"location":"concepts/gears/","title":"Gears","text":"<p>Gears are Axium's privileged automation extension system \u2014 structured components with enhanced capabilities beyond regular Spokes.</p>"},{"location":"concepts/gears/#overview","title":"Overview","text":"<p>While Spokes provide lightweight plugins for commands and event handlers, Gears offer more powerful capabilities:</p> <ul> <li>Long-running job execution with tmux pane management</li> <li>Filesystem access with fine-grained read/write permissions</li> <li>IPC operations for daemon-level actions</li> <li>Background process spawning with environment context</li> <li>Prefix rule registration with conflict detection</li> <li>Enhanced security with explicit permission manifests</li> </ul>"},{"location":"concepts/gears/#gears-vs-spokes","title":"Gears vs Spokes","text":"Feature Spokes Gears CLI commands \u2713 \u2713 Event system \u2713 \u2713 Permissions required Basic Explicit manifest Filesystem access Limited Fine-grained IPC operations Read-only Privileged actions Tmux pane control \u2717 \u2713 Background processes \u2717 \u2713 Prefix registration \u2717 \u2713 Security model Permissive Sandboxed <p>When to use Gears: - Need to spawn long-running processes in tmux panes - Require filesystem read/write access - Want to register command prefixes dynamically - Need privileged IPC operations (HUD updates, notifications)</p> <p>When to use Spokes: - Simple CLI commands - Event handlers without side effects - Read-only operations - Quick integrations</p>"},{"location":"concepts/gears/#directory-structure","title":"Directory Structure","text":"<p>Gears live in <code>~/.config/axium/gears/</code>:</p> <pre><code>~/.config/axium/gears/\n  .gear_metadata.json          # Installation tracking\n  ansible/\n    gear.yaml                  # Manifest with permissions\n    main.py                    # Entry module with register()\n    ansible_runner.py          # Additional modules\n  terraform/\n    gear.yaml\n    main.py\n</code></pre>"},{"location":"concepts/gears/#gear-manifest","title":"Gear Manifest","text":"<p>Every Gear requires a <code>gear.yaml</code> manifest defining metadata and permissions:</p> <pre><code>name: ansible\nversion: 1.0.0\ndescription: Ansible automation gear with tmux integration\nauthor: Axium Team\nentrypoint: main:register\n\npermissions:\n  # Execute commands in subprocesses\n  exec: true\n\n  # Send notifications via daemon\n  notify: true\n\n  # Network access\n  net: false\n\n  # IPC actions this gear can perform\n  ipc:\n    - tmux_split_run      # Create tmux panes and run commands\n    - hud_update          # Update HUD segments\n    - notify              # Send system notifications\n    - read_file           # Read files via daemon\n    - write_file          # Write files via daemon\n\n  # Filesystem read permissions (glob patterns)\n  fs_read:\n    - ~/.ansible/**\n    - ~/.ssh/config\n    - ~/ansible/**\n\n  # Filesystem write permissions\n  fs_write:\n    - ~/.ansible/tmp/**\n    - ~/ansible/logs/**\n\n# Optional: Register command prefix rules\nprefixes:\n  - command: ansible-playbook\n    wrapper: axium ansible-run\n</code></pre>"},{"location":"concepts/gears/#manifest-fields","title":"Manifest Fields","text":"<ul> <li>name: Unique identifier (must match directory name)</li> <li>version: Semantic version string</li> <li>description: Short description for <code>axium gear list</code></li> <li>author: Gear author</li> <li>entrypoint: Python module and function (format: <code>module:function</code>)</li> <li>permissions: Permission declarations (see below)</li> <li>prefixes: Optional prefix rules to register</li> </ul>"},{"location":"concepts/gears/#permission-system","title":"Permission System","text":"<p>Gears use an explicit permission model for security:</p>"},{"location":"concepts/gears/#boolean-permissions","title":"Boolean Permissions","text":"<ul> <li>exec: Execute commands in subprocesses</li> <li>notify: Send notifications to user</li> <li>net: Make network requests</li> </ul>"},{"location":"concepts/gears/#ipc-permissions","title":"IPC Permissions","text":"<p>List of IPC actions the gear can perform via <code>axium.core.api</code>:</p> <ul> <li><code>tmux_split_run</code> - Create tmux panes and execute commands</li> <li><code>hud_update</code> - Update HUD status segments</li> <li><code>notify</code> - Send system notifications</li> <li><code>read_file</code> - Read files through daemon</li> <li><code>write_file</code> - Write files through daemon</li> <li><code>get_env_data</code> - Access environment configuration</li> </ul>"},{"location":"concepts/gears/#filesystem-permissions","title":"Filesystem Permissions","text":"<p>Glob patterns for filesystem access:</p> <pre><code>permissions:\n  fs_read:\n    - ~/.ansible/**           # Read all ansible config\n    - ~/.ssh/config           # Read SSH config\n    - ~/playbooks/**          # Read playbook files\n\n  fs_write:\n    - ~/.ansible/tmp/**       # Write to tmp directory\n    - ~/playbooks/logs/**     # Write log files\n</code></pre>"},{"location":"concepts/gears/#permission-overrides","title":"Permission Overrides","text":"<p>Users can override gear permissions in <code>~/.config/axium/overrides/permissions/&lt;gear&gt;.yaml</code>:</p> <pre><code># Override for ansible gear\nexec: true          # Allow execution\nnotify: false       # Disable notifications\n\nfs_read:\n  - ~/.ansible/**\n  - /company/ansible/**  # Add company directory\n\nipc:\n  - tmux_split_run\n  - hud_update\n  # Removed: notify (disabled above)\n</code></pre>"},{"location":"concepts/gears/#commands","title":"Commands","text":"<pre><code># View effective permissions\naxium gear perms-show ansible\n\n# Edit permission overrides\naxium gear perms-edit ansible\n</code></pre>"},{"location":"concepts/gears/#loading-lifecycle","title":"Loading Lifecycle","text":"<ol> <li>Discovery - Daemon scans <code>~/.config/axium/gears/</code> for <code>gear.yaml</code> files</li> <li>Manifest Loading - Parse <code>gear.yaml</code> for metadata and permissions</li> <li>Permission Merging - Combine base permissions with user overrides</li> <li>Registration - Import module and call <code>register(app, events)</code></li> <li>Prefix Registration - Register any prefix rules from manifest</li> <li>Activation - Gear commands and handlers become available</li> <li>Event Emission - Emit <code>gear_loaded</code> event</li> </ol>"},{"location":"concepts/gears/#loading-at-startup","title":"Loading at Startup","text":"<p>Gears load automatically when: - Daemon starts (after Spokes) - CLI commands are invoked (for command registration)</p> <pre><code># In daemon startup\nfrom axium.core import gears\n\ndiscovered = gears.discover_gears()\nfor gear_name in discovered:\n    gears.load_gear(gear_name, app, events, daemon_permissions)\n</code></pre>"},{"location":"concepts/gears/#sandboxing","title":"Sandboxing","text":"<p>Gears operate in a security sandbox:</p> <ul> <li>No direct imports between gears</li> <li>Communication via EventBus only</li> <li>All privileged operations require explicit permissions</li> <li>No shared global state between gears</li> <li>IPC permission checks on every API call</li> </ul> <p>Example:</p> <pre><code># \u2713 ALLOWED: Gear calls API with permission check\nfrom axium.core import api\n\nresult = api.tmux_split_run(\"ansible\", \"ansible-playbook site.yml\", height=20)\n# Daemon checks: does \"ansible\" gear have \"tmux_split_run\" IPC permission?\n\n# \u2717 NOT ALLOWED: Direct import between gears\nfrom other_gear import helper  # ImportError - other_gear not in sys.path\n</code></pre>"},{"location":"concepts/gears/#prefix-conflict-detection","title":"Prefix Conflict Detection","text":"<p>When gears register prefix rules, Axium detects conflicts:</p> <pre><code># gear1/gear.yaml\nprefixes:\n  - command: terraform\n    wrapper: axium tf-wrapper\n\n# gear2/gear.yaml\nprefixes:\n  - command: terraform  # \u26a0\ufe0f  CONFLICT\n    wrapper: axium other-wrapper\n</code></pre> <p>Behavior: - First gear to register wins - Conflict logged as warning - User can resolve by disabling one gear or removing prefix</p>"},{"location":"concepts/gears/#metadata-tracking","title":"Metadata Tracking","text":"<p>Gear installation is tracked in <code>.gear_metadata.json</code>:</p> <pre><code>{\n  \"ansible\": {\n    \"name\": \"ansible\",\n    \"version\": \"1.0.0\",\n    \"description\": \"Ansible automation gear\",\n    \"entrypoint\": \"main:register\",\n    \"source\": \"local:/Users/jon/gear-ansible\",\n    \"install_mode\": \"symlink\",\n    \"installed_at\": \"2025-10-13T15:30:00Z\",\n    \"last_loaded\": \"2025-10-13T16:45:00Z\",\n    \"status\": \"active\"\n  }\n}\n</code></pre> <p>Status values: - <code>active</code> - Successfully loaded and running - <code>error</code> - Failed to load (see logs) - <code>not-loaded</code> - Installed but not loaded yet</p>"},{"location":"concepts/gears/#cli-commands","title":"CLI Commands","text":"<pre><code># List installed gears\naxium gear list\n\n# View effective permissions for a gear\naxium gear perms-show ansible\n\n# Edit permission overrides\naxium gear perms-edit ansible\n</code></pre>"},{"location":"concepts/gears/#example-gear","title":"Example Gear","text":"<p>Minimal gear that adds a command and uses tmux:</p> <pre><code># ~/.config/axium/gears/example/main.py\n\ndef register(app, events):\n    \"\"\"\n    Register gear commands and event handlers.\n\n    Args:\n        app: Typer application for CLI commands\n        events: EventBus for event subscriptions\n    \"\"\"\n    from axium.core import api\n\n    @app.command(\"example-run\")\n    def example_run():\n        \"\"\"Run example command in tmux pane.\"\"\"\n        # Requires: ipc: [tmux_split_run]\n        result = api.tmux_split_run(\n            \"example\",\n            \"echo 'Hello from gear!' &amp;&amp; sleep 5\",\n            height=20\n        )\n\n        if result[\"ok\"]:\n            print(\"\u2713 Command running in pane\")\n        else:\n            print(f\"\u2717 Failed: {result.get('error')}\")\n\n    @app.command(\"example-notify\")\n    def example_notify():\n        \"\"\"Send a test notification.\"\"\"\n        # Requires: ipc: [notify]\n        api.notify_send_cli(\n            \"example\",\n            \"Test Notification\",\n            \"This is from the example gear\"\n        )\n\n    # React to environment changes\n    def on_env_change(new_env, old_env):\n        print(f\"[example] Environment changed: {old_env} \u2192 {new_env}\")\n\n    events.on(\"env_change\", on_env_change)\n</code></pre> <p>With manifest:</p> <pre><code># ~/.config/axium/gears/example/gear.yaml\nname: example\nversion: 0.1.0\ndescription: Example gear demonstrating capabilities\nauthor: Your Name\nentrypoint: main:register\n\npermissions:\n  exec: false\n  notify: true\n  net: false\n  ipc:\n    - tmux_split_run\n    - notify\n  fs_read: []\n  fs_write: []\n</code></pre> <p>Usage:</p> <pre><code>axium example-run\naxium example-notify\n</code></pre>"},{"location":"concepts/gears/#see-also","title":"See Also","text":"<ul> <li>Writing Gears - Complete guide to gear development</li> <li>Spokes - Lightweight plugin system</li> <li>Permissions - Permission system details</li> <li>API Reference - Gear API documentation</li> </ul>"},{"location":"concepts/permissions/","title":"Permission System","text":"<p>Axium provides a declarative permission system for Spokes with daemon-enforced security and user-configurable overrides.</p>"},{"location":"concepts/permissions/#overview","title":"Overview","text":"<p>Spokes declare required permissions in their <code>spoke.yaml</code> manifest. All privileged operations (exec, notify, filesystem access) are enforced by the daemon via IPC. Users can extend or restrict permissions without modifying spoke code.</p>"},{"location":"concepts/permissions/#key-features","title":"Key Features","text":"<ul> <li>Declarative Permissions - Spokes declare needs in <code>spoke.yaml</code></li> <li>Daemon Enforcement - All privileged actions go through daemon IPC</li> <li>User Overrides - Users can extend/restrict via <code>~/.config/axium/permissions.yaml</code></li> <li>Glob Matching - Filesystem permissions support wildcards</li> <li>Security Logging - All permission checks logged with <code>[SECURITY]</code> prefix</li> <li>Strict Mode - <code>AXIUM_PERMS_STRICT=1</code> disables all overrides</li> </ul>"},{"location":"concepts/permissions/#permission-types","title":"Permission Types","text":""},{"location":"concepts/permissions/#boolean-permissions","title":"Boolean Permissions","text":"<ul> <li><code>exec</code> - Allow background command execution via <code>daemon_exec</code></li> <li><code>notify</code> - Allow user notifications</li> <li><code>net</code> - (Reserved) Future HTTP request capability</li> </ul>"},{"location":"concepts/permissions/#list-permissions","title":"List Permissions","text":"<ul> <li><code>fs_read</code> - List of allowed readable paths (glob patterns)</li> <li><code>fs_write</code> - List of allowed writable paths (glob patterns)</li> </ul>"},{"location":"concepts/permissions/#declaring-permissions","title":"Declaring Permissions","text":""},{"location":"concepts/permissions/#in-spokeyaml","title":"In spoke.yaml","text":"<pre><code>name: creds\nversion: 0.1.0\ndescription: Credential validity checker\nentrypoint: main:register\npermissions:\n  exec: true                # Allow background commands\n  notify: true              # Allow notifications\n  net: false                # No network access\n  fs_read:\n    - ~/.aws/credentials    # Can read AWS creds\n    - ~/.aws/config\n    - /opt/company/creds/*  # Wildcard pattern\n  fs_write:\n    - /tmp/creds-cache/*    # Can write to cache\n</code></pre>"},{"location":"concepts/permissions/#default-permissions","title":"Default Permissions","text":"<p>If no <code>permissions</code> section exists, all permissions default to <code>false</code> and empty lists (most restrictive).</p>"},{"location":"concepts/permissions/#user-overrides","title":"User Overrides","text":"<p>Users can customize spoke permissions via <code>~/.config/axium/permissions.yaml</code>:</p> <pre><code># User permission overrides\ncreds:\n  exec: false               # Disable exec even if spoke requests it\n  fs_read:\n    - ~/.aws/credentials\n    - /extra/path/*         # Add additional path\n\naws-spoke:\n  notify: true              # Enable notifications\n  fs_write:\n    - ~/aws-logs/*          # Add write permission\n</code></pre>"},{"location":"concepts/permissions/#merge-rules","title":"Merge Rules","text":"<ul> <li>Booleans (exec, notify, net): Override replaces base value</li> <li>Lists (fs_read, fs_write): Union of base + override (deduplicated)</li> </ul> <p>Example:</p> <p>Base (spoke.yaml): <pre><code>permissions:\n  exec: true\n  fs_read:\n    - ~/.aws/credentials\n</code></pre></p> <p>Override (permissions.yaml): <pre><code>creds:\n  exec: false\n  fs_read:\n    - /opt/creds.json\n</code></pre></p> <p>Result: <pre><code>exec: false                    # Overridden\nfs_read:\n  - ~/.aws/credentials         # From base\n  - /opt/creds.json            # From override\n</code></pre></p>"},{"location":"concepts/permissions/#using-permissions-in-spokes","title":"Using Permissions in Spokes","text":""},{"location":"concepts/permissions/#sending-notifications","title":"Sending Notifications","text":"<pre><code>from axium.core.ipc import send_request_sync\n\ndef send_notification(title: str, body: str):\n    \"\"\"Send notification via daemon (requires notify permission).\"\"\"\n    try:\n        resp = send_request_sync({\n            \"cmd\": \"notify\",\n            \"spoke\": \"creds\",\n            \"title\": title,\n            \"body\": body,\n            \"level\": \"info\"\n        })\n        return resp.get(\"ok\", False)\n    except Exception:\n        return False\n</code></pre>"},{"location":"concepts/permissions/#requesting-background-execution","title":"Requesting Background Execution","text":"<pre><code>def request_daemon_exec(command: str) -&gt; bool:\n    \"\"\"Request daemon to run command in background (requires exec permission).\"\"\"\n    try:\n        resp = send_request_sync({\n            \"cmd\": \"daemon_exec\",\n            \"spoke\": \"creds\",\n            \"command\": command,\n            \"mode\": \"background\"\n        })\n        return resp.get(\"ok\", False)\n    except Exception:\n        return False\n\n# Usage\nif request_daemon_exec(\"aws sso login --profile prod\"):\n    print(\"\u2713 Refresh started in background\")\n</code></pre>"},{"location":"concepts/permissions/#updating-hud-segments","title":"Updating HUD Segments","text":"<pre><code>def update_hud_segment(value: str):\n    \"\"\"Update spoke's HUD segment (no special permission needed).\"\"\"\n    try:\n        send_request_sync({\n            \"cmd\": \"hud_segment_value\",\n            \"spoke\": \"creds\",\n            \"value\": value  # e.g., \"[creds:Y]\" or \"\"\n        })\n    except Exception:\n        pass  # Non-fatal\n</code></pre>"},{"location":"concepts/permissions/#filesystem-permissions","title":"Filesystem Permissions","text":"<p>Filesystem permissions use glob pattern matching with the <code>fnmatch</code> module (shell-style wildcards).</p>"},{"location":"concepts/permissions/#pattern-examples","title":"Pattern Examples","text":"<pre><code>fs_read:\n  - ~/.aws/credentials              # Exact file\n  - ~/.aws/*                        # All files in dir (not recursive)\n  - ~/.config/axium/**              # Recursive (all files in tree)\n  - /tmp/spoke-*.log                # Pattern matching\n  - ~/data/*.{json,yaml}            # Multiple extensions (if shell expanded)\n</code></pre>"},{"location":"concepts/permissions/#path-expansion","title":"Path Expansion","text":"<p>Paths are automatically expanded: - Tilde (<code>~</code>) \u2192 User's home directory - Environment variables work in override files</p>"},{"location":"concepts/permissions/#checking-filesystem-permissions","title":"Checking Filesystem Permissions","text":"<p>Daemon automatically checks filesystem permissions when spokes use config loading:</p> <pre><code># Config system automatically checks fs_read permissions\nconfig = load_spoke_config(\"creds\", \"creds.yaml\")\n# If creds spoke doesn't have fs_read permission for config file, loading fails\n</code></pre>"},{"location":"concepts/permissions/#cli-commands","title":"CLI Commands","text":""},{"location":"concepts/permissions/#view-permissions","title":"View Permissions","text":"<pre><code># List all spoke permissions\n$ axium perms list\nSpoke Permissions:\n\ncreds (v0.1.0)\n  exec: true (base)\n  notify: true (base)\n  net: false (base)\n  fs_read: 2 paths\n  fs_write: 1 path\n\naws (v1.0.0)\n  exec: false (base)\n  notify: true (override)\n  ...\n</code></pre>"},{"location":"concepts/permissions/#show-detailed-permissions","title":"Show Detailed Permissions","text":"<pre><code>$ axium perms show creds\nPermissions for 'creds' (v0.1.0):\n\nBoolean Permissions:\n  exec: true (base)\n  notify: true (base)\n  net: false (base)\n\nFilesystem Permissions:\n  fs_read:\n    \u2022 ~/.aws/credentials (base)\n    \u2022 ~/.aws/config (base)\n    \u2022 /opt/company/creds/* (override)\n\n  fs_write:\n    \u2022 /tmp/creds-cache/* (base)\n\nOverride source: ~/.config/axium/permissions.yaml\n</code></pre>"},{"location":"concepts/permissions/#edit-overrides","title":"Edit Overrides","text":"<pre><code>$ axium perms edit creds\n# Opens ~/.config/axium/permissions.yaml in $EDITOR\n# Creates file if it doesn't exist\n</code></pre>"},{"location":"concepts/permissions/#notification-management","title":"Notification Management","text":""},{"location":"concepts/permissions/#drain-notifications","title":"Drain Notifications","text":"<pre><code>$ axium notify drain\nQueued Notifications (2):\n\n[2025-10-07 16:30:00] creds: Credentials expired\n  Run: aws sso login or 'axium creds refresh'\n\n[2025-10-07 16:31:15] system: Update available\n  Run: axium update\n</code></pre>"},{"location":"concepts/permissions/#test-notification","title":"Test Notification","text":"<pre><code>$ axium notify send --title \"Test\" --body \"Hello world\"\n\u2713 Notification sent\n\nView with: axium notify drain\n</code></pre>"},{"location":"concepts/permissions/#security-logging","title":"Security Logging","text":"<p>All permission checks are logged with <code>[SECURITY]</code> prefix for audit trails:</p> <pre><code>[SECURITY] spoke=creds action=exec allowed=true detail=None via_override=false\n[SECURITY] spoke=creds action=notify allowed=true detail=None via_override=false\n[SECURITY] spoke=aws action=fs_read:/etc/passwd allowed=false detail=/etc/passwd via_override=false\n</code></pre>"},{"location":"concepts/permissions/#log-format","title":"Log Format","text":"<pre><code>[SECURITY] spoke=&lt;name&gt; action=&lt;action&gt; allowed=&lt;bool&gt; detail=&lt;info&gt; via_override=&lt;bool&gt;\n</code></pre> <ul> <li>spoke: Spoke name</li> <li>action: Permission type (exec, notify, fs_read:path, etc.)</li> <li>allowed: true if permitted, false if denied</li> <li>detail: Additional context (command, path, etc.)</li> <li>via_override: true if permission came from user override</li> </ul>"},{"location":"concepts/permissions/#strict-mode","title":"Strict Mode","text":"<p>Strict mode disables all user overrides, using only spoke-declared permissions. Useful for CI/CD, locked-down hosts, or security compliance.</p>"},{"location":"concepts/permissions/#enable-strict-mode","title":"Enable Strict Mode","text":"<pre><code>export AXIUM_PERMS_STRICT=1\naxium daemon restart\n</code></pre> <p>In strict mode: - All <code>~/.config/axium/permissions.yaml</code> overrides ignored - Only permissions in <code>spoke.yaml</code> are active - Logged: <code>\"Strict mode enabled, ignoring overrides for spoke: &lt;name&gt;\"</code></p>"},{"location":"concepts/permissions/#best-practices","title":"Best Practices","text":""},{"location":"concepts/permissions/#for-spoke-developers","title":"For Spoke Developers","text":"<p>\u2705 Request minimal permissions <pre><code># Good - only what you need\npermissions:\n  notify: true\n  fs_read:\n    - ~/.aws/credentials\n</code></pre></p> <p>\u2705 Document why you need permissions <pre><code># Good - explain in spoke README\npermissions:\n  exec: true  # Required to refresh credentials via 'aws sso login'\n</code></pre></p> <p>\u2705 Fail gracefully when denied <pre><code># Good - handle permission denial\nif not request_daemon_exec(command):\n    logger.warning(\"Could not refresh credentials (exec permission denied)\")\n    # Continue with cached data or manual prompt\n</code></pre></p> <p>\u274c Don't request blanket permissions <pre><code># Bad - too broad\npermissions:\n  fs_read:\n    - ~/**           # Everything in home dir!\n    - /etc/**        # All system configs!\n</code></pre></p> <p>\u274c Don't hardcode actions without permission checks <pre><code># Bad - bypasses permission system\nimport subprocess\nsubprocess.run([\"aws\", \"sso\", \"login\"])  # Should use daemon_exec\n</code></pre></p>"},{"location":"concepts/permissions/#for-users","title":"For Users","text":"<p>\u2705 Use overrides to grant additional access <pre><code># Good - allow spoke to access extra credential files\ncreds:\n  fs_read:\n    - /opt/company/special-creds.json\n</code></pre></p> <p>\u2705 Use strict mode in production <pre><code># Good - no user overrides in CI\nexport AXIUM_PERMS_STRICT=1\n</code></pre></p> <p>\u274c Don't grant excessive permissions <pre><code># Bad - defeats security model\naws-spoke:\n  exec: true\n  fs_write:\n    - ~/**  # Can write anywhere!\n</code></pre></p>"},{"location":"concepts/permissions/#architecture","title":"Architecture","text":""},{"location":"concepts/permissions/#permission-flow","title":"Permission Flow","text":"<ol> <li>Spoke declares permissions in <code>spoke.yaml</code></li> <li>Daemon loads permissions on spoke load</li> <li>User overrides merged (unless strict mode)</li> <li>Spoke requests action via IPC</li> <li>Daemon checks permission before executing</li> <li>Action allowed/denied with security log</li> <li>Response sent to spoke</li> </ol>"},{"location":"concepts/permissions/#ipc-handlers","title":"IPC Handlers","text":"<ul> <li><code>load_spoke_permissions</code> - Load/merge permissions on spoke load</li> <li><code>notify</code> - Check notify permission, queue notification</li> <li><code>daemon_exec</code> - Check exec permission, run background command</li> <li><code>get_permissions</code> - Return effective permissions for spoke</li> <li><code>notify_drain</code> - Return and clear notification queue</li> </ul>"},{"location":"concepts/permissions/#example-complete-workflow","title":"Example: Complete Workflow","text":""},{"location":"concepts/permissions/#1-spoke-declares-permissions","title":"1. Spoke Declares Permissions","text":"<p><code>spokes/creds/spoke.yaml</code>: <pre><code>name: creds\npermissions:\n  exec: true\n  notify: true\n  fs_read:\n    - ~/.aws/credentials\n</code></pre></p>"},{"location":"concepts/permissions/#2-user-adds-override","title":"2. User Adds Override","text":"<pre><code>$ axium perms edit creds\n</code></pre> <p><code>~/.config/axium/permissions.yaml</code>: <pre><code>creds:\n  exec: false  # Disable auto-refresh\n  fs_read:\n    - ~/extra-creds.json\n</code></pre></p>"},{"location":"concepts/permissions/#3-daemon-loads-merged-permissions","title":"3. Daemon Loads Merged Permissions","text":"<pre><code># Result:\n{\n  \"exec\": false,                  # From override\n  \"notify\": true,                 # From base\n  \"fs_read\": [\n    \"~/.aws/credentials\",         # From base\n    \"~/extra-creds.json\"          # From override\n  ]\n}\n</code></pre>"},{"location":"concepts/permissions/#4-spoke-requests-action","title":"4. Spoke Requests Action","text":"<pre><code># Spoke tries to refresh\nresult = request_daemon_exec(\"aws sso login\")\n# Returns: False (exec denied by override)\n</code></pre>"},{"location":"concepts/permissions/#5-security-log","title":"5. Security Log","text":"<pre><code>[SECURITY] spoke=creds action=exec allowed=false detail=aws sso login via_override=true\n</code></pre>"},{"location":"concepts/permissions/#see-also","title":"See Also","text":"<ul> <li>Configuration - Config system documentation</li> <li>Spokes - Spoke development guide</li> <li>Security - Security considerations (if exists)</li> </ul>"},{"location":"concepts/prefixes/","title":"Command Prefixes","text":"<p>Axium's prefix system allows transparent command wrapping \u2014 intercepting commands and prepending context-aware prefixes before execution.</p>"},{"location":"concepts/prefixes/#overview","title":"Overview","text":"<p>Command prefixes enable workflows like:</p> <pre><code>aws s3 ls  # Automatically becomes: enva-root aws s3 ls\n</code></pre> <p>This is powerful for: - AWS multi-account management (using <code>aws-vault</code> or similar) - Terraform workspace switching - Docker context switching - Any tool that needs context injection</p>"},{"location":"concepts/prefixes/#configuration","title":"Configuration","text":"<p>Prefixes are defined in <code>~/.config/axium/prefixes.yaml</code>:</p> <pre><code>prefixes:\n  - command: aws\n    prefix: ${env.prefix}\n\n  - command: terraform\n    prefix: ${env.prefix}\n\n  - command: kubectl\n    prefix: \"kubecontext-${env.cluster}\"\n</code></pre>"},{"location":"concepts/prefixes/#template-expansion","title":"Template Expansion","text":"<p>Use <code>${env.&lt;key&gt;}</code> to reference environment properties:</p> <pre><code>prefixes:\n  - command: aws\n    prefix: ${env.prefix}  # Expands to 'enva-root' if env.prefix = 'enva-root'\n\n  - command: docker\n    prefix: \"DOCKER_HOST=${env.docker_host}\"  # Expands to full env var\n</code></pre> <p>When you switch environments with <code>axium env set</code>, the prefix automatically updates.</p>"},{"location":"concepts/prefixes/#shell-integration","title":"Shell Integration","text":"<p>Axium's shell integration (<code>bash/init.sh</code>) wraps configured commands automatically:</p> <pre><code># In your shell\naws s3 ls\n\n# Actually executes\nenva-root aws s3 ls\n</code></pre> <p>The wrapping is transparent \u2014 you type normal commands, Axium handles the prefix injection.</p>"},{"location":"concepts/prefixes/#example-workflows","title":"Example Workflows","text":""},{"location":"concepts/prefixes/#aws-multi-account","title":"AWS Multi-Account","text":"<pre><code># envs.yaml\nenvs:\n  dev:\n    prefix: aws-vault exec dev --\n  prod:\n    prefix: aws-vault exec prod --\n\n# prefixes.yaml\nprefixes:\n  - command: aws\n    prefix: ${env.prefix}\n</code></pre> <p>Now: <pre><code>axium env set dev\naws s3 ls  # \u2192 aws-vault exec dev -- aws s3 ls\n\naxium env set prod\naws s3 ls  # \u2192 aws-vault exec prod -- aws s3 ls\n</code></pre></p>"},{"location":"concepts/prefixes/#terraform-workspaces","title":"Terraform Workspaces","text":"<pre><code># envs.yaml\nenvs:\n  staging:\n    prefix: terraform-workspace-staging\n  prod:\n    prefix: terraform-workspace-prod\n\n# prefixes.yaml\nprefixes:\n  - command: terraform\n    prefix: ${env.prefix}\n</code></pre>"},{"location":"concepts/prefixes/#docker-contexts","title":"Docker Contexts","text":"<pre><code># envs.yaml\nenvs:\n  local:\n    docker_context: default\n  remote:\n    docker_context: remote-host\n\n# prefixes.yaml\nprefixes:\n  - command: docker\n    prefix: \"docker --context ${env.docker_context}\"\n</code></pre>"},{"location":"concepts/prefixes/#python-api","title":"Python API","text":""},{"location":"concepts/prefixes/#expand-templates","title":"Expand Templates","text":"<pre><code>from axium.core.prefix import expand_env_vars\n\ntemplate = \"${env.prefix}\"\nexpanded = expand_env_vars(template)  # \u2192 \"enva-root\"\n\ntemplate = \"Using ${env.prefix} in ${env.region}\"\nexpanded = expand_env_vars(template)  # \u2192 \"Using enva-root in eu-west-1\"\n</code></pre>"},{"location":"concepts/prefixes/#load-prefixes","title":"Load Prefixes","text":"<pre><code>from axium.core.prefix import load_prefixes\n\nprefixes = load_prefixes()\n# Returns: [{\"command\": \"aws\", \"prefix\": \"enva-root\"}, ...]\n</code></pre>"},{"location":"concepts/prefixes/#advanced-usage","title":"Advanced Usage","text":""},{"location":"concepts/prefixes/#conditional-prefixes","title":"Conditional Prefixes","text":"<p>You can use different prefixes for different environments:</p> <pre><code># envs.yaml\nenvs:\n  dev:\n    prefix: \"\"  # No prefix for dev\n  prod:\n    prefix: aws-vault exec prod --\n\n# prefixes.yaml\nprefixes:\n  - command: aws\n    prefix: ${env.prefix}\n</code></pre> <p>In dev: <code>aws s3 ls</code> runs as-is In prod: <code>aws s3 ls</code> \u2192 <code>aws-vault exec prod -- aws s3 ls</code></p>"},{"location":"concepts/prefixes/#multiple-commands","title":"Multiple Commands","text":"<p>Wrap multiple commands with the same prefix:</p> <pre><code>prefixes:\n  - command: aws\n    prefix: ${env.prefix}\n  - command: terraform\n    prefix: ${env.prefix}\n  - command: kubectl\n    prefix: ${env.prefix}\n</code></pre>"},{"location":"concepts/prefixes/#best-practices","title":"Best Practices","text":"<ol> <li>Use Templates: Always use <code>${env.&lt;key&gt;}</code> instead of hardcoding values</li> <li>Test First: Set up prefixes in dev environment before rolling to prod</li> <li>Keep it Simple: Prefixes should be single commands or simple wrappers</li> <li>Document Assumptions: If your prefix expects specific tools (e.g., <code>aws-vault</code>), document in envs.yaml comments</li> </ol>"},{"location":"concepts/prefixes/#troubleshooting","title":"Troubleshooting","text":""},{"location":"concepts/prefixes/#prefix-not-expanding","title":"Prefix Not Expanding","text":"<p>Check that: 1. The environment property exists: <code>axium env show</code> 2. The template syntax is correct: <code>${env.key}</code> not <code>${env_key}</code> 3. The daemon is running: <code>axium daemon status</code></p>"},{"location":"concepts/prefixes/#command-not-being-wrapped","title":"Command Not Being Wrapped","text":"<p>Verify: 1. Shell integration is loaded: <code>source bash/init.sh</code> 2. The command is in prefixes.yaml 3. The prefix expansion is valid: <code>axium env get prefix</code></p>"},{"location":"concepts/prefixes/#see-also","title":"See Also","text":"<ul> <li>Environments - Defining environment properties</li> <li>Configuration Reference - Complete prefixes.yaml schema</li> <li>Examples - Real-world prefix configurations</li> </ul>"},{"location":"concepts/registry/","title":"Command Registry","text":"<p>The Command Registry is Axium's dynamic command discovery system that powers the interactive palette and enables automatic command cataloging.</p>"},{"location":"concepts/registry/#overview","title":"Overview","text":"<p>Every command registered with Axium's Typer CLI\u2014whether from core or from Spokes\u2014is automatically captured and cataloged in a global registry. This enables:</p> <ul> <li>Dynamic command discovery in the palette</li> <li>Source attribution (core vs spoke commands)</li> <li>Automatic command listing without manual maintenance</li> <li>Metadata preservation (help text, groups, callbacks)</li> </ul>"},{"location":"concepts/registry/#how-it-works","title":"How It Works","text":""},{"location":"concepts/registry/#automatic-registration","title":"Automatic Registration","text":"<p>Commands are registered automatically during Axium initialization:</p> <ol> <li>Core commands are introspected after <code>load_spokes()</code> completes</li> <li>Spoke commands are tagged as each Spoke's <code>register()</code> function runs</li> <li>Command metadata is extracted from Typer's internal structures</li> </ol> <pre><code># In cli.py _autoload() callback\nload_spokes(app)\nregistry.introspect_typer_app(app, source=\"core\")\n</code></pre>"},{"location":"concepts/registry/#command-metadata","title":"Command Metadata","text":"<p>Each registered command includes:</p> <pre><code>{\n    \"name\": \"daemon start\",      # Full command path\n    \"help\": \"Start the daemon\",  # From docstring\n    \"source\": \"core\",            # \"core\" or spoke name\n    \"group\": \"daemon\"            # Parent group if applicable\n}\n</code></pre>"},{"location":"concepts/registry/#using-the-registry","title":"Using the Registry","text":""},{"location":"concepts/registry/#in-the-palette","title":"In the Palette","text":"<p>The palette dynamically builds its menu from the registry:</p> <pre><code>$ axium palette\n\u2554\u2550\u2550 Axium Palette \u2550\u2550\u2557\n&gt; [core] daemon start\n  [core] daemon status\n  [core] env set\n  [core] env get\n  [aws] whoami\n  quit\n</code></pre> <p>Commands are tagged with <code>[source]</code> to show their origin.</p>"},{"location":"concepts/registry/#reloading-commands","title":"Reloading Commands","text":"<p>Use <code>--reload</code> to refresh the command list after installing new Spokes:</p> <pre><code>$ axium palette --reload\n</code></pre> <p>This clears the registry and re-introspects all commands, picking up any newly installed Spokes.</p>"},{"location":"concepts/registry/#programmatic-access","title":"Programmatic Access","text":"<p>The registry can be queried programmatically:</p> <pre><code>from axium.core import registry\n\n# Get all commands (sorted alphabetically)\ncommands = registry.get_all_commands()\n\n# Get commands from specific source\ncore_commands = registry.get_commands_by_source(\"core\")\naws_commands = registry.get_commands_by_source(\"aws\")\n\n# Get commands with grouped sorting (core first)\ncommands = registry.get_all_commands(sort_by=\"grouped\")\n</code></pre>"},{"location":"concepts/registry/#spoke-integration","title":"Spoke Integration","text":"<p>When Spokes register commands, they're automatically tagged:</p> <pre><code># In a Spoke's register function\ndef register(app, events):\n    @app.command(\"whoami\")\n    def aws_whoami():\n        \"\"\"Get AWS caller identity.\"\"\"\n        import boto3\n        print(boto3.client(\"sts\").get_caller_identity())\n</code></pre> <p>After loading, this command appears in the registry as:</p> <pre><code>{\n    \"name\": \"whoami\",\n    \"help\": \"Get AWS caller identity.\",\n    \"source\": \"aws\",\n    \"group\": None\n}\n</code></pre>"},{"location":"concepts/registry/#registry-api","title":"Registry API","text":""},{"location":"concepts/registry/#functions","title":"Functions","text":"<p><code>register_command(name, help, source, group=None, callback=None)</code> - Manually register a command (rarely needed) - Warns if overwriting existing command</p> <p><code>get_all_commands(sort_by=\"alpha\")</code> - Get all registered commands - Sort options: <code>\"alpha\"</code>, <code>\"grouped\"</code>, <code>\"usage\"</code> (future)</p> <p><code>get_commands_by_source(source)</code> - Filter commands by source</p> <p><code>clear_registry()</code> - Clear all registered commands - Used for testing and <code>--reload</code></p> <p><code>introspect_typer_app(app, source, prefix=\"\")</code> - Walk Typer app structure and register commands - Handles nested subgroups recursively - Called automatically during initialization</p>"},{"location":"concepts/registry/#implementation-details","title":"Implementation Details","text":""},{"location":"concepts/registry/#when-commands-are-registered","title":"When Commands Are Registered","text":"<pre><code>CLI Startup\n    \u2193\n_autoload() callback\n    \u2193\nload_spokes(app)\n    \u251c\u2500 For each spoke:\n    \u2502   \u251c\u2500 spoke.register(app, events)\n    \u2502   \u2514\u2500 introspect_typer_app(app, source=spoke_name)\n    \u2502\n    \u2514\u2500 introspect_typer_app(app, source=\"core\")\n\nResult: All commands now in registry\n</code></pre>"},{"location":"concepts/registry/#introspection-process","title":"Introspection Process","text":"<p>The <code>introspect_typer_app()</code> function:</p> <ol> <li>Iterates <code>app.registered_commands</code> (direct commands)</li> <li>Iterates <code>app.registered_groups</code> (subcommands)</li> <li>Recursively processes nested groups</li> <li>Extracts metadata from Typer's CommandInfo objects</li> <li>Registers each command with appropriate source tag</li> </ol>"},{"location":"concepts/registry/#command-naming","title":"Command Naming","text":"<ul> <li>Root commands: Use function name or explicit <code>@app.command(\"name\")</code></li> <li>Subcommands: Full path with group prefix (<code>\"daemon start\"</code>)</li> <li>Nested groups: Multiple prefixes (<code>\"l1 l2 deep\"</code>)</li> </ul>"},{"location":"concepts/registry/#best-practices","title":"Best Practices","text":""},{"location":"concepts/registry/#for-core-development","title":"For Core Development","text":"<ul> <li>No manual updates needed\u2014commands auto-register</li> <li>Use clear docstrings (first line becomes help text)</li> <li>Group related commands with <code>typer.Typer()</code> subapps</li> </ul>"},{"location":"concepts/registry/#for-spoke-development","title":"For Spoke Development","text":"<ul> <li>Commands automatically tagged with spoke name</li> <li>No special registration needed</li> <li>Help text extracted from docstrings</li> <li>Multiple commands per spoke fully supported</li> </ul>"},{"location":"concepts/registry/#for-testing","title":"For Testing","text":"<ul> <li>Use <code>clean_registry</code> fixture to reset between tests</li> <li>Test with mock Typer apps for isolation</li> <li>Verify source tagging with <code>get_commands_by_source()</code></li> </ul>"},{"location":"concepts/registry/#future-enhancements","title":"Future Enhancements","text":"<p>Planned registry features:</p> <ul> <li>Usage tracking: Sort by frequency in palette</li> <li>Command history: Persistent favorites</li> <li>Search/filter: Fuzzy find in palette</li> <li>Command aliases: User-defined shortcuts</li> <li>Help browser: TUI for exploring command documentation</li> </ul>"},{"location":"concepts/registry/#see-also","title":"See Also","text":"<ul> <li>Palette Guide - Using the interactive palette</li> <li>Spokes Documentation - Plugin system overview</li> <li>CLI Reference - Core commands</li> </ul>"},{"location":"concepts/spokes/","title":"Spokes","text":"<p>Spokes are Axium's plugin system \u2014 modular extensions that add commands, react to events, and integrate with external tools without modifying the core.</p>"},{"location":"concepts/spokes/#overview","title":"Overview","text":"<p>Spokes allow you to: - Add custom CLI commands - React to environment changes - Integrate with AWS, Kubernetes, Docker, etc. - Extend the HUD and palette - Share functionality across teams</p>"},{"location":"concepts/spokes/#architecture","title":"Architecture","text":"<p>Each Spoke lives in <code>~/.config/axium/spokes/&lt;spoke-name&gt;/</code>:</p> <pre><code>~/.config/axium/spokes/\n  aws/\n    spoke.yaml       # Manifest\n    aws_spoke.py     # Implementation\n  k8s/\n    spoke.yaml\n    k8s_spoke.py\n</code></pre>"},{"location":"concepts/spokes/#spoke-manifest","title":"Spoke Manifest","text":"<p>Every Spoke has a <code>spoke.yaml</code> manifest:</p> <pre><code>name: aws\nversion: 1.0.0\ndescription: AWS operations and utilities\nentrypoint: aws_spoke:register\npermissions:\n  exec: false\n  notify: true\n  fs_read:\n    - ~/.aws/credentials\n    - ~/.aws/config\n  fs_write: []\n</code></pre> <ul> <li><code>name</code>: Unique identifier for the Spoke</li> <li><code>version</code>: Semantic version string</li> <li><code>description</code>: Short description for spoke list</li> <li><code>entrypoint</code>: Python module and function to call (format: <code>module:function</code>)</li> <li><code>permissions</code>: Permissions required by the spoke (see Permissions)</li> </ul>"},{"location":"concepts/spokes/#basic-spoke","title":"Basic Spoke","text":"<p>Here's a minimal Spoke that adds a command:</p> <pre><code># ~/.config/axium/spokes/aws/aws_spoke.py\n\ndef register(app, events):\n    \"\"\"\n    Register Spoke commands and event handlers.\n\n    Args:\n        app: Typer application instance\n        events: EventBus instance\n    \"\"\"\n    @app.command(\"aws-whoami\")\n    def aws_whoami():\n        \"\"\"Show current AWS identity.\"\"\"\n        import boto3\n        sts = boto3.client(\"sts\")\n        identity = sts.get_caller_identity()\n        print(f\"Account: {identity['Account']}\")\n        print(f\"User: {identity['Arn']}\")\n</code></pre> <p>Now you can run: <pre><code>axium aws-whoami\n</code></pre></p>"},{"location":"concepts/spokes/#event-system","title":"Event System","text":"<p>Spokes can react to events using the EventBus:</p> <pre><code>def register(app, events):\n    # React to environment changes\n    def on_env_change(new_env, old_env):\n        print(f\"Environment changed: {old_env} \u2192 {new_env}\")\n        # Refresh credentials, update state, etc.\n\n    events.on(\"env_change\", on_env_change)\n\n    # React to Spoke loading\n    def on_spoke_loaded(spoke_name):\n        if spoke_name == \"aws\":\n            print(\"AWS Spoke loaded!\")\n\n    events.on(\"spoke_loaded\", on_spoke_loaded)\n</code></pre>"},{"location":"concepts/spokes/#available-events","title":"Available Events","text":"<ul> <li><code>env_change(new_env, old_env)</code> - Environment switched</li> <li><code>spoke_loaded(spoke_name)</code> - Spoke finished loading</li> </ul>"},{"location":"concepts/spokes/#accessing-environment","title":"Accessing Environment","text":"<p>Import the <code>env</code> module to access environment properties:</p> <pre><code>from axium.core import env\n\ndef register(app, events):\n    @app.command(\"show-region\")\n    def show_region():\n        \"\"\"Show current region from environment.\"\"\"\n        region = env.get_env_value(\"region\")\n        env_name = env.get_active_env_name()\n        print(f\"Environment: {env_name}\")\n        print(f\"Region: {region}\")\n</code></pre>"},{"location":"concepts/spokes/#example-spokes","title":"Example Spokes","text":""},{"location":"concepts/spokes/#aws-profile-manager","title":"AWS Profile Manager","text":"<pre><code># aws_spoke.py\nfrom axium.core import env\nimport os\n\ndef register(app, events):\n    def on_env_change(new_env, old_env):\n        \"\"\"Update AWS_PROFILE when environment changes.\"\"\"\n        envs = env.load_envs()\n        env_data = envs.get(new_env, {})\n        aws_profile = env_data.get(\"aws_profile\")\n\n        if aws_profile:\n            os.environ[\"AWS_PROFILE\"] = aws_profile\n            print(f\"AWS_PROFILE \u2192 {aws_profile}\")\n\n    events.on(\"env_change\", on_env_change)\n\n    @app.command(\"aws-whoami\")\n    def aws_whoami():\n        \"\"\"Show current AWS identity.\"\"\"\n        import boto3\n        sts = boto3.client(\"sts\")\n        identity = sts.get_caller_identity()\n        print(f\"Account: {identity['Account']}\")\n        print(f\"ARN: {identity['Arn']}\")\n</code></pre>"},{"location":"concepts/spokes/#kubernetes-context-switcher","title":"Kubernetes Context Switcher","text":"<pre><code># k8s_spoke.py\nfrom axium.core import env\nimport subprocess\n\ndef register(app, events):\n    def on_env_change(new_env, old_env):\n        \"\"\"Switch kubectl context when environment changes.\"\"\"\n        context = env.get_env_value(\"k8s_context\")\n        if context:\n            subprocess.run([\"kubectl\", \"config\", \"use-context\", context])\n            print(f\"kubectl context \u2192 {context}\")\n\n    events.on(\"env_change\", on_env_change)\n\n    @app.command(\"k8s-pods\")\n    def k8s_pods():\n        \"\"\"List pods in current context.\"\"\"\n        result = subprocess.run(\n            [\"kubectl\", \"get\", \"pods\"],\n            capture_output=True,\n            text=True\n        )\n        print(result.stdout)\n</code></pre>"},{"location":"concepts/spokes/#configuration","title":"Configuration","text":"<p>Spokes should use the centralized config system instead of implementing their own config loading. See Configuration for details.</p>"},{"location":"concepts/spokes/#loading-config","title":"Loading Config","text":"<pre><code>from axium.core.config import load_spoke_config\n\ndef register(app, events):\n    # Load spoke configuration (env-aware)\n    config = load_spoke_config(\"creds\", \"creds.yaml\", env_aware=True)\n\n    # Access values (already expanded)\n    timeout = config[\"timeout\"]\n    path = config[\"path\"]  # Tilde and vars already expanded\n</code></pre>"},{"location":"concepts/spokes/#config-file-structure","title":"Config File Structure","text":"<p>Create <code>&lt;spoke-name&gt;.yaml</code> in your spoke directory:</p> <pre><code># ~/.config/axium/spokes/creds/creds.yaml\ndefault:\n  timeout: 30\n  check:\n    type: mtime\n    path: ~/.aws/credentials\n\nprod:\n  timeout: 60\n  check:\n    type: command\n    command: aws sts get-caller-identity\n</code></pre> <p>Users can override values without modifying your spoke:</p> <pre><code>$ axium config edit creds\n# Creates ~/.config/axium/overrides/creds.yaml\n</code></pre> <p>See Configuration for complete documentation.</p>"},{"location":"concepts/spokes/#permissions","title":"Permissions","text":"<p>Spokes must declare required permissions in <code>spoke.yaml</code>. All privileged operations are enforced by the daemon. See Permissions for details.</p>"},{"location":"concepts/spokes/#requesting-background-execution","title":"Requesting Background Execution","text":"<pre><code>from axium.core.ipc import send_request_sync\n\ndef refresh_credentials():\n    \"\"\"Refresh credentials via daemon (requires exec permission).\"\"\"\n    resp = send_request_sync({\n        \"cmd\": \"daemon_exec\",\n        \"spoke\": \"creds\",\n        \"command\": \"aws sso login --profile prod\",\n        \"mode\": \"background\"\n    })\n    return resp.get(\"ok\", False)\n</code></pre>"},{"location":"concepts/spokes/#sending-notifications","title":"Sending Notifications","text":"<pre><code>def notify_user(title: str, message: str):\n    \"\"\"Send notification (requires notify permission).\"\"\"\n    try:\n        send_request_sync({\n            \"cmd\": \"notify\",\n            \"spoke\": \"creds\",\n            \"title\": title,\n            \"body\": message,\n            \"level\": \"info\"\n        })\n    except Exception:\n        pass  # Non-fatal\n</code></pre>"},{"location":"concepts/spokes/#updating-hud","title":"Updating HUD","text":"<pre><code>def update_hud(is_valid: bool):\n    \"\"\"Update HUD segment (no special permission required).\"\"\"\n    value = \"[creds:Y]\" if is_valid else \"[creds:N]\"\n    try:\n        send_request_sync({\n            \"cmd\": \"hud_segment_value\",\n            \"spoke\": \"creds\",\n            \"value\": value\n        })\n    except Exception:\n        pass\n</code></pre>"},{"location":"concepts/spokes/#best-practices","title":"Best Practices","text":"<ol> <li>Command Naming: Prefix commands with spoke name (e.g., <code>aws-whoami</code>, <code>k8s-pods</code>)</li> <li>Configuration: Use <code>load_spoke_config()</code> instead of custom config loading</li> <li>Permissions: Request minimal permissions needed, fail gracefully when denied</li> <li>Graceful Degradation: Handle missing dependencies and daemon unavailability</li> <li>Event Handlers: Keep handlers fast \u2014 don't block the event loop</li> <li>Environment Access: Use <code>env.get_env_value()</code> instead of reading files directly</li> <li>Documentation: Add docstrings to all commands for <code>axium --help</code></li> </ol>"},{"location":"concepts/spokes/#testing-spokes","title":"Testing Spokes","text":"<p>Create a test file in your Spoke directory:</p> <pre><code># test_aws_spoke.py\nimport pytest\nfrom aws_spoke import register\n\ndef test_register():\n    \"\"\"Test Spoke registration.\"\"\"\n    from typer import Typer\n    from axium.core.spokes import EventBus\n\n    app = Typer()\n    events = EventBus()\n\n    register(app, events)\n\n    # Verify command registered\n    assert any(cmd.name == \"aws-whoami\" for cmd in app.registered_commands)\n</code></pre> <p>Run tests: <pre><code>pytest ~/.config/axium/spokes/aws/\n</code></pre></p>"},{"location":"concepts/spokes/#distributing-spokes","title":"Distributing Spokes","text":""},{"location":"concepts/spokes/#as-git-repositories","title":"As Git Repositories","text":"<pre><code>cd ~/.config/axium/spokes/\ngit clone https://github.com/your-org/axium-spoke-aws.git aws\naxium daemon reload\n</code></pre>"},{"location":"concepts/spokes/#as-python-packages","title":"As Python Packages","text":"<pre><code>pip install axium-spoke-aws\n# Package installs to ~/.config/axium/spokes/aws/\naxium daemon reload\n</code></pre>"},{"location":"concepts/spokes/#see-also","title":"See Also","text":"<ul> <li>Configuration - Centralized config system</li> <li>Permissions - Permission system and security</li> <li>Writing Spokes Guide - Detailed tutorial</li> <li>API Reference - Complete API documentation</li> <li>Examples - Example Spoke implementations</li> </ul>"},{"location":"concepts/tmux-integration/","title":"tmux Integration","text":"<p>Axium provides deep integration with tmux, enabling per-pane environment contexts and rich status line displays.</p>"},{"location":"concepts/tmux-integration/#overview","title":"Overview","text":"<p>When running inside tmux, Axium automatically detects pane IDs and maintains independent environment contexts for each pane. This allows you to work with different environments simultaneously in different panes.</p>"},{"location":"concepts/tmux-integration/#features","title":"Features","text":""},{"location":"concepts/tmux-integration/#per-pane-environments","title":"Per-Pane Environments","text":"<p>Each tmux pane can have its own active environment:</p> <pre><code># In pane %1\n$ axium env set prod\naxium: pane %1 env set \u2192 prod\n\n# In pane %2 (different environment)\n$ axium env set dev\naxium: pane %2 env set \u2192 dev\n</code></pre> <p>The daemon maintains a mapping of pane IDs to environments:</p> <pre><code>{\n  \"panes\": {\n    \"%1\": \"prod\",\n    \"%2\": \"dev\",\n    \"%3\": \"staging\"\n  }\n}\n</code></pre>"},{"location":"concepts/tmux-integration/#hud-status-line","title":"HUD Status Line","text":"<p>Axium integrates with tmux's status line via the <code>axium hud</code> command:</p> <pre><code>$ axium hud --pane %1\n[axium] pane:%1  env:prod  aws:production  uptime:2h15m\n</code></pre> <p>The HUD displays: - Current pane ID - Active environment for the pane - AWS profile (if set) - Daemon uptime - Custom segments from Spokes (extensible)</p>"},{"location":"concepts/tmux-integration/#palette-keybinding","title":"Palette Keybinding","text":"<p>Press <code>Ctrl+G</code> in any tmux pane to launch the Axium palette:</p> <pre><code>\u2554\u2550\u2550 Axium Palette \u2550\u2550\u2557  pane:%1 env:prod\n  [core] daemon start\n  [core] daemon status\n  [core] env set\n&gt; [core] env get\n  [aws] whoami\n  quit\n</code></pre> <p>The palette header shows your current pane and environment context.</p>"},{"location":"concepts/tmux-integration/#setup","title":"Setup","text":""},{"location":"concepts/tmux-integration/#1-source-axium-shell-integration","title":"1. Source Axium Shell Integration","text":"<p>Add to your <code>~/.bashrc</code> or <code>~/.zshrc</code>:</p> <pre><code>source ~/.config/axium/bash/init.sh\n</code></pre> <p>This automatically loads tmux integration when you're in a tmux session.</p>"},{"location":"concepts/tmux-integration/#2-tmux-configuration","title":"2. tmux Configuration","text":"<p>The <code>~/.config/axium/tmux/init.sh</code> file is created automatically by Axium on first run. It provides modular helper functions that you can enable selectively.</p>"},{"location":"concepts/tmux-integration/#default-mode-automatic","title":"Default Mode (Automatic)","text":"<p>By default, Axium enables: - Status Line: Sets <code>status-right</code> to display Axium HUD - Keybinding: Binds <code>Ctrl+G</code> to launch palette - Pane Restore: Restores pane environment on shell init (always enabled)</p>"},{"location":"concepts/tmux-integration/#minimal-mode-full-control","title":"Minimal Mode (Full Control)","text":"<p>Set <code>AXIUM_TMUX_MINIMAL=1</code> to disable automatic configuration:</p> <pre><code># In your ~/.bashrc or ~/.zshrc (before sourcing bash/init.sh)\nexport AXIUM_TMUX_MINIMAL=1\nsource ~/.config/axium/bash/init.sh\n</code></pre> <p>Then selectively enable features by calling helper functions:</p> <pre><code># Enable only HUD (no palette keybinding)\naxium_tmux_enable_hud\n\n# Enable only palette keybinding (no HUD)\naxium_tmux_enable_palette\n\n# Enable both (equivalent to default mode)\naxium_tmux_enable_hud\naxium_tmux_enable_palette\n\n# Add custom segments (for Spokes or user scripts)\naxium_tmux_enable_segment \"kubectl config current-context\" \"cyan\"\n</code></pre>"},{"location":"concepts/tmux-integration/#manual-setup-alternative","title":"Manual Setup (Alternative)","text":"<p>If you prefer managing tmux configuration in <code>~/.tmux.conf</code>:</p> <pre><code># In your ~/.tmux.conf\nset -g status-right '#(axium hud --pane #D)'\nset -g status-right-length 100\nset -g status-interval 5\nbind-key -n C-g run-shell \"tmux send-keys 'axium palette' Enter\"\n</code></pre>"},{"location":"concepts/tmux-integration/#3-start-axium-daemon","title":"3. Start Axium Daemon","text":"<pre><code>axium daemon start\n</code></pre>"},{"location":"concepts/tmux-integration/#usage","title":"Usage","text":""},{"location":"concepts/tmux-integration/#setting-pane-environment","title":"Setting Pane Environment","text":"<p>In tmux, <code>axium env set</code> automatically detects the current pane:</p> <pre><code>$ axium env set prod\naxium: pane %1 env set \u2192 prod\n</code></pre> <p>Outside tmux, it sets the global environment:</p> <pre><code>$ axium env set prod\naxium: env set \u2192 prod\n</code></pre>"},{"location":"concepts/tmux-integration/#querying-pane-environment","title":"Querying Pane Environment","text":"<p>Get the current pane's environment:</p> <pre><code>$ axium env get\nprod\n</code></pre> <p>Query a specific pane:</p> <pre><code>$ axium env get --pane %2\ndev\n</code></pre>"},{"location":"concepts/tmux-integration/#listing-pane-mappings","title":"Listing Pane Mappings","text":"<p>Show all pane-to-environment mappings:</p> <pre><code>$ axium env list --panes\nAvailable environments:\n  * prod (prefix, aws_profile, region, color)\n    dev (prefix, aws_profile, region, color)\n\nPane Mappings:\n  %1 \u2192 prod\n  %2 \u2192 dev\n  %3 \u2192 staging\n</code></pre>"},{"location":"concepts/tmux-integration/#running-commands-with-pane-context","title":"Running Commands with Pane Context","text":"<p>When you run commands via <code>axium run</code>, the daemon uses the pane's environment:</p> <pre><code># In pane %1 (env: prod)\n$ aws s3 ls\n# Actually runs: enva-prod aws s3 ls\n\n# In pane %2 (env: dev)\n$ aws s3 ls\n# Actually runs: enva-dev aws s3 ls\n</code></pre>"},{"location":"concepts/tmux-integration/#spoke-integration","title":"Spoke Integration","text":"<p>Spokes can extend Axium's tmux integration in two ways:</p>"},{"location":"concepts/tmux-integration/#1-hud-segments-python-side","title":"1. HUD Segments (Python-side)","text":"<p>Register HUD segment providers that run in the daemon:</p> <pre><code># In your spoke's register() function\nfrom axium.core.hud import register_hud_provider\n\ndef my_hud_segment():\n    \"\"\"Provide custom HUD segment.\"\"\"\n    # Query current k8s context, docker status, etc.\n    return \"k8s:prod\"\n\nregister_hud_provider(my_hud_segment)\n</code></pre> <p>The HUD will display:</p> <pre><code>[axium] pane:%1  env:prod  aws:production  uptime:2h15m  k8s:prod\n</code></pre> <p>Provider Guidelines: - Return a string segment (e.g., <code>\"key:value\"</code>) - Return empty string <code>\"\"</code> to skip - Keep segments short (status line space is limited) - Handle exceptions gracefully (providers are silently skipped on error) - Avoid expensive operations (HUD refreshes every 5 seconds)</p>"},{"location":"concepts/tmux-integration/#2-tmux-configuration-shell-side","title":"2. tmux Configuration (Shell-side)","text":"<p>Spokes can extend tmux configuration using helper functions in their shell integration files:</p> <pre><code># In your spoke's shell integration file (e.g., spokes/my-spoke/init.sh)\n\n# Add custom HUD segment to status-right\naxium_tmux_enable_segment \"my-spoke status\" \"green\"\n\n# Or configure tmux directly\nif [[ -n \"$TMUX\" ]]; then\n  tmux set-hook -g pane-focus-in \"run-shell 'my-spoke sync #{pane_id}'\"\nfi\n</code></pre> <p>Available Helpers: - <code>axium_tmux_enable_segment CMD [COLOR]</code> - Append custom segment to status-right - <code>axium_tmux_enable_hud</code> - Enable Axium HUD (if user disabled it) - <code>axium_tmux_enable_palette</code> - Enable palette keybinding - <code>axium_restore_pane_env</code> - Restore pane environment (usually not needed)</p> <p>Example Spoke Integration:</p> <pre><code># spokes/kubectl/init.sh\nif [[ -n \"$TMUX\" ]]; then\n  # Add kubectl context to status line\n  axium_tmux_enable_segment \"kubectl config current-context\" \"cyan\"\nfi\n</code></pre> <p>This adds the current kubectl context to every tmux pane's status line.</p>"},{"location":"concepts/tmux-integration/#architecture","title":"Architecture","text":""},{"location":"concepts/tmux-integration/#state-management","title":"State Management","text":"<p>The daemon maintains two environment contexts:</p> <ol> <li>Global Environment (<code>state[\"active_env\"]</code>): Used outside tmux</li> <li>Per-Pane Environments (<code>state[\"panes\"]</code>): Used inside tmux</li> </ol> <pre><code>{\n    \"active_env\": \"root\",       # Global fallback\n    \"panes\": {\n        \"%1\": \"prod\",           # Pane-specific overrides\n        \"%2\": \"dev\",\n        \"%3\": \"staging\"\n    }\n}\n</code></pre>"},{"location":"concepts/tmux-integration/#pane-detection","title":"Pane Detection","text":"<p>Commands detect tmux context via the <code>TMUX_PANE</code> environment variable:</p> <pre><code>import os\n\npane_id = os.getenv(\"TMUX_PANE\")  # e.g., \"%1\"\nif pane_id:\n    # Use pane-specific environment\n    pass\nelse:\n    # Use global environment\n    pass\n</code></pre>"},{"location":"concepts/tmux-integration/#pane-restoration","title":"Pane Restoration","text":"<p>When you open a new shell in an existing pane, the <code>axium_restore_pane_env()</code> function queries the daemon for the pane's saved environment and exports <code>AXIUM_ENV</code>:</p> <pre><code># In ~/.config/tmux/init.sh\naxium_restore_pane_env() {\n  local pane_env=$(axium env get 2&gt;/dev/null)\n  if [[ -n \"$pane_env\" &amp;&amp; \"$pane_env\" != \"None\" ]]; then\n    export AXIUM_ENV=\"$pane_env\"\n  fi\n}\n</code></pre>"},{"location":"concepts/tmux-integration/#ipc-commands","title":"IPC Commands","text":"<p>The daemon provides three new IPC commands for pane management:</p>"},{"location":"concepts/tmux-integration/#set_pane_env","title":"<code>set_pane_env</code>","text":"<p>Set environment for a specific pane:</p> <pre><code>{\n  \"cmd\": \"set_pane_env\",\n  \"pane\": \"%1\",\n  \"value\": \"prod\"\n}\n</code></pre> <p>Response:</p> <pre><code>{\n  \"ok\": true\n}\n</code></pre>"},{"location":"concepts/tmux-integration/#get_pane_env","title":"<code>get_pane_env</code>","text":"<p>Get environment for a specific pane:</p> <pre><code>{\n  \"cmd\": \"get_pane_env\",\n  \"pane\": \"%1\"\n}\n</code></pre> <p>Response:</p> <pre><code>{\n  \"ok\": true,\n  \"env\": \"prod\"\n}\n</code></pre>"},{"location":"concepts/tmux-integration/#clear_pane_env","title":"<code>clear_pane_env</code>","text":"<p>Clear environment mapping for a pane:</p> <pre><code>{\n  \"cmd\": \"clear_pane_env\",\n  \"pane\": \"%1\"\n}\n</code></pre> <p>Response:</p> <pre><code>{\n  \"ok\": true\n}\n</code></pre>"},{"location":"concepts/tmux-integration/#troubleshooting","title":"Troubleshooting","text":""},{"location":"concepts/tmux-integration/#axium-overwriting-my-tmux-configuration","title":"Axium Overwriting My tmux Configuration","text":"<p>If Axium is overwriting your custom <code>status-right</code> or keybindings, enable minimal mode:</p> <pre><code># In your ~/.bashrc or ~/.zshrc (before sourcing bash/init.sh)\nexport AXIUM_TMUX_MINIMAL=1\n</code></pre> <p>Then selectively enable only the features you want:</p> <pre><code># Example: Enable HUD but not palette keybinding\naxium_tmux_enable_hud\n</code></pre>"},{"location":"concepts/tmux-integration/#hud-not-updating","title":"HUD Not Updating","text":"<p>Check tmux refresh interval:</p> <pre><code>tmux show-option -g status-interval\n</code></pre> <p>Set to 5 seconds (or lower):</p> <pre><code>tmux set-option -g status-interval 5\n</code></pre>"},{"location":"concepts/tmux-integration/#ctrlg-not-working","title":"Ctrl+G Not Working","text":"<p>Option 1: Check if minimal mode is enabled and you forgot to enable palette:</p> <pre><code># Enable palette explicitly\naxium_tmux_enable_palette\n</code></pre> <p>Option 2: Verify keybinding:</p> <pre><code>tmux list-keys | grep C-g\n</code></pre> <p>Manually bind:</p> <pre><code>tmux bind-key -n C-g run-shell \"tmux send-keys 'axium palette' Enter\"\n</code></pre>"},{"location":"concepts/tmux-integration/#hud-shows-axium-inactive","title":"HUD Shows \"[axium] inactive\"","text":"<p>This means the daemon is not running or not responding. Check daemon status:</p> <pre><code>axium daemon status\n</code></pre> <p>If not running, start it:</p> <pre><code>axium daemon start\n</code></pre>"},{"location":"concepts/tmux-integration/#pane-environment-not-persisting","title":"Pane Environment Not Persisting","text":"<p>Ensure daemon is running:</p> <pre><code>axium daemon status\n</code></pre> <p>Check state file:</p> <pre><code>cat ~/.config/axium/state.json\n</code></pre>"},{"location":"concepts/tmux-integration/#wrong-pane-id-detected","title":"Wrong Pane ID Detected","text":"<p>Check <code>TMUX_PANE</code> variable:</p> <pre><code>echo $TMUX_PANE\n</code></pre> <p>If empty, you're not in tmux. If incorrect, restart your shell.</p>"},{"location":"concepts/tmux-integration/#best-practices","title":"Best Practices","text":"<ol> <li>Use Per-Pane Environments: Keep different environments in different panes for safety</li> <li>Color Code Environments: Use tmux pane border colors to distinguish environments visually</li> <li>Monitor HUD: Keep an eye on the status line to verify your current context</li> <li>Use Palette: Press <code>Ctrl+G</code> for quick command access</li> <li>Extend HUD: Add custom segments for project-specific context</li> </ol>"},{"location":"concepts/tmux-integration/#example-workflow","title":"Example Workflow","text":"<pre><code># Create new tmux session\ntmux new -s work\n\n# Pane 1: Production monitoring\naxium env set prod\naws cloudwatch get-metric-statistics ...\n\n# Split pane (Ctrl+B, %)\n# Pane 2: Development work\naxium env set dev\nterraform plan\n\n# Split pane (Ctrl+B, \")\n# Pane 3: Staging deployment\naxium env set staging\nkubectl get pods\n\n# Press Ctrl+G in any pane to access palette\n# HUD shows current context: [axium] pane:%1  env:prod  aws:production  uptime:1h30m\n</code></pre>"},{"location":"concepts/tmux-integration/#future-enhancements","title":"Future Enhancements","text":"<ul> <li>Automatic pane cleanup (remove stale pane IDs)</li> <li>Pane grouping (multiple panes share environment)</li> <li>Visual indicators (colored borders based on environment)</li> <li>Pane templates (save/restore pane layouts with environments)</li> <li>Integration with tmux-resurrect for session persistence</li> </ul>"},{"location":"concepts/ux-philosophy/","title":"UX Philosophy","text":"<p>Axium follows a silent-first, predictable, and structured design philosophy. Commands should be invisible when working correctly, and informative when something needs attention.</p>"},{"location":"concepts/ux-philosophy/#core-principles","title":"Core Principles","text":""},{"location":"concepts/ux-philosophy/#1-silent-first-pattern","title":"1. Silent-First Pattern","text":"<p>Commands succeed silently by default. Exit codes communicate status:</p> <ul> <li>Exit 0: Success (no output)</li> <li>Exit 1: User error (show message)</li> <li>Exit 2: System failure (show message)</li> </ul> <pre><code># Silent success\n$ axium bootstrap\n$ echo $?\n0\n\n# Verbose mode for confirmation\n$ axium bootstrap --verbose\n\u2713 Axium config initialized at ~/.config/axium\n\n# Errors always show\n$ axium env set nonexistent\n\u2717 Environment 'nonexistent' not found\n</code></pre>"},{"location":"concepts/ux-philosophy/#2-structured-output","title":"2. Structured Output","text":"<p>List and show commands output structured data, not chatty messages:</p> <pre><code># Good: Data output\n$ axium env list\ndev\nstaging\nprod\n\n# Bad: Chatty output (avoided)\n$ axium env list\nHere are your environments:\n  - dev\n  - staging\n  - prod\nTotal: 3 environments found!\n</code></pre>"},{"location":"concepts/ux-philosophy/#3-predictable-behavior","title":"3. Predictable Behavior","text":"<ul> <li>Same command + same state = same result</li> <li>No hidden side effects</li> <li>No auto-modification without flags</li> <li>Idempotent operations</li> </ul>"},{"location":"concepts/ux-philosophy/#4-discoverability","title":"4. Discoverability","text":"<pre><code># Grouped command help\n$ axium help\nCore Commands:\n  bootstrap          Initialize or update Axium configuration\n  info               Display Axium information and tagline\n  ...\n\n# Component discovery\n$ axium discover\nEnvironments (3):\n  \u2022 dev\n  \u2022 staging\n  \u2022 prod\n\n# Health checks\n$ axium doctor\n\u2713 Config directory: ~/.config/axium\n\u2713 Daemon running: PID 12345\n...\n</code></pre>"},{"location":"concepts/ux-philosophy/#global-flags","title":"Global Flags","text":""},{"location":"concepts/ux-philosophy/#-verbose-v","title":"--verbose / -v","text":"<p>Enable detailed output for any command:</p> <pre><code>$ axium spoke reload\n$ echo $?\n0\n\n$ axium spoke reload --verbose\n\u2713 Reloaded spoke: aws\n</code></pre>"},{"location":"concepts/ux-philosophy/#error-messages","title":"Error Messages","text":"<p>Errors use \u2717 prefix and print to stderr:</p> <pre><code>$ axium env set missing 2&gt;&amp;1\n\u2717 Environment 'missing' not found\n  Available: dev, staging, prod\n</code></pre> <p>Provide actionable suggestions when possible:</p> <pre><code>$ axium doctor\n\u2717 Shell integration: Not detected\n  \u2192 Add to ~/.bashrc: source ~/.config/axium/bash/init.sh\n</code></pre>"},{"location":"concepts/ux-philosophy/#command-categories","title":"Command Categories","text":""},{"location":"concepts/ux-philosophy/#data-commands","title":"Data Commands","text":"<p>Show information, always produce output: - <code>axium env list</code> - <code>axium spoke list</code> - <code>axium help</code> - <code>axium discover</code></p>"},{"location":"concepts/ux-philosophy/#action-commands","title":"Action Commands","text":"<p>Perform operations, silent on success: - <code>axium env set &lt;name&gt;</code> - <code>axium spoke reload</code> - <code>axium bootstrap</code> - <code>axium notify clear</code></p>"},{"location":"concepts/ux-philosophy/#diagnostic-commands","title":"Diagnostic Commands","text":"<p>Check system state, show status: - <code>axium doctor</code> - <code>axium daemon status</code> - <code>axium notify list</code></p>"},{"location":"concepts/ux-philosophy/#modular-design","title":"Modular Design","text":""},{"location":"concepts/ux-philosophy/#hud-segments","title":"HUD Segments","text":"<p>HUD uses modular segment system:</p> <pre><code>from axium.core.hud_segments import HudSegment, HudRegistry\n\nclass MySegment(HudSegment):\n    name = \"status\"\n    priority = 50\n\n    def render(self, context: dict) -&gt; str:\n        return f\"status:{get_status()}\"\n\nregistry = HudRegistry.get_instance()\nregistry.register(MySegment())\n</code></pre>"},{"location":"concepts/ux-philosophy/#command-registry","title":"Command Registry","text":"<p>Centralized command discovery:</p> <pre><code>from axium.core.registry import get_all_commands\n\n# Used by help system\ncommands = get_all_commands(sort_by=\"alpha\")\n</code></pre>"},{"location":"concepts/ux-philosophy/#examples","title":"Examples","text":""},{"location":"concepts/ux-philosophy/#good-ux","title":"Good UX","text":"<pre><code># Clear, silent success\n$ axium wrapper add git \"axium run\"\n$ echo $?\n0\n\n# Structured data when needed\n$ axium wrapper list\ngit\ndocker\nkubectl\n\n# Helpful diagnostics\n$ axium doctor\n\u2713 All 7 checks passed\n</code></pre>"},{"location":"concepts/ux-philosophy/#bad-ux-avoided","title":"Bad UX (Avoided)","text":"<pre><code># Don't: Chatty success messages\n$ axium wrapper add git \"axium run\"\nSuccess! Added wrapper for 'git' command!\nYou can now use: git status\nRun 'axium wrapper list' to see all wrappers.\n\n# Don't: Inconsistent output\n$ axium wrapper list\nYou have 3 wrappers:\n1. git\n2. docker\n3. kubectl\n</code></pre>"},{"location":"concepts/ux-philosophy/#design-goals","title":"Design Goals","text":"<ol> <li>Scriptable: Easy to use in automation</li> <li>Composable: Commands chain naturally</li> <li>Predictable: Same input \u2192 same output</li> <li>Self-documenting: <code>help</code> and <code>discover</code> reveal capabilities</li> <li>Debuggable: <code>doctor</code> diagnoses issues</li> <li>Respectful: Silent unless user wants details</li> </ol>"},{"location":"concepts/ux-philosophy/#related","title":"Related","text":"<ul> <li>HUD System</li> <li>Command Registry</li> <li>Silent-Core Pattern</li> </ul>"},{"location":"concepts/wrappers/","title":"Command Wrappers","text":"<p>Axium's wrapper system intercepts shell commands and applies context-aware transformations before execution.</p>"},{"location":"concepts/wrappers/#overview","title":"Overview","text":"<p>Command wrappers enable transparent command transformation:</p> <pre><code># You type:\naws s3 ls\n\n# Axium intercepts and executes:\nenva-prod aws s3 ls\n</code></pre> <p>This allows: - Environment-specific prefixing (AWS profiles, Terraform workspaces) - Context injection (Docker contexts, kubectl namespaces) - Credential management (aws-vault, SOPS, etc.) - Logging and auditing of command execution</p>"},{"location":"concepts/wrappers/#how-it-works","title":"How It Works","text":"<ol> <li>Shell Integration loads wrapper functions</li> <li>Wrapper function intercepts command</li> <li>Calls <code>axium run &lt;command&gt; &lt;args&gt;</code></li> <li>Intelligent routing - Check if spoke command or native command</li> <li>Spoke route - Dispatch to spoke subcommand OR Prefix route - Apply prefix rules from <code>prefixes.yaml</code></li> <li>Executes transformed command</li> </ol> <pre><code>Shell: aws whoami\n    \u2193\nWrapper: axium run aws whoami\n    \u2193\nRouting: Is 'whoami' a spoke subcommand? YES\n    \u2193\nExecute: axium aws whoami (spoke command)\n</code></pre> <pre><code>Shell: aws s3 ls\n    \u2193\nWrapper: axium run aws s3 ls\n    \u2193\nRouting: Is 's3' a spoke subcommand? NO\n    \u2193\nDaemon: Apply prefixes.yaml rules\n    \u2193\nExecute: enva-prod aws s3 ls (native CLI)\n</code></pre>"},{"location":"concepts/wrappers/#configuration","title":"Configuration","text":"<p>Wrappers are defined in <code>prefixes.yaml</code>:</p> <pre><code>prefixes:\n  - command: aws\n    prefix: ${env.prefix}\n\n  - command: terraform\n    prefix: ${env.prefix}\n\n  - command: kubectl\n    prefix: \"kubeconfig ${env.kubeconfig}\"\n</code></pre> <p>The daemon reads this file and generates the wrapper list.</p>"},{"location":"concepts/wrappers/#shell-integration","title":"Shell Integration","text":""},{"location":"concepts/wrappers/#initialization","title":"Initialization","text":"<pre><code># In ~/.bashrc or ~/.zshrc\nsource ~/.config/axium/bash/init.sh\n</code></pre> <p>This sources Axium's shell functions:</p> <ul> <li><code>axium_refresh_wrappers</code> - Regenerate wrapper functions</li> <li><code>axium_clear_wrappers</code> - Remove all wrappers</li> <li>Wrapper functions for each command in <code>prefixes.yaml</code></li> </ul>"},{"location":"concepts/wrappers/#wrapper-function-template","title":"Wrapper Function Template","text":"<pre><code># Example generated wrapper for 'aws' command\naws() {\n    command axium run aws \"$@\"\n}\n</code></pre> <p>All arguments are passed through to <code>axium run</code>.</p>"},{"location":"concepts/wrappers/#wrapper-management","title":"Wrapper Management","text":""},{"location":"concepts/wrappers/#list-wrapped-commands","title":"List Wrapped Commands","text":"<pre><code>axium wrapper list\n\n# Output:\naws\nterraform\nkubectl\ndocker\n</code></pre>"},{"location":"concepts/wrappers/#refresh-wrappers","title":"Refresh Wrappers","text":"<p>After changing <code>prefixes.yaml</code>:</p> <pre><code># 1. Reload daemon configuration\naxium daemon reload\n\n# 2. Refresh wrappers in current shell\neval \"$(axium wrapper refresh)\"\n</code></pre> <p>Or in one line:</p> <pre><code>axium daemon reload &amp;&amp; eval \"$(axium wrapper refresh)\"\n</code></pre>"},{"location":"concepts/wrappers/#clear-all-wrappers","title":"Clear All Wrappers","text":"<p>Temporarily disable all command wrapping:</p> <pre><code>eval \"$(axium wrapper clear)\"\n\n# Commands now execute directly\naws --version  # Runs /usr/bin/aws directly\n</code></pre> <p>To re-enable:</p> <pre><code>eval \"$(axium wrapper refresh)\"\n</code></pre>"},{"location":"concepts/wrappers/#the-axium-run-command","title":"The <code>axium run</code> Command","text":"<p>Core command that applies prefix rules:</p> <pre><code>axium run &lt;command&gt; [args...]\n</code></pre>"},{"location":"concepts/wrappers/#intelligent-routing","title":"Intelligent Routing","text":"<p><code>axium run</code> intelligently routes commands based on context:</p> <p>Spoke Commands - Routes to spoke subcommands: <pre><code>axium run aws whoami\n# \u2192 Routes to: axium aws whoami (spoke command)\n\naxium run aws info\n# \u2192 Routes to: axium aws info (spoke command)\n</code></pre></p> <p>Native Commands - Applies prefix wrapping: <pre><code>axium run aws s3 ls\n# \u2192 Applies prefix: enva-prod aws s3 ls (native AWS CLI)\n\naxium run terraform plan\n# \u2192 Applies prefix: enva-prod terraform plan (native Terraform)\n</code></pre></p> <p>This means you can use the same wrapper for both spoke-provided functionality and native CLI commands \u2014 Axium automatically determines the correct routing.</p>"},{"location":"concepts/wrappers/#behavior","title":"Behavior","text":"<ol> <li>Check spoke routing - Is this a spoke/gear subcommand?</li> <li>Get context - Current environment, tmux pane</li> <li>Query daemon - Apply prefix rules</li> <li>Expand templates - Substitute <code>${env.key}</code> values</li> <li>Execute - Run transformed command</li> </ol>"},{"location":"concepts/wrappers/#examples","title":"Examples","text":"<pre><code># Spoke command routing\naxium run aws whoami\n# Routes to spoke: axium aws whoami\n\n# Native command with prefix\naxium run aws s3 ls\n# Applies prefix: enva-prod aws s3 ls\n\n# With environment context\naxium env set prod\naxium run aws s3 ls\n# Becomes: enva-prod aws s3 ls\n\n# Passes all arguments\naxium run terraform plan -out=tfplan\n# Becomes: enva-prod terraform plan -out=tfplan\n</code></pre>"},{"location":"concepts/wrappers/#fallback-behavior","title":"Fallback Behavior","text":"<p>If daemon is unavailable:</p> <pre><code>axium run aws s3 ls\n# Falls back to: aws s3 ls (unwrapped)\n</code></pre>"},{"location":"concepts/wrappers/#state-cache","title":"State Cache","text":"<p>Wrapper state is cached in <code>~/.config/axium/state_cache.json</code>:</p> <pre><code>{\n  \"prefixed_commands\": [\"aws\", \"terraform\", \"kubectl\"],\n  \"last_updated\": \"2025-10-13T17:30:00Z\"\n}\n</code></pre> <p>This cache is updated when: - Daemon starts - <code>axium daemon reload</code> is called - <code>prefixes.yaml</code> changes</p> <p>The shell integration reads this cache to generate wrapper functions.</p>"},{"location":"concepts/wrappers/#environment-context","title":"Environment Context","text":"<p>Wrappers are environment-aware:</p> <pre><code># Set environment\naxium env set dev\n\n# Wrapper uses dev prefix\naws s3 ls\n# Executes: enva-dev aws s3 ls\n\n# Switch environment\naxium env set prod\n\n# Wrapper uses prod prefix\naws s3 ls\n# Executes: enva-prod aws s3 ls\n</code></pre>"},{"location":"concepts/wrappers/#pane-specific-context","title":"Pane-Specific Context","text":"<p>In tmux, each pane can have its own environment:</p> <pre><code># Pane 1\naxium env set dev\naws s3 ls  # Uses dev prefix\n\n# Pane 2\naxium env set prod\naws s3 ls  # Uses prod prefix\n</code></pre>"},{"location":"concepts/wrappers/#template-expansion","title":"Template Expansion","text":"<p>Wrappers support template variables:</p> <pre><code>prefixes:\n  - command: aws\n    prefix: ${env.prefix}\n\n  - command: docker\n    prefix: \"docker --context ${env.docker_context}\"\n\n  - command: kubectl\n    prefix: \"kubectl --kubeconfig ${env.kubeconfig}\"\n</code></pre> <p>Variables are expanded at runtime:</p> <pre><code># With env.prefix = \"aws-vault exec prod --\"\naws s3 ls\n# Becomes: aws-vault exec prod -- aws s3 ls\n\n# With env.docker_context = \"remote\"\ndocker ps\n# Becomes: docker --context remote ps\n</code></pre>"},{"location":"concepts/wrappers/#shell-functions-support","title":"Shell Functions Support","text":"<p>Prefix commands can be shell functions:</p> <pre><code># Define in ~/.bashrc\nenva-prod() {\n    echo \"[Running in prod]\" &gt;&amp;2\n    AWS_PROFILE=prod \"$@\"\n}\n\n# Use in prefixes.yaml\nprefixes:\n  - command: aws\n    prefix: enva-prod\n</code></pre> <p>When executed:</p> <pre><code>aws s3 ls\n# Axium detects shell function and executes via: bash -ic \"enva-prod aws s3 ls\"\n</code></pre>"},{"location":"concepts/wrappers/#conflict-detection-gears","title":"Conflict Detection (Gears)","text":"<p>Gears can register prefix rules in their manifests:</p> <pre><code># gear.yaml\nprefixes:\n  - command: terraform\n    wrapper: axium tf-run\n</code></pre> <p>If multiple gears register the same command, a conflict is detected:</p> <pre><code>[WARNING] Prefix conflict: command 'terraform' already registered by gear 'terraform-gear'\n[WARNING] Gear 'my-gear' attempted to register 'terraform' but was rejected\n</code></pre> <p>First registration wins.</p>"},{"location":"concepts/wrappers/#debugging","title":"Debugging","text":""},{"location":"concepts/wrappers/#check-wrapper-function","title":"Check Wrapper Function","text":"<pre><code># ZSH\nwhich aws\n# Output: aws () { command axium run aws \"$@\" }\n\n# Bash\ntype aws\n# Output: aws is a function\n</code></pre>"},{"location":"concepts/wrappers/#test-wrapper","title":"Test Wrapper","text":"<pre><code># Enable debug output\nAXIUM_DEBUG=1 axium run aws --version\n\n# Check daemon prefix logic\naxium daemon logs | grep apply_prefixes\n</code></pre>"},{"location":"concepts/wrappers/#verify-state-cache","title":"Verify State Cache","text":"<pre><code>cat ~/.config/axium/state_cache.json | jq .prefixed_commands\n</code></pre>"},{"location":"concepts/wrappers/#best-practices","title":"Best Practices","text":""},{"location":"concepts/wrappers/#1-wrapper-naming","title":"1. Wrapper Naming","text":"<p>Use clear, consistent prefix patterns:</p> <pre><code># GOOD\nprefixes:\n  - command: aws\n    prefix: ${env.prefix}\n\n# AVOID\nprefixes:\n  - command: aws\n    prefix: weird-custom-thing\n</code></pre>"},{"location":"concepts/wrappers/#2-test-before-production","title":"2. Test Before Production","text":"<pre><code># Test in dev environment\nenvs:\n  dev:\n    prefix: \"\"  # No wrapping in dev\n\n  prod:\n    prefix: aws-vault exec prod --  # Wrap in prod\n</code></pre>"},{"location":"concepts/wrappers/#3-document-dependencies","title":"3. Document Dependencies","text":"<pre><code># prefixes.yaml\nprefixes:\n  - command: aws\n    prefix: ${env.prefix}\n    # NOTE: Requires 'aws-vault' installed\n    # Install: brew install aws-vault\n</code></pre>"},{"location":"concepts/wrappers/#4-refresh-after-changes","title":"4. Refresh After Changes","text":"<p>Always refresh after modifying <code>prefixes.yaml</code>:</p> <pre><code>axium daemon reload &amp;&amp; eval \"$(axium wrapper refresh)\"\n</code></pre>"},{"location":"concepts/wrappers/#troubleshooting","title":"Troubleshooting","text":""},{"location":"concepts/wrappers/#wrapper-not-working","title":"Wrapper Not Working","text":"<p>Check loaded:</p> <pre><code>which aws\n# Should show function, not path\n</code></pre> <p>Reload shell integration:</p> <pre><code>source ~/.config/axium/bash/init.sh\neval \"$(axium wrapper refresh)\"\n</code></pre>"},{"location":"concepts/wrappers/#wrong-prefix-applied","title":"Wrong Prefix Applied","text":"<p>Check current environment:</p> <pre><code>axium env get\naxium env show\n</code></pre> <p>Check prefix rule:</p> <pre><code>cat ~/.config/axium/prefixes.yaml\n</code></pre>"},{"location":"concepts/wrappers/#command-not-found-after-wrapping","title":"Command Not Found After Wrapping","text":"<p>The wrapper function may be hiding the real command. Clear wrappers:</p> <pre><code>eval \"$(axium wrapper clear)\"\nwhich aws  # Should show /usr/bin/aws or similar\n</code></pre>"},{"location":"concepts/wrappers/#advanced-usage","title":"Advanced Usage","text":""},{"location":"concepts/wrappers/#conditional-wrapping","title":"Conditional Wrapping","text":"<p>Different prefixes per environment:</p> <pre><code># envs.yaml\nenvs:\n  dev:\n    prefix: \"\"  # No prefix in dev\n\n  staging:\n    prefix: \"aws-vault exec staging --\"\n\n  prod:\n    prefix: \"aws-vault exec prod --\"\n</code></pre>"},{"location":"concepts/wrappers/#multiple-commands-one-prefix","title":"Multiple Commands, One Prefix","text":"<pre><code>prefixes:\n  - command: aws\n    prefix: ${env.prefix}\n  - command: terraform\n    prefix: ${env.prefix}\n  - command: kubectl\n    prefix: ${env.prefix}\n</code></pre>"},{"location":"concepts/wrappers/#environment-variables-in-wrappers","title":"Environment Variables in Wrappers","text":"<pre><code>prefixes:\n  - command: docker\n    prefix: \"DOCKER_HOST=${env.docker_host}\"\n</code></pre>"},{"location":"concepts/wrappers/#see-also","title":"See Also","text":"<ul> <li>Prefixes - Prefix configuration details</li> <li>Environments - Environment management</li> <li>Gears - Gears can register prefixes</li> <li>Shell Integration - Shell setup guide</li> </ul>"},{"location":"development/CONTRIBUTING/","title":"\ud83e\udd1d Contributing to Axium","text":"<p>Welcome! Axium is an async, extensible DevOps assistant \u2014 and contributions from other builders are always welcome. This guide explains how to set up a local development environment, follow our standards, and extend Axium via Spokes.</p>"},{"location":"development/CONTRIBUTING/#philosophy","title":"\ud83e\udded Philosophy","text":"<p>Axium follows a few simple rules:</p> <ul> <li>Keep it calm \u2014 clarity and composure over cleverness</li> <li>Async-first \u2014 all daemon or long-running code uses asyncio</li> <li>Predictable UX \u2014 axium <code>&lt;noun&gt;</code> <code>&lt;verb&gt;</code> pattern everywhere</li> <li>Extensible \u2014 all features should be possible via Spokes</li> <li>Minimal dependencies \u2014 stdlib + Typer + YAML preferred</li> </ul>"},{"location":"development/CONTRIBUTING/#local-development-setup","title":"\u2699\ufe0f Local Development Setup","text":"<p>1\ufe0f\u20e3 Clone and install</p> <pre><code>git clone https://github.com/axium-tools/axium.git\ncd axium\npip install -e .[dev]\n</code></pre> <p>2\ufe0f\u20e3 Enable shell integration</p> <pre><code>source bash/init.sh\n</code></pre> <p>This adds the ax alias and initializes environment functions.</p> <p>3\ufe0f\u20e3 Run tests</p> <pre><code>pytest -q\n</code></pre> <p>Tests are run with pytest and must pass before PR submission.</p>"},{"location":"development/CONTRIBUTING/#testing-standards","title":"\ud83e\uddea Testing Standards","text":"<ul> <li>Unit tests live in the tests/ directory</li> <li>Every CLI command and IPC endpoint must have a corresponding test</li> <li>Async code should use pytest.mark.asyncio</li> <li>Avoid mocking unless network or file IO is required</li> <li>Run tests locally before committing</li> </ul> <p>Example commands:</p> <pre><code>pytest -v\npytest tests/core/test_ipc.py\npytest --maxfail=1 --disable-warnings -q\n</code></pre>"},{"location":"development/CONTRIBUTING/#spoke-development","title":"\ud83e\udde9 Spoke Development","text":"<p>Spokes are how Axium grows \u2014 each Spoke extends Axium\u2019s commands, palette, or HUD. They live in ~/.config/axium/spokes/<code>&lt;name&gt;</code>/.</p> <p>Example layout:</p> <pre><code>~/.config/axium/spokes/aws/\n  \u251c\u2500 spoke.yaml\n  \u2514\u2500 aws_spoke.py\n</code></pre> <p>Example spoke.yaml:</p> <pre><code>name: aws\nentrypoint: aws_spoke:register\n</code></pre> <p>Example aws_spoke.py:</p> <pre><code>def register(app):\n    @app.command(\"aws-whoami\")\n    def aws_whoami():\n        import boto3\n        print(boto3.client(\"sts\").get_caller_identity())\n</code></pre> <p>Test it:</p> <pre><code>axium aws-whoami\n</code></pre>"},{"location":"development/CONTRIBUTING/#code-style","title":"\ud83e\uddf1 Code Style","text":"<ul> <li>Formatting: use black (line length 100)</li> <li>Imports: sorted via isort</li> <li>Linting: flake8 must pass cleanly</li> <li>Typing: add type hints to all public functions</li> <li>Logging: use the logging module, not print statements</li> </ul> <p>Format locally:</p> <pre><code>black .\nisort .\nflake8\n</code></pre>"},{"location":"development/CONTRIBUTING/#branching-workflow","title":"\ud83d\udd04 Branching &amp; Workflow","text":"Step Action main Stable branch (always green CI) develop Active dev branch (features merged here) feature/<code>&lt;name&gt;</code> Your working branch spoke/<code>&lt;name&gt;</code> Spoke-specific branch for plugin dev <p>Example flow:</p> <pre><code>git checkout -b feature/state-persistence\n# ...make changes...\npytest -q\ngit commit -am \"Add persistent state.json handling\"\ngit push origin feature/state-persistence\n</code></pre> <p>Then open a Pull Request into develop.</p>"},{"location":"development/CONTRIBUTING/#commit-guidelines","title":"\ud83e\uddfe Commit Guidelines","text":"<p>Format commits as:</p> <pre><code>`&lt;type&gt;`(scope): short summary\n</code></pre> <p>Examples:</p> <pre><code>feat(daemon): add reload IPC command\nfix(cli): handle missing socket permissions\ntest(ipc): increase coverage for state reload\ndocs(readme): clarify palette usage\n</code></pre> <p>Types: feat, fix, docs, test, refactor, chore.</p>"},{"location":"development/CONTRIBUTING/#pull-requests","title":"\ud83e\uddf0 Pull Requests","text":"<p>Before you submit:</p> <ul> <li>\u2705 All tests pass</li> <li>\u2705 Code formatted (black, isort, flake8)</li> <li>\u2705 No debug prints</li> <li>\u2705 ROADMAP.md updated if needed</li> <li>\u2705 New features documented</li> </ul> <p>CI will verify tests and lint automatically.</p>"},{"location":"development/CONTRIBUTING/#good-first-issues","title":"\ud83e\udde0 Good First Issues","text":"<ul> <li>Improve CLI help text</li> <li>Expand test coverage for ipc.py</li> <li>Add example Spoke (e.g., system, git, or aws)</li> <li>Improve error handling for daemon restarts</li> </ul>"},{"location":"development/CONTRIBUTING/#community","title":"\ud83e\udea9 Community","text":"<ul> <li>Discussions and design chat will live under GitHub Discussions</li> <li>Spokes can be submitted to the registry at registry.axium.tools once it launches</li> <li>For now, feel free to open issues or share ideas directly via PR comments</li> </ul>"},{"location":"development/CONTRIBUTING/#license","title":"\ud83e\udeaa License","text":"<p>By contributing, you agree that your code is licensed under the Apache 2.0 License (LICENSE).</p> <p>\u201cStructure for your terminal.\u201d</p>"},{"location":"development/STYLE-GUIDE/","title":"\ud83c\udfa8 Axium Color Palette","text":"<p>Axium: structure for your terminal.</p> <p>This defines the official Axium colors used across the CLI, HUD, daemon output, and web interfaces.</p>"},{"location":"development/STYLE-GUIDE/#core-palette","title":"\ud83e\udded Core Palette","text":"Role Color Hex Notes Primary (Teal) #00B7C7 Core Axium color \u2014 structure and balance. Used in HUD, logo, and highlights. Accent (Cyan) #14D9E7 Brighter accent for interactive elements, cursor glow, and palette focus. Dark Graphite #111111 Main background for site, HUD, and daemon logs \u2014 terminal base tone. Mid Graphite #1B1B1B Slightly lighter background for panels, code blocks, and secondary surfaces. Soft White (Text) #E6E6E6 Default foreground text \u2014 high contrast but softer than pure white. Muted Grey (Secondary Text) #A3A3A3 Used for descriptions, metadata, or inactive HUD sections. Error / Warn Red #FF4C4C Errors, warnings, failed commands. Success Green #3ECF8E Subtle success highlight in CLI confirmations or daemon OK states."},{"location":"development/STYLE-GUIDE/#usage-guidelines","title":"\ud83e\udde0 Usage Guidelines","text":""},{"location":"development/STYLE-GUIDE/#cli-hud-daemon-output","title":"CLI / HUD / Daemon Output","text":"<ul> <li>Primary (#00B7C7) \u2192 prefix, active env, key highlight</li> <li>Accent (#14D9E7) \u2192 dynamic or live feedback (palette selection, HUD blink)</li> <li>Muted Grey (#A3A3A3) \u2192 inactive items or status labels</li> <li>Error / Success \u2192 log output or CLI result messages</li> </ul> <p>Example output (colors shown conceptually):</p> <pre><code>[axium] env:prod  uptime:12m  status:ok\naxium \u2192 teal (#00B7C7)\nenv \u2192 grey (#A3A3A3)\nprod \u2192 cyan (#14D9E7)\nok \u2192 green (#3ECF8E)\n</code></pre>"},{"location":"development/STYLE-GUIDE/#web-docs-theme","title":"Web / Docs Theme","text":"<ul> <li>Background: #111111</li> <li>Text: #E6E6E6</li> <li>Link / CTA: #00B7C7</li> <li>Hover / Focus: #14D9E7</li> <li>Code blocks: background #1B1B1B, text #14D9E7</li> <li>Logo / accents: blend of #00B7C7 \u2192 #14D9E7 gradient</li> </ul>"},{"location":"development/STYLE-GUIDE/#logo-favicon","title":"Logo &amp; Favicon","text":"<ul> <li>Base emblem color: #00B7C7</li> <li>Gradient accent: #14D9E7</li> <li>Background: transparent or dark graphite (#111111)</li> </ul>"},{"location":"development/STYLE-GUIDE/#tailwind-config-example","title":"\ud83e\udde9 Tailwind Config Example","text":"<pre><code>// tailwind.config.js\nmodule.exports = {\n  theme: {\n    extend: {\n      colors: {\n        axium: {\n          primary: \"#00B7C7\",\n          accent:  \"#14D9E7\",\n          dark:    \"#111111\",\n          mid:     \"#1B1B1B\",\n          text:    \"#E6E6E6\",\n          muted:   \"#A3A3A3\",\n          error:   \"#FF4C4C\",\n          success: \"#3ECF8E\"\n        }\n      }\n    }\n  }\n};\n</code></pre> <p>Usage in HTML or JSX:</p> <pre><code>`&lt;div class=\"bg-axium-dark text-axium-text\"&gt;`\n  `&lt;button class=\"text-axium-primary hover:text-axium-accent\"&gt;`Run Axium`&lt;/button&gt;`\n`&lt;/div&gt;`\n</code></pre>"},{"location":"development/STYLE-GUIDE/#hex-summary","title":"\u2705 Hex Summary","text":"<pre><code>Primary Teal:     #00B7C7\nAccent Cyan:      #14D9E7\nDark Graphite:    #111111\nMid Graphite:     #1B1B1B\nSoft White:       #E6E6E6\nMuted Grey:       #A3A3A3\nError Red:        #FF4C4C\nSuccess Green:    #3ECF8E\n</code></pre> <p>\u201cStructure for your terminal.\u201d</p>"},{"location":"guides/hud-segments/","title":"HUD Segments for Spokes","text":"<p>This guide shows how spokes can add custom segments to the Axium HUD with automatic name:value composition and wrapper normalization.</p>"},{"location":"guides/hud-segments/#overview","title":"Overview","text":"<p>Spokes create HUD segments by subclassing <code>HudSegment</code> and registering them with the HUD registry. The registry automatically: - Composes segments as <code>name:value</code> (e.g., \"creds:Y\") - Applies wrapper normalization (e.g., <code>[creds:Y]</code> if configured) - Handles caching for expensive operations</p>"},{"location":"guides/hud-segments/#hudsegment-classes","title":"HudSegment Classes","text":"<p>All HUD segments inherit from the <code>HudSegment</code> base class:</p> <pre><code>from axium.core.hud import register_hud_segment, get_registry\nfrom axium.core.hud_segments import HudSegment\n\nclass MyStatusSegment(HudSegment):\n    \"\"\"Custom HUD segment for spoke.\"\"\"\n\n    name = \"mystatus\"\n    priority = 100  # After core segments (5-20)\n    cached = False  # Set to True for expensive operations\n\n    def render(self, context: dict) -&gt; str:\n        \"\"\"\n        Render the segment VALUE only.\n\n        The registry automatically composes this as \"mystatus:{value}\"\n        and applies wrapper normalization.\n\n        Args:\n            context: Dict with keys:\n                - state: Daemon state dict\n                - pane_id: Optional tmux pane ID\n                - env: Active environment name\n                - started: Daemon start timestamp\n                - wrapper: Dict with prefix/suffix for wrapping\n\n        Returns:\n            Value string (e.g., \"ok\") - registry composes to \"mystatus:ok\"\n        \"\"\"\n        # Access current environment\n        env = context.get(\"env\", \"-\")\n\n        # Compute status (fast operation)\n        status = self.check_status(env)\n\n        return status  # Returns \"ok\", registry composes \"mystatus:ok\"\n\n    def check_status(self, env: str) -&gt; str:\n        \"\"\"Check current status (called on every render).\"\"\"\n        # Keep this fast! Called ~1-2 times per second in tmux\n        return \"ok\" if env != \"-\" else \"none\"\n\n# In spoke's register() function:\ndef register(app, events):\n    # Register HUD segment\n    register_hud_segment(MyStatusSegment())\n</code></pre>"},{"location":"guides/hud-segments/#cached-segments-for-expensive-operations","title":"Cached Segments (For Expensive Operations)","text":"<p>For segments that require expensive operations (network calls, file I/O, etc.), use the caching system:</p> <pre><code>from axium.core.hud import register_hud_segment, get_registry\nfrom axium.core.hud_segments import HudSegment\n\nclass CredsSegment(HudSegment):\n    \"\"\"Credential validity HUD segment with caching.\"\"\"\n\n    name = \"creds\"\n    priority = 100\n    cached = True  # Expensive check, only update on events\n\n    def render(self, context: dict) -&gt; str:\n        \"\"\"\n        Check credential validity. Returns just \"Y\" or \"N\".\n\n        Registry automatically composes to \"creds:Y\" or \"creds:N\".\n        \"\"\"\n        from axium.core import api\n        from . import helpers\n\n        env_name = context.get(\"env\") or api.get_active_env()\n        is_valid, _ = helpers.get_status(env_name)\n\n        return \"Y\" if is_valid else \"N\"\n\ndef register(app, events):\n    # Register cached segment\n    creds_segment = CredsSegment()\n    register_hud_segment(creds_segment)\n\n    # Update cache on environment change\n    def on_env_change(new_env: str, old_env: str, **kwargs):\n        registry = get_registry()\n        context = {\"env\": new_env}\n        registry.update_cached_segments(context)  # Refresh cache\n\n    # Update cache on spoke load\n    def on_spoke_loaded(spoke_name: str):\n        if spoke_name == \"creds\":\n            from axium.core import api\n            registry = get_registry()\n            env_name = api.get_active_env()\n            context = {\"env\": env_name}\n            registry.update_cached_segments(context)  # Initial cache\n\n    events.on(\"env_change\", on_env_change)\n    events.on(\"spoke_loaded\", on_spoke_loaded)\n</code></pre>"},{"location":"guides/hud-segments/#how-caching-works","title":"How Caching Works","text":"<ol> <li>Cached segments (<code>cached=True</code>) store their rendered value and only update when <code>update_cached_segments()</code> is called</li> <li>Uncached segments (<code>cached=False</code>) render fresh on every HUD update</li> <li>Event handlers trigger cache updates, keeping expensive operations out of the render loop</li> </ol>"},{"location":"guides/hud-segments/#conditional-rendering","title":"Conditional Rendering","text":"<p>Segments can implement <code>should_render()</code> for conditional display:</p> <pre><code>class ConditionalSegment(HudSegment):\n    name = \"conditional\"\n    priority = 100\n\n    def should_render(self, context: dict) -&gt; bool:\n        \"\"\"Only show in specific environments.\"\"\"\n        env = context.get(\"env\", \"\")\n        return env in [\"prod\", \"staging\"]\n\n    def render(self, context: dict) -&gt; str:\n        return \"critical\"  # Composes to \"conditional:critical\"\n</code></pre>"},{"location":"guides/hud-segments/#wrapper-configuration","title":"Wrapper Configuration","text":"<p>Users can configure wrappers in their <code>~/.config/axium/hud.yaml</code>:</p> <pre><code>style:\n  wrapper:\n    prefix: '['\n    suffix: ']'\n</code></pre> <p>The registry automatically: 1. Composes <code>name:value</code> (e.g., \"creds:Y\") 2. Detects and removes existing wrappers 3. Applies configured wrapper (e.g., \"[creds:Y]\")</p> <p>Supported wrappers: <code>[]</code>, <code>{}</code>, <code>()</code>, <code>&lt;&gt;</code>, <code>||</code>, <code>\"\"</code>, <code>''</code></p>"},{"location":"guides/hud-segments/#segment-types-comparison","title":"Segment Types Comparison","text":"Type cached flag Best For Pros Cons Uncached <code>False</code> Fast computations Simple, real-time Must be fast Cached <code>True</code> Expensive checks Doesn't slow HUD More complex setup"},{"location":"guides/hud-segments/#performance-guidelines","title":"Performance Guidelines","text":"<p>HUD renders frequently in tmux (~1-2 times per second)</p>"},{"location":"guides/hud-segments/#uncached-segments-cachedfalse","title":"Uncached Segments (cached=False)","text":"<ul> <li>\u2705 DO: Keep render() fast (&lt;5ms)</li> <li>\u2705 DO: Use context data (already available)</li> <li>\u2705 DO: Read environment variables</li> <li>\u274c DON'T: Make network calls in render()</li> <li>\u274c DON'T: Read files in render()</li> <li>\u274c DON'T: Run subprocesses in render()</li> </ul>"},{"location":"guides/hud-segments/#cached-segments-cachedtrue","title":"Cached Segments (cached=True)","text":"<ul> <li>\u2705 DO: Use for network calls, file I/O, subprocesses</li> <li>\u2705 DO: Update cache in event handlers</li> <li>\u2705 DO: Call <code>registry.update_cached_segments()</code> after state changes</li> <li>\u274c DON'T: Forget to update cache on relevant events</li> </ul>"},{"location":"guides/hud-segments/#priority-guidelines","title":"Priority Guidelines","text":"<ul> <li>0-4: Reserved (future use)</li> <li>5-9: Pane ID (PaneSegment)</li> <li>10-19: Core segments (Environment, Uptime)</li> <li>20-99: System extensions</li> <li>100+: Spoke segments (recommended)</li> </ul>"},{"location":"guides/hud-segments/#testing-segments","title":"Testing Segments","text":"<pre><code>def test_my_segment():\n    \"\"\"Test HUD segment rendering.\"\"\"\n    segment = MyStatusSegment()\n\n    context = {\n        \"env\": \"prod\",\n        \"pane_id\": \"%1\",\n        \"started\": \"2024-01-01T00:00:00Z\",\n    }\n\n    result = segment.render(context)\n    assert result == \"ok\"  # Returns value only, not \"mystatus:ok\"\n</code></pre>"},{"location":"guides/hud-segments/#examples","title":"Examples","text":""},{"location":"guides/hud-segments/#k8s-context-uncached","title":"K8s Context (Uncached)","text":"<pre><code>class K8sContextSegment(HudSegment):\n    name = \"k8s\"\n    priority = 100\n    cached = False\n\n    def render(self, context: dict) -&gt; str:\n        # Fast: read from env var set by kubectl\n        import os\n        ctx = os.getenv(\"KUBECONFIG_CONTEXT\", \"none\")\n        return ctx  # Registry composes to \"k8s:prod-cluster\"\n</code></pre>"},{"location":"guides/hud-segments/#git-branch-uncached-with-subprocess","title":"Git Branch (Uncached with Subprocess)","text":"<pre><code>class GitBranchSegment(HudSegment):\n    name = \"git\"\n    priority = 110\n    cached = False\n\n    def should_render(self, context: dict) -&gt; bool:\n        # Only show in development envs\n        return context.get(\"env\") in [\"dev\", \"local\"]\n\n    def render(self, context: dict) -&gt; str:\n        import subprocess\n        try:\n            # Fast subprocess with timeout\n            branch = subprocess.check_output(\n                [\"git\", \"branch\", \"--show-current\"],\n                cwd=os.getcwd(),\n                stderr=subprocess.DEVNULL,\n                timeout=0.05  # 50ms timeout\n            ).decode().strip()\n            return branch  # Registry composes to \"git:main\"\n        except:\n            return \"\"  # Empty string hides segment\n</code></pre>"},{"location":"guides/hud-segments/#database-status-cached","title":"Database Status (Cached)","text":"<pre><code>class DbStatusSegment(HudSegment):\n    name = \"db\"\n    priority = 105\n    cached = True  # Expensive connection check\n\n    def render(self, context: dict) -&gt; str:\n        \"\"\"Check database connectivity (cached).\"\"\"\n        import psycopg2\n        try:\n            conn = psycopg2.connect(\n                host=\"localhost\",\n                database=\"mydb\",\n                user=\"user\",\n                password=\"pass\",\n                connect_timeout=2\n            )\n            conn.close()\n            return \"UP\"  # Registry composes to \"db:UP\"\n        except:\n            return \"DOWN\"  # Registry composes to \"db:DOWN\"\n\ndef register(app, events):\n    db_segment = DbStatusSegment()\n    register_hud_segment(db_segment)\n\n    # Update cache every 5 minutes\n    import threading\n    import time\n\n    def periodic_update():\n        while True:\n            time.sleep(300)  # 5 minutes\n            registry = get_registry()\n            context = {\"env\": api.get_active_env()}\n            registry.update_cached_segments(context)\n\n    threading.Thread(target=periodic_update, daemon=True).start()\n\n    # Also update on environment change\n    def on_env_change(new_env: str, old_env: str, **kwargs):\n        registry = get_registry()\n        context = {\"env\": new_env}\n        registry.update_cached_segments(context)\n\n    events.on(\"env_change\", on_env_change)\n</code></pre>"},{"location":"guides/hud-segments/#see-also","title":"See Also","text":"<ul> <li>Event System Reference</li> <li>Spoke Development Guide</li> <li>HUD Configuration</li> </ul>"},{"location":"guides/writing-gears/","title":"Writing Gears","text":"<p>Complete guide to developing Axium Gears \u2014 privileged automation extensions with enhanced capabilities.</p>"},{"location":"guides/writing-gears/#when-to-use-gears","title":"When to Use Gears","text":"<p>Choose Gears over Spokes when you need:</p> <ul> <li>Tmux pane management - Spawn commands in split panes</li> <li>Long-running processes - Background jobs with lifecycle management</li> <li>Filesystem access - Read/write files with permissions</li> <li>Command prefix registration - Dynamically wrap system commands</li> <li>Privileged IPC operations - HUD updates, notifications, file operations</li> </ul> <p>Example use cases: - Ansible playbook runner with tmux output - Terraform workspace manager with state file access - Docker Compose orchestrator with context switching - CI/CD job runner with artifact management</p>"},{"location":"guides/writing-gears/#project-structure","title":"Project Structure","text":"<p>Create a gear directory in <code>~/.config/axium/gears/&lt;name&gt;/</code>:</p> <pre><code>~/.config/axium/gears/\n  my-gear/\n    gear.yaml          # Manifest\n    main.py            # Entry point\n    runner.py          # Additional modules (optional)\n    utils.py           # Helper functions (optional)\n</code></pre>"},{"location":"guides/writing-gears/#step-1-create-manifest","title":"Step 1: Create Manifest","text":"<p>Create <code>gear.yaml</code> with metadata and permissions:</p> <pre><code>name: my-gear\nversion: 0.1.0\ndescription: My automation gear\nauthor: Your Name\nentrypoint: main:register\n\npermissions:\n  exec: true           # Allow subprocess execution\n  notify: true         # Allow notifications\n  net: false           # Deny network access\n\n  ipc:\n    - tmux_split_run   # Create tmux panes\n    - hud_update       # Update HUD\n    - notify           # Send notifications\n    - read_file        # Read files via daemon\n\n  fs_read:\n    - ~/.my-tool/**    # Read tool config\n    - ~/projects/**    # Read project files\n\n  fs_write:\n    - ~/.my-tool/cache/**   # Write cache\n    - ~/projects/logs/**    # Write logs\n\n# Optional: Register command wrappers\nprefixes:\n  - command: my-tool\n    wrapper: axium my-gear-run\n</code></pre>"},{"location":"guides/writing-gears/#manifest-guidelines","title":"Manifest Guidelines","text":"<ol> <li>Be conservative with permissions - Only request what you need</li> <li>Document filesystem patterns - Use comments for clarity</li> <li>Limit IPC actions - Only include actions you'll use</li> <li>Version semantically - Follow semver for version field</li> </ol>"},{"location":"guides/writing-gears/#step-2-implement-register","title":"Step 2: Implement register()","text":"<p>Create <code>main.py</code> with the registration function:</p> <pre><code>\"\"\"\nMy Gear - Automation example.\n\"\"\"\n\ndef register(app, events):\n    \"\"\"\n    Register gear commands and event handlers.\n\n    This function is called by Axium when the gear loads.\n\n    Args:\n        app: Typer CLI application for command registration\n        events: EventBus for event subscriptions\n    \"\"\"\n    from axium.core import api\n    import typer\n\n    @app.command(\"my-gear-run\")\n    def my_gear_run(\n        playbook: str = typer.Argument(..., help=\"Playbook to run\"),\n        check: bool = typer.Option(False, \"--check\", help=\"Dry run mode\")\n    ):\n        \"\"\"\n        Run my-tool automation in tmux pane.\n        \"\"\"\n        # Build command\n        cmd = f\"my-tool execute {playbook}\"\n        if check:\n            cmd += \" --check\"\n\n        # Run in tmux pane (requires ipc: [tmux_split_run])\n        result = api.tmux_split_run(\n            gear_name=\"my-gear\",\n            command=cmd,\n            height=20,\n            cwd=\"~/projects\"\n        )\n\n        if result[\"ok\"]:\n            pane_id = result.get(\"pane_id\")\n            print(f\"\u2713 Running in pane {pane_id}\")\n\n            # Update HUD (requires ipc: [hud_update])\n            api.update_hud_segment(\"my-gear\", \"[my-gear:RUNNING]\")\n        else:\n            error = result.get(\"error\", \"Unknown error\")\n            print(f\"\u2717 Failed: {error}\")\n            raise typer.Exit(1)\n\n    @app.command(\"my-gear-status\")\n    def my_gear_status():\n        \"\"\"\n        Show gear status.\n        \"\"\"\n        # Read config file (requires ipc: [read_file])\n        result = api.read_file(\"my-gear\", \"~/.my-tool/config.yaml\")\n\n        if result[\"ok\"]:\n            content = result[\"content\"]\n            print(f\"Config loaded: {len(content)} bytes\")\n        else:\n            print(\"\u2717 Failed to read config\")\n\n    # React to environment changes\n    def on_env_change(new_env, old_env):\n        \"\"\"Handle environment switch.\"\"\"\n        # Send notification (requires permissions: notify: true, ipc: [notify])\n        api.notify_send_cli(\n            \"my-gear\",\n            \"Environment Changed\",\n            f\"Switched from {old_env} to {new_env}\"\n        )\n\n    events.on(\"env_change\", on_env_change)\n\n    # React to gear loaded event\n    def on_gear_loaded(gear_name):\n        \"\"\"Initialize when gear loads.\"\"\"\n        if gear_name == \"my-gear\":\n            print(\"[my-gear] Initialized\")\n\n    events.on(\"gear_loaded\", on_gear_loaded)\n</code></pre>"},{"location":"guides/writing-gears/#step-3-using-the-api","title":"Step 3: Using the API","text":"<p>Gears access privileged operations through <code>axium.core.api</code>:</p>"},{"location":"guides/writing-gears/#tmux-pane-management","title":"Tmux Pane Management","text":"<pre><code>from axium.core import api\n\n# Create pane and run command\nresult = api.tmux_split_run(\n    gear_name=\"my-gear\",\n    command=\"long-running-process\",\n    height=20,           # Percentage of window height\n    cwd=\"~/projects\",    # Working directory\n    env_vars={\"FOO\": \"bar\"}  # Additional environment vars\n)\n\n# result: {\"ok\": True, \"pane_id\": \"%3\"}\n</code></pre> <p>Requires: <code>ipc: [tmux_split_run]</code></p>"},{"location":"guides/writing-gears/#hud-updates","title":"HUD Updates","text":"<pre><code>from axium.core import api\n\n# Update HUD segment\napi.update_hud_segment(\"my-gear\", \"[my-gear:ACTIVE]\")\n\n# Clear HUD segment\napi.update_hud_segment(\"my-gear\", \"\")\n</code></pre> <p>Requires: <code>ipc: [hud_update]</code></p>"},{"location":"guides/writing-gears/#notifications","title":"Notifications","text":"<pre><code>from axium.core import api\n\n# Send notification\napi.notify_send_cli(\n    spoke_name=\"my-gear\",\n    title=\"Job Complete\",\n    body=\"Playbook finished successfully\",\n    level=\"info\"  # info, warning, error\n)\n</code></pre> <p>Requires: <code>permissions: {notify: true}</code> and <code>ipc: [notify]</code></p>"},{"location":"guides/writing-gears/#file-operations","title":"File Operations","text":"<pre><code>from axium.core import api\n\n# Read file (via daemon)\nresult = api.read_file(\"my-gear\", \"~/.my-tool/config.yaml\")\nif result[\"ok\"]:\n    content = result[\"content\"]  # str\n\n# Write file (via daemon)\nresult = api.write_file(\"my-gear\", \"~/projects/output.txt\", \"Hello\\n\")\nif result[\"ok\"]:\n    print(\"File written\")\n</code></pre> <p>Requires: <code>ipc: [read_file]</code> and/or <code>ipc: [write_file]</code> Requires: Matching <code>fs_read</code> or <code>fs_write</code> patterns</p>"},{"location":"guides/writing-gears/#environment-access","title":"Environment Access","text":"<pre><code>from axium.core import api\n\n# Get environment data\nresult = api.get_env_data(\"my-gear\")\nif result[\"ok\"]:\n    env_data = result[\"env_data\"]\n    prefix = env_data.get(\"prefix\")\n    region = env_data.get(\"region\")\n</code></pre> <p>Requires: <code>ipc: [get_env_data]</code></p>"},{"location":"guides/writing-gears/#step-4-event-handling","title":"Step 4: Event Handling","text":"<p>Subscribe to Axium events:</p>"},{"location":"guides/writing-gears/#available-events","title":"Available Events","text":"Event Args Description <code>env_change</code> <code>new_env, old_env</code> Environment switched <code>gear_loaded</code> <code>gear_name</code> Gear finished loading <code>spoke_loaded</code> <code>spoke_name</code> Spoke finished loading <code>hud_refresh</code> None HUD needs refresh <code>daemon_ready</code> None Daemon startup complete"},{"location":"guides/writing-gears/#example-handlers","title":"Example Handlers","text":"<pre><code>def register(app, events):\n    # Environment changes\n    def on_env_change(new_env, old_env):\n        print(f\"Env: {old_env} \u2192 {new_env}\")\n        # Reload gear config for new environment\n        load_config_for_env(new_env)\n\n    events.on(\"env_change\", on_env_change)\n\n    # Daemon startup\n    def on_daemon_ready():\n        # Initialize gear state\n        initialize_gear_state()\n\n    events.on(\"daemon_ready\", on_daemon_ready)\n\n    # Other gear loaded\n    def on_gear_loaded(gear_name):\n        if gear_name == \"terraform\":\n            # Coordinate with terraform gear\n            setup_terraform_integration()\n\n    events.on(\"gear_loaded\", on_gear_loaded)\n</code></pre>"},{"location":"guides/writing-gears/#step-5-prefix-registration","title":"Step 5: Prefix Registration","text":"<p>Gears can register command prefixes in their manifest:</p> <pre><code># gear.yaml\nprefixes:\n  - command: ansible-playbook\n    wrapper: axium ansible-run\n\n  - command: terraform\n    wrapper: axium tf-run\n</code></pre> <p>When these commands are executed, they'll be intercepted and wrapped:</p> <pre><code># User types:\nansible-playbook site.yml\n\n# Actually executes:\naxium ansible-run site.yml\n</code></pre>"},{"location":"guides/writing-gears/#prefix-conflict-detection","title":"Prefix Conflict Detection","text":"<p>If multiple gears register the same command, Axium detects the conflict:</p> <pre><code>[WARNING] Prefix conflict: command 'terraform' already registered by gear 'terraform-gear'\n[WARNING] Gear 'my-gear' attempted to register 'terraform' but was rejected\n</code></pre> <p>First gear to register wins. Users can resolve conflicts by: - Disabling one gear - Removing prefix from one manifest - Using permission overrides</p>"},{"location":"guides/writing-gears/#step-6-testing","title":"Step 6: Testing","text":""},{"location":"guides/writing-gears/#manual-testing","title":"Manual Testing","text":"<pre><code># Reload daemon to pick up gear changes\naxium daemon reload\n\n# Test gear commands\naxium my-gear-run playbook.yml\naxium my-gear-status\n\n# Check gear loaded correctly\naxium gear list\n\n# View permissions\naxium gear perms-show my-gear\n\n# Check logs\naxium daemon logs -f\n</code></pre>"},{"location":"guides/writing-gears/#unit-testing","title":"Unit Testing","text":"<pre><code># tests/test_my_gear.py\nimport pytest\nfrom pathlib import Path\n\ndef test_gear_manifest():\n    \"\"\"Test manifest is valid YAML.\"\"\"\n    gear_path = Path(\"~/.config/axium/gears/my-gear\").expanduser()\n    manifest = gear_path / \"gear.yaml\"\n\n    assert manifest.exists()\n\n    import yaml\n    data = yaml.safe_load(manifest.read_text())\n\n    assert data[\"name\"] == \"my-gear\"\n    assert \"permissions\" in data\n    assert \"entrypoint\" in data\n\ndef test_register_function():\n    \"\"\"Test register function exists.\"\"\"\n    from gears.my_gear import main\n\n    assert hasattr(main, \"register\")\n    assert callable(main.register)\n</code></pre>"},{"location":"guides/writing-gears/#step-7-permission-overrides","title":"Step 7: Permission Overrides","text":"<p>Allow users to customize permissions:</p>"},{"location":"guides/writing-gears/#create-override-template","title":"Create Override Template","text":"<pre><code>axium gear perms-edit my-gear\n</code></pre> <p>This creates <code>~/.config/axium/overrides/permissions/my-gear.yaml</code>:</p> <pre><code># Permission overrides for gear: my-gear\n# See base permissions in: ~/.config/axium/gears/my-gear/gear.yaml\n\n# Uncomment to override:\n# exec: true\n# notify: false\n# net: true\n# ipc:\n#   - tmux_split_run\n#   - hud_update\n# fs_read:\n#   - ~/custom/path/**\n# fs_write:\n#   - ~/custom/output/**\n</code></pre>"},{"location":"guides/writing-gears/#test-overrides","title":"Test Overrides","text":"<pre><code># View effective permissions (base + overrides)\naxium gear perms-show my-gear\n\n# Reload to apply changes\naxium daemon reload\n</code></pre>"},{"location":"guides/writing-gears/#best-practices","title":"Best Practices","text":""},{"location":"guides/writing-gears/#1-security","title":"1. Security","text":"<ul> <li>Minimal permissions - Only request what you need</li> <li>Validate inputs - Sanitize user input before executing</li> <li>Error handling - Gracefully handle permission denials</li> <li>Audit logging - Log privileged operations</li> </ul>"},{"location":"guides/writing-gears/#2-user-experience","title":"2. User Experience","text":"<ul> <li>Clear command names - Use <code>&lt;gear&gt;-&lt;action&gt;</code> pattern</li> <li>Help text - Document all commands and options</li> <li>Error messages - Provide actionable error messages</li> <li>Progress feedback - Show status for long operations</li> </ul>"},{"location":"guides/writing-gears/#3-development","title":"3. Development","text":"<ul> <li>Type hints - Use type annotations for clarity</li> <li>Docstrings - Document all public functions</li> <li>Testing - Write unit tests for core logic</li> <li>Versioning - Follow semver for releases</li> </ul>"},{"location":"guides/writing-gears/#4-integration","title":"4. Integration","text":"<ul> <li>Event coordination - Use events to coordinate with other gears</li> <li>HUD updates - Keep HUD in sync with gear state</li> <li>Configuration - Use Axium's environment system</li> <li>Logging - Use Python logging module</li> </ul>"},{"location":"guides/writing-gears/#example-complete-ansible-gear","title":"Example: Complete Ansible Gear","text":"<pre><code># ~/.config/axium/gears/ansible/main.py\n\n\"\"\"\nAnsible Gear - Run playbooks in tmux with environment context.\n\"\"\"\n\nimport typer\nfrom pathlib import Path\nfrom axium.core import api\n\ndef register(app, events):\n    \"\"\"Register ansible gear commands.\"\"\"\n\n    @app.command(\"ansible-run\")\n    def ansible_run(\n        playbook: str = typer.Argument(..., help=\"Playbook file\"),\n        inventory: str = typer.Option(None, \"-i\", help=\"Inventory file\"),\n        check: bool = typer.Option(False, \"--check\", help=\"Dry run\"),\n        diff: bool = typer.Option(False, \"--diff\", help=\"Show diffs\")\n    ):\n        \"\"\"\n        Run Ansible playbook in tmux pane with environment context.\n        \"\"\"\n        # Get current environment data\n        env_result = api.get_env_data(\"ansible\")\n        if not env_result[\"ok\"]:\n            print(\"\u2717 Failed to get environment data\")\n            raise typer.Exit(1)\n\n        env_data = env_result[\"env_data\"]\n\n        # Build command\n        cmd = f\"ansible-playbook {playbook}\"\n\n        if inventory:\n            cmd += f\" -i {inventory}\"\n        elif \"ansible_inventory\" in env_data:\n            # Use environment-specific inventory\n            cmd += f\" -i {env_data['ansible_inventory']}\"\n\n        if check:\n            cmd += \" --check\"\n        if diff:\n            cmd += \" --diff\"\n\n        # Add environment variables\n        env_vars = {}\n        if \"ansible_vault_password_file\" in env_data:\n            env_vars[\"ANSIBLE_VAULT_PASSWORD_FILE\"] = env_data[\"ansible_vault_password_file\"]\n\n        print(f\"Running: {cmd}\")\n\n        # Execute in tmux pane\n        result = api.tmux_split_run(\n            gear_name=\"ansible\",\n            command=cmd,\n            height=30,\n            cwd=Path.cwd(),\n            env_vars=env_vars\n        )\n\n        if result[\"ok\"]:\n            pane_id = result[\"pane_id\"]\n            print(f\"\u2713 Playbook running in pane {pane_id}\")\n\n            # Update HUD\n            api.update_hud_segment(\"ansible\", \"[ansible:RUNNING]\")\n\n            # Send notification\n            api.notify_send_cli(\n                \"ansible\",\n                \"Playbook Started\",\n                f\"Running {playbook} in {pane_id}\"\n            )\n        else:\n            error = result.get(\"error\", \"Unknown error\")\n            print(f\"\u2717 Failed to start playbook: {error}\")\n            raise typer.Exit(1)\n\n    @app.command(\"ansible-check\")\n    def ansible_check():\n        \"\"\"Check Ansible installation and configuration.\"\"\"\n        # Read ansible.cfg\n        config_result = api.read_file(\"ansible\", \"~/ansible/ansible.cfg\")\n\n        if config_result[\"ok\"]:\n            print(\"\u2713 Ansible config found\")\n        else:\n            print(\"\u2717 No ansible.cfg found\")\n\n        # Get environment data\n        env_result = api.get_env_data(\"ansible\")\n        if env_result[\"ok\"]:\n            env_data = env_result[\"env_data\"]\n            print(f\"\u2713 Environment: {env_data.get('name', 'unknown')}\")\n            if \"ansible_inventory\" in env_data:\n                print(f\"  Inventory: {env_data['ansible_inventory']}\")\n        else:\n            print(\"\u2717 Failed to get environment\")\n\n    # Event handlers\n    def on_env_change(new_env, old_env):\n        \"\"\"Clear HUD when environment changes.\"\"\"\n        api.update_hud_segment(\"ansible\", \"\")\n\n    events.on(\"env_change\", on_env_change)\n</code></pre> <p>With manifest:</p> <pre><code># ~/.config/axium/gears/ansible/gear.yaml\nname: ansible\nversion: 1.0.0\ndescription: Ansible playbook automation with tmux\nauthor: Axium Team\nentrypoint: main:register\n\npermissions:\n  exec: true\n  notify: true\n  net: false\n\n  ipc:\n    - tmux_split_run\n    - hud_update\n    - notify\n    - read_file\n    - get_env_data\n\n  fs_read:\n    - ~/.ansible/**\n    - ~/ansible/**\n    - ~/.ssh/config\n\n  fs_write:\n    - ~/.ansible/tmp/**\n    - ~/ansible/logs/**\n\nprefixes:\n  - command: ansible-playbook\n    wrapper: axium ansible-run\n</code></pre>"},{"location":"guides/writing-gears/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/writing-gears/#permission-denied-errors","title":"Permission Denied Errors","text":"<pre><code>Error: Gear 'my-gear' lacks IPC permission: tmux_split_run\n</code></pre> <p>Solution: Add permission to <code>gear.yaml</code>:</p> <pre><code>permissions:\n  ipc:\n    - tmux_split_run\n</code></pre>"},{"location":"guides/writing-gears/#gear-not-loading","title":"Gear Not Loading","text":"<p>Check daemon logs:</p> <pre><code>axium daemon logs | grep my-gear\n</code></pre> <p>Common issues: - Syntax error in <code>gear.yaml</code> - Missing <code>entrypoint</code> function - Import errors in gear code</p>"},{"location":"guides/writing-gears/#prefix-not-working","title":"Prefix Not Working","text":"<pre><code># Check if prefix registered\naxium wrapper list\n\n# Check for conflicts\naxium daemon logs | grep \"Prefix conflict\"\n</code></pre>"},{"location":"guides/writing-gears/#official-gears","title":"Official Gears","text":"<p>The Axium project maintains several official gears that demonstrate best practices and provide common functionality:</p>"},{"location":"guides/writing-gears/#axium-gear-ansible","title":"axium-gear-ansible","text":"<p>Profile-based ansible-playbook execution with environment awareness. Simplifies Ansible operations with preconfigured profiles and environment-specific inventory management.</p> <p>Features: - Profile-based playbook execution - Environment-aware inventory selection - Automatic verbosity control - Tag filtering support - Dry-run mode - Custom variables per profile</p> <p>Permissions: - <code>exec</code>: Run ansible-playbook commands - <code>fs_read</code>: Access inventory and playbook files - <code>notify</code>: Send completion notifications</p>"},{"location":"guides/writing-gears/#axium-gear-web","title":"axium-gear-web","text":"<p>Web dashboard for Axium state, permissions, and notifications. Provides a modern web interface for monitoring and managing Axium.</p> <p>Features: - Real-time state visualization - Permission management UI - Notification history viewer - Environment switching - Gear and spoke status monitoring - RESTful API for external integrations</p> <p>Permissions: - <code>exec</code>: Start embedded web server - <code>fs_read</code>: Read Axium configuration - <code>ipc</code>: Access daemon state and notifications</p>"},{"location":"guides/writing-gears/#see-also","title":"See Also","text":"<ul> <li>Gears Concept - Architecture and permissions</li> <li>Gears API Reference - Complete API docs</li> <li>Spokes Guide - Alternative plugin system</li> <li>Permissions - Permission system details</li> </ul>"},{"location":"guides/writing-spokes/","title":"\ud83e\udde9 Axium Spokes: Architecture &amp; Contribution Guide","text":"<p>Axium\u2019s Spokes are how we extend the platform \u2014 logic, not config.</p>"},{"location":"guides/writing-spokes/#overview","title":"Overview","text":"<p>Spokes are lightweight Python modules that extend Axium\u2019s behavior by registering hooks, commands, and integrations. They never carry their own configuration files. All persistent data lives in Axium\u2019s core config (like <code>envs.yaml</code>, <code>prefixes.yaml</code>, <code>settings.yaml</code>).</p> <p>This design keeps Axium declarative, deterministic, and reloadable at runtime.</p>"},{"location":"guides/writing-spokes/#philosophy-config-lives-in-core-logic-lives-in-spokes","title":"\ud83d\udd27 Philosophy: \u201cConfig lives in core, logic lives in Spokes\u201d","text":"Responsibility Lives in Example Persistent configuration Core <code>~/.config/axium/envs.yaml</code>, <code>prefixes.yaml</code> Runtime logic &amp; integrations Spokes Hooks, commands, event listeners Declarative state Daemon <code>state.json</code> (active env, status) Execution context Command wrapper <code>axium run &lt;cmd&gt;</code>"},{"location":"guides/writing-spokes/#what-a-spoke-is","title":"\ud83e\udde0 What a Spoke is","text":"<p>A Spoke is just a Python file (or package) that exports a single <code>register()</code> function.</p> <pre><code>def register(app, events):\n    # Add CLI commands\n    @app.command(\"aws-whoami\")\n    def aws_whoami():\n        import boto3\n        print(boto3.client(\"sts\").get_caller_identity())\n\n    # Subscribe to events\n    def on_env_change(new_env):\n        print(f\"[spoke:aws] environment changed \u2192 {new_env}\")\n    events.on(\"env_change\", on_env_change)\n\n    # Access environment data\n    from axium.core import env\n    current_env = env.get_active_env_name()\n    prefix = env.get_env_value(\"prefix\")\n</code></pre> <p>That's it. No YAML, no hidden state, no user configuration.</p>"},{"location":"guides/writing-spokes/#what-spokes-can-do","title":"\u2699\ufe0f What Spokes Can Do","text":"Capability Description Example Register CLI commands Add subcommands to <code>axium</code> <code>axium aws whoami</code> Hook into events React to daemon or CLI lifecycle <code>on_env_change</code>, <code>on_prefix_apply</code> Extend prefix logic Register new prefix rules dynamically <code>register_prefix(\"aws\", \"aws\", \"axium run aws\")</code> Intelligent command routing Seamlessly blend spoke + native commands <code>aws whoami</code> (spoke) vs <code>aws s3 ls</code> (native) Add HUD / Palette elements (Future) Display widgets or menu items <code>register_hud_widget(\"aws-status\")</code> Run background tasks Schedule or poll data quietly via daemon hooks Example: refresh EC2 list every 60s"},{"location":"guides/writing-spokes/#event-system","title":"\ud83e\ude9d Event System","text":"<p>Axium provides a synchronous event bus for runtime extensibility and coordination between Spokes.</p>"},{"location":"guides/writing-spokes/#core-events","title":"Core Events","text":"Event When it triggers Common use <code>env_change(new_env, old_env)</code> After <code>axium env set</code> Update context, refresh credentials <code>spoke_loaded(spoke_name)</code> When a Spoke finishes loading Initialization, set initial HUD state <code>spoke_reloaded(spoke_name)</code> After <code>axium daemon reload</code> Refresh config, clear caches <code>daemon_reload()</code> After daemon configuration reloads Reload spoke-specific config <code>config_reloaded()</code> After all spoke configs are cleared Re-read configuration files <code>hud_segment_updated(spoke, value)</code> When a HUD segment changes Coordinate related HUD segments <code>hud_refresh()</code> When HUD should be regenerated Update dynamic HUD segments <code>gear_loaded(gear_name)</code> When a Gear finishes loading Initialize gear integrations <p>Events are registered via <code>events.on()</code> and receive arguments as shown. See the Events Reference for complete details on signatures, timing, and best practices.</p>"},{"location":"guides/writing-spokes/#spoke-lifecycle","title":"\ud83e\udde9 Spoke Lifecycle","text":"<ol> <li>Load \u2013 The daemon scans <code>spokes/</code> and imports each Spoke.</li> <li>Register \u2013 Calls each Spoke's <code>register(app, events)</code> function.</li> <li>Activate \u2013 Hooks and commands become live.</li> <li>Reload \u2013 On demand (<code>axium daemon reload</code>) without restart.</li> <li>Unload \u2013 When daemon exits or Spoke disables itself.</li> </ol> <p>Spokes can be safely added or removed between reloads \u2014 no reboot required.</p>"},{"location":"guides/writing-spokes/#directory-layout-example","title":"\ud83d\udce6 Directory Layout Example","text":"<pre><code>axium/\n  core/\n    prefix.py\n    env.py\n    spokes.py       # Loader\n  spokes/\n    aws_spoke.py\n    terraform_spoke.py\n    command_wrapper.py\n  ...\n</code></pre>"},{"location":"guides/writing-spokes/#example-command-wrapper-spoke","title":"\ud83e\uddf1 Example: Command Wrapper Spoke","text":"<p>This built-in Spoke handles all prefixed command execution. It defines the <code>axium run</code> CLI command and applies prefix rules before running binaries.</p> <pre><code>def register(app, events, env):\n    @app.command(\"run\")\n    def run(cmd: list[str]):\n        from axium.core.prefix import apply_prefixes\n        full_cmd = apply_prefixes(cmd)\n        subprocess.run(full_cmd)\n</code></pre> <p>Other Spokes (like AWS or Terraform) simply register prefix metadata \u2014 not their own executors.</p>"},{"location":"guides/writing-spokes/#intelligent-command-routing","title":"\ud83d\udd00 Intelligent Command Routing","text":"<p>When a Spoke registers both CLI commands and prefix wrappers, <code>axium run</code> intelligently routes between them:</p> <pre><code>def register(api):\n    # Register spoke commands\n    @api.command(\"whoami\")\n    def whoami():\n        \"\"\"Show current AWS identity\"\"\"\n        # Custom spoke logic\n        pass\n\n    @api.command(\"info\")\n    def info():\n        \"\"\"Show AWS environment info\"\"\"\n        # Custom spoke logic\n        pass\n\n    # Register prefix wrapper for native commands\n    api.register_prefix(\"aws\", \"aws\", \"axium run aws\")\n</code></pre> <p>User Experience: <pre><code># Spoke commands route to spoke\naws whoami      # \u2192 axium aws whoami (spoke command)\naws info        # \u2192 axium aws info (spoke command)\n\n# Native commands get prefix applied\naws s3 ls       # \u2192 enva-prod aws s3 ls (native CLI)\naws ec2 describe-instances  # \u2192 enva-prod aws ec2... (native CLI)\n</code></pre></p> <p>The routing logic automatically: 1. Checks if the first argument matches a registered spoke subcommand 2. If YES \u2192 routes to <code>axium &lt;spoke&gt; &lt;subcommand&gt;</code> 3. If NO \u2192 applies prefix wrapper for native command</p> <p>This allows Spokes to seamlessly extend native CLI tools without requiring users to learn different command patterns.</p>"},{"location":"guides/writing-spokes/#what-spokes-should-not-do","title":"\ud83d\udeab What Spokes Should NOT Do","text":"Don\u2019t Reason Store their own YAML or JSON config Breaks the declarative model Manage state directly The daemon owns runtime state Modify core files All extension points go through events or the app API Depend on other Spokes directly Use event hooks instead"},{"location":"guides/writing-spokes/#data-access-for-spokes","title":"\ud83e\udde9 Data Access for Spokes","text":"<p>Spokes can safely read contextual data through <code>env</code> and <code>core</code> helpers.</p> <pre><code>env.current() \u2192 returns active env key (e.g. \"root\")\nenv.get(\"aws_profile\") \u2192 returns property from envs.yaml\nenv.all() \u2192 returns full envs.yaml mapping\n</code></pre> <p>They can also query or update via IPC if needed (<code>axiumd</code> exposes small APIs).</p>"},{"location":"guides/writing-spokes/#contribution-guidelines-for-spokes","title":"\u2705 Contribution Guidelines for Spokes","text":"<ol> <li>Keep it stateless \u2014 no persistent config or files.</li> <li>Use <code>register()</code> with <code>(app, events, env)</code> signature.</li> <li>Prefer declarative config in core (<code>envs.yaml</code>, etc.).</li> <li>Ensure commands are namespaced (<code>axium aws-*</code>, <code>axium tf-*</code>).</li> <li>Use events for coordination between Spokes.</li> <li>Document any external dependencies (e.g., boto3).</li> <li>Avoid blocking calls \u2014 use async when possible.</li> </ol>"},{"location":"guides/writing-spokes/#official-spokes","title":"\ud83d\udce6 Official Spokes","text":"<p>The Axium project maintains several official spokes that demonstrate best practices and provide common functionality:</p>"},{"location":"guides/writing-spokes/#axium-spoke-creds","title":"axium-spoke-creds","text":"<p>Credential validity checking with HUD integration. Provides commands to check credential status and displays validity in the HUD status line.</p> <p>Features: - Check credential validity for current environment - Display credential status in HUD (green Y / red N) - Automatic credential refresh hooks - Environment-aware credential management</p>"},{"location":"guides/writing-spokes/#axium-spoke-aws","title":"axium-spoke-aws","text":"<p>AWS CLI wrapper with intelligent resource discovery. Simplifies common AWS operations with environment-aware commands.</p> <p>Features: - EC2 instance listing and management - Resource search across services - Cost analysis commands - Recent resource activity tracking - Environment-specific AWS profile handling</p>"},{"location":"guides/writing-spokes/#design-summary","title":"\ud83e\udde0 Design Summary","text":"<ul> <li>Axium owns all persistent config (YAML, state).</li> <li>Spokes are pure Python runtime extensions.</li> <li>Each Spoke registers commands and event hooks.</li> <li>The daemon orchestrates, reloads, and isolates them.</li> <li>Core provides shared APIs for envs, prefixing, state, and IPC.</li> </ul> <p>Declarative data. Procedural extensions. One consistent model.</p> <p>This doc complements <code>CONTRIBUTING.md</code> by describing how to author and structure new Spokes.</p>"},{"location":"reference/api/","title":"API Reference","text":"<p>Complete reference for <code>axium.core.api</code> - the high-level Python API for spokes and gears.</p> <p>Use API over IPC</p> <p>Spokes and gears should always use this API instead of calling IPC commands directly. The API provides:</p> <ul> <li>Error handling - Graceful failures with logging</li> <li>Type safety - Proper type hints and validation</li> <li>Better ergonomics - Simpler function signatures</li> <li>Permission checks - Automatic validation for gears</li> <li>Future compatibility - IPC protocol changes won't break your code</li> </ul>"},{"location":"reference/api/#quick-start","title":"Quick Start","text":"<pre><code>from axium.core import api\n\n# Environment management\nenv = api.get_active_env()\napi.set_active_env(\"prod\")\n\n# Configuration\nconfig = api.load_config(\"myspoke\", \"config.yaml\")\n\n# Notifications\napi.send_notification(\"myspoke\", \"Alert\", \"Something happened\", level=\"warning\")\n\n# Daemon control\napi.reload_daemon()\nstatus = api.daemon_status()\n</code></pre>"},{"location":"reference/api/#api-vs-ipc","title":"API vs IPC","text":"Use Case Recommended Approach Spokes Use <code>api.*</code> functions exclusively Gears Use <code>api.*</code> functions (permission-checked) Core daemon Direct IPC for internal operations CLI commands Use <code>api.*</code> for most operations Testing Mock <code>api</code> functions, not IPC <p>See IPC Commands Reference for low-level protocol details.</p>"},{"location":"reference/api/#core-functions","title":"Core Functions","text":"<p>Axium Core API - High-level interface for spokes.</p> <p>This module provides a simplified, public API for spokes to interact with the Axium daemon, environment state, configuration, and other core services.</p> <p>Spokes should import from this module instead of using axium.core.ipc directly. All functions handle errors gracefully and return None on failure.</p> Example <pre><code>from axium.core import api\n\n# Get current environment\nenv = api.get_active_env()\n\n# Load spoke config\nconfig = api.load_config(\"myspoke\", \"myspoke.yaml\")\n\n# Update HUD\napi.update_hud_segment(\"myspoke\", \"[myspoke:OK]\")\n\n# Send notification\napi.send_notification(\"myspoke\", \"Alert\", \"Something happened\")\n\n# Execute command via daemon\napi.daemon_exec(\"myspoke\", \"some-command\")\n</code></pre>"},{"location":"reference/api/#axium.core.api.get_active_env","title":"<code>get_active_env()</code>","text":"<p>Get the name of the currently active environment.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>Active environment name, or None if not set or unreachable.</p> Example <pre><code>&gt;&gt;&gt; api.get_active_env()\n'prod'\n</code></pre> Source code in <code>axium/core/api.py</code> <pre><code>def get_active_env() -&gt; str | None:\n    \"\"\"\n    Get the name of the currently active environment.\n\n    Returns:\n        Active environment name, or None if not set or unreachable.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; api.get_active_env()\n        'prod'\n        ```\n    \"\"\"\n    try:\n        from axium.core.env import get_active_env_name\n\n        return get_active_env_name()\n    except Exception as e:\n        logger.debug(\"Failed to get active environment: %s\", e)\n        return None\n</code></pre>"},{"location":"reference/api/#axium.core.api.get_env_data","title":"<code>get_env_data(name)</code>","text":"<p>Get configuration data for a specific environment.</p> <p>Returns all configuration for the named environment, including variables, inventory paths, and other environment-specific settings.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Environment name to query</p> required <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>Environment configuration dict, or None if environment doesn't exist</p> Example <pre><code>&gt;&gt;&gt; data = api.get_env_data('production')\n&gt;&gt;&gt; data['vars']['app_version']\n'1.2.3'\n&gt;&gt;&gt; data.get('ansible_inventory')\n'~/ansible/inventories/production.ini'\n</code></pre> Source code in <code>axium/core/api.py</code> <pre><code>def get_env_data(name: str) -&gt; dict[str, Any] | None:\n    \"\"\"\n    Get configuration data for a specific environment.\n\n    Returns all configuration for the named environment, including\n    variables, inventory paths, and other environment-specific settings.\n\n    Args:\n        name: Environment name to query\n\n    Returns:\n        Environment configuration dict, or None if environment doesn't exist\n\n    Example:\n        ```python\n        &gt;&gt;&gt; data = api.get_env_data('production')\n        &gt;&gt;&gt; data['vars']['app_version']\n        '1.2.3'\n        &gt;&gt;&gt; data.get('ansible_inventory')\n        '~/ansible/inventories/production.ini'\n        ```\n    \"\"\"\n    try:\n        from axium.core.env import load_environments\n\n        envs = load_environments()\n        return envs.get(name)\n    except Exception as e:\n        logger.debug(\"Failed to get environment data for %s: %s\", name, e)\n        return None\n</code></pre>"},{"location":"reference/api/#axium.core.api.set_active_env","title":"<code>set_active_env(name, pane_id=None)</code>","text":"<p>Set the active environment (global or pane-specific).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Environment name to activate</p> required <code>pane_id</code> <code>str | None</code> <p>Optional tmux pane ID for pane-specific environment</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p> Example <pre><code>&gt;&gt;&gt; api.set_active_env(\"prod\")\nTrue\n&gt;&gt;&gt; api.set_active_env(\"dev\", pane_id=\"%1\")\nTrue\n</code></pre> Source code in <code>axium/core/api.py</code> <pre><code>def set_active_env(name: str, pane_id: str | None = None) -&gt; bool:\n    \"\"\"\n    Set the active environment (global or pane-specific).\n\n    Args:\n        name: Environment name to activate\n        pane_id: Optional tmux pane ID for pane-specific environment\n\n    Returns:\n        True if successful, False otherwise\n\n    Example:\n        ```python\n        &gt;&gt;&gt; api.set_active_env(\"prod\")\n        True\n        &gt;&gt;&gt; api.set_active_env(\"dev\", pane_id=\"%1\")\n        True\n        ```\n    \"\"\"\n    try:\n        from axium.core.ipc import send_request_sync\n\n        if pane_id:\n            resp = send_request_sync(\n                {\"cmd\": \"set_pane_env\", \"pane\": pane_id, \"env\": name}\n            )\n        else:\n            resp = send_request_sync({\"cmd\": \"set_env\", \"env\": name})\n\n        # Log error if daemon rejected the request\n        if not resp.get(\"ok\"):\n            error = resp.get(\"error\", \"Unknown error\")\n            logger.error(\"Daemon rejected environment change: %s\", error)\n\n        return resp.get(\"ok\", False)\n    except Exception as e:\n        logger.debug(\"Failed to set active environment: %s\", e)\n        return False\n</code></pre>"},{"location":"reference/api/#axium.core.api.get_pane_env","title":"<code>get_pane_env(pane_id)</code>","text":"<p>Get environment for specific tmux pane.</p> <p>Parameters:</p> Name Type Description Default <code>pane_id</code> <code>str</code> <p>Tmux pane ID</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>Environment name or None if not set</p> Example <pre><code>&gt;&gt;&gt; api.get_pane_env(\"%1\")\n'dev'\n</code></pre> Source code in <code>axium/core/api.py</code> <pre><code>def get_pane_env(pane_id: str) -&gt; str | None:\n    \"\"\"\n    Get environment for specific tmux pane.\n\n    Args:\n        pane_id: Tmux pane ID\n\n    Returns:\n        Environment name or None if not set\n\n    Example:\n        ```python\n        &gt;&gt;&gt; api.get_pane_env(\"%1\")\n        'dev'\n        ```\n    \"\"\"\n    try:\n        from axium.core.ipc import send_request_sync\n\n        resp = send_request_sync({\"cmd\": \"get_pane_env\", \"pane\": pane_id})\n        if resp.get(\"ok\"):\n            return resp.get(\"env\")\n        return None\n    except Exception as e:\n        logger.debug(\"Failed to get pane environment: %s\", e)\n        return None\n</code></pre>"},{"location":"reference/api/#axium.core.api.clear_pane_env","title":"<code>clear_pane_env(pane_id)</code>","text":"<p>Clear pane-specific environment (falls back to global).</p> <p>Parameters:</p> Name Type Description Default <code>pane_id</code> <code>str</code> <p>Tmux pane ID</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p> Example <pre><code>&gt;&gt;&gt; api.clear_pane_env(\"%1\")\nTrue\n</code></pre> Source code in <code>axium/core/api.py</code> <pre><code>def clear_pane_env(pane_id: str) -&gt; bool:\n    \"\"\"\n    Clear pane-specific environment (falls back to global).\n\n    Args:\n        pane_id: Tmux pane ID\n\n    Returns:\n        True if successful, False otherwise\n\n    Example:\n        ```python\n        &gt;&gt;&gt; api.clear_pane_env(\"%1\")\n        True\n        ```\n    \"\"\"\n    try:\n        from axium.core.ipc import send_request_sync\n\n        resp = send_request_sync({\"cmd\": \"clear_pane_env\", \"pane\": pane_id})\n        return resp.get(\"ok\", False)\n    except Exception as e:\n        logger.debug(\"Failed to clear pane environment: %s\", e)\n        return False\n</code></pre>"},{"location":"reference/api/#axium.core.api.list_environments","title":"<code>list_environments()</code>","text":"<p>List all defined environments.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of environment names (empty list on error)</p> Example <pre><code>&gt;&gt;&gt; api.list_environments()\n['dev', 'staging', 'prod']\n</code></pre> Source code in <code>axium/core/api.py</code> <pre><code>def list_environments() -&gt; list[str]:\n    \"\"\"\n    List all defined environments.\n\n    Returns:\n        List of environment names (empty list on error)\n\n    Example:\n        ```python\n        &gt;&gt;&gt; api.list_environments()\n        ['dev', 'staging', 'prod']\n        ```\n    \"\"\"\n    try:\n        from axium.core import env as env_module\n\n        envs = env_module.load_envs()\n        return list(envs.keys()) if envs else []\n    except Exception as e:\n        logger.debug(\"Failed to list environments: %s\", e)\n        return []\n</code></pre>"},{"location":"reference/api/#axium.core.api.get_state","title":"<code>get_state()</code>","text":"<p>Get current daemon state.</p> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>State dictionary containing active_env, started time, etc.</p> <code>dict[str, Any] | None</code> <p>Returns None if daemon unreachable.</p> Example <pre><code>&gt;&gt;&gt; api.get_state()\n{'active_env': 'prod', 'started': '2024-10-07T10:30:00', ...}\n</code></pre> Source code in <code>axium/core/api.py</code> <pre><code>def get_state() -&gt; dict[str, Any] | None:\n    \"\"\"\n    Get current daemon state.\n\n    Returns:\n        State dictionary containing active_env, started time, etc.\n        Returns None if daemon unreachable.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; api.get_state()\n        {'active_env': 'prod', 'started': '2024-10-07T10:30:00', ...}\n        ```\n    \"\"\"\n    try:\n        from axium.core.ipc import send_request_sync\n\n        resp = send_request_sync({\"cmd\": \"get_state\"})\n        if resp.get(\"ok\"):\n            return resp.get(\"state\")\n        return None\n    except Exception as e:\n        logger.debug(\"Failed to get daemon state: %s\", e)\n        return None\n</code></pre>"},{"location":"reference/api/#axium.core.api.reload_spokes","title":"<code>reload_spokes()</code>","text":"<p>Reload all spokes from disk.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p> Example <pre><code>&gt;&gt;&gt; api.reload_spokes()\nTrue\n</code></pre> Source code in <code>axium/core/api.py</code> <pre><code>def reload_spokes() -&gt; bool:\n    \"\"\"\n    Reload all spokes from disk.\n\n    Returns:\n        True if successful, False otherwise\n\n    Example:\n        ```python\n        &gt;&gt;&gt; api.reload_spokes()\n        True\n        ```\n    \"\"\"\n    try:\n        from axium.core.ipc import send_request_sync\n\n        resp = send_request_sync({\"cmd\": \"reload_spokes\"})\n        return resp.get(\"ok\", False)\n    except Exception as e:\n        logger.debug(\"Failed to reload spokes: %s\", e)\n        return False\n</code></pre>"},{"location":"reference/api/#axium.core.api.reload_daemon","title":"<code>reload_daemon()</code>","text":"<p>Reload daemon configuration from disk.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p> Example <pre><code>&gt;&gt;&gt; api.reload_daemon()\nTrue\n</code></pre> Source code in <code>axium/core/api.py</code> <pre><code>def reload_daemon() -&gt; bool:\n    \"\"\"\n    Reload daemon configuration from disk.\n\n    Returns:\n        True if successful, False otherwise\n\n    Example:\n        ```python\n        &gt;&gt;&gt; api.reload_daemon()\n        True\n        ```\n    \"\"\"\n    try:\n        from axium.core.ipc import send_request_sync\n\n        resp = send_request_sync({\"cmd\": \"reload\"})\n        return resp.get(\"ok\", False)\n    except Exception as e:\n        logger.debug(\"Failed to reload daemon: %s\", e)\n        return False\n</code></pre>"},{"location":"reference/api/#notifications-hud","title":"Notifications &amp; HUD","text":"<p>Axium Core API - High-level interface for spokes.</p> <p>This module provides a simplified, public API for spokes to interact with the Axium daemon, environment state, configuration, and other core services.</p> <p>Spokes should import from this module instead of using axium.core.ipc directly. All functions handle errors gracefully and return None on failure.</p> Example <pre><code>from axium.core import api\n\n# Get current environment\nenv = api.get_active_env()\n\n# Load spoke config\nconfig = api.load_config(\"myspoke\", \"myspoke.yaml\")\n\n# Update HUD\napi.update_hud_segment(\"myspoke\", \"[myspoke:OK]\")\n\n# Send notification\napi.send_notification(\"myspoke\", \"Alert\", \"Something happened\")\n\n# Execute command via daemon\napi.daemon_exec(\"myspoke\", \"some-command\")\n</code></pre>"},{"location":"reference/api/#axium.core.api.send_notification","title":"<code>send_notification(spoke, title, body, level='info')</code>","text":"<p>Send notification via daemon.</p> <p>Parameters:</p> Name Type Description Default <code>spoke</code> <code>str</code> <p>Spoke name</p> required <code>title</code> <code>str</code> <p>Notification title</p> required <code>body</code> <code>str</code> <p>Notification body</p> required <code>level</code> <code>str</code> <p>Notification level (info, warning, error)</p> <code>'info'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p> Example <pre><code>&gt;&gt;&gt; api.send_notification(\"creds\", \"Alert\", \"Credentials expired\", level=\"warning\")\nTrue\n</code></pre> Source code in <code>axium/core/api.py</code> <pre><code>def send_notification(spoke: str, title: str, body: str, level: str = \"info\") -&gt; bool:\n    \"\"\"\n    Send notification via daemon.\n\n    Args:\n        spoke: Spoke name\n        title: Notification title\n        body: Notification body\n        level: Notification level (info, warning, error)\n\n    Returns:\n        True if successful, False otherwise\n\n    Example:\n        ```python\n        &gt;&gt;&gt; api.send_notification(\"creds\", \"Alert\", \"Credentials expired\", level=\"warning\")\n        True\n        ```\n    \"\"\"\n    try:\n        from axium.core.ipc import send_request_sync\n\n        resp = send_request_sync(\n            {\n                \"cmd\": \"notify\",\n                \"spoke\": spoke,\n                \"title\": title,\n                \"body\": body,\n                \"level\": level,\n            }\n        )\n        return resp.get(\"ok\", False)\n    except Exception as e:\n        logger.debug(\"Failed to send notification: %s\", e)\n        return False\n</code></pre>"},{"location":"reference/api/#axium.core.api.show_toast","title":"<code>show_toast(title, body)</code>","text":"<p>Show a simple toast notification (info level).</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Notification title</p> required <code>body</code> <code>str</code> <p>Notification body</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p> Example <pre><code>&gt;&gt;&gt; api.show_toast(\"Success\", \"Operation completed\")\nTrue\n</code></pre> Source code in <code>axium/core/api.py</code> <pre><code>def show_toast(title: str, body: str) -&gt; bool:\n    \"\"\"\n    Show a simple toast notification (info level).\n\n    Args:\n        title: Notification title\n        body: Notification body\n\n    Returns:\n        True if successful, False otherwise\n\n    Example:\n        ```python\n        &gt;&gt;&gt; api.show_toast(\"Success\", \"Operation completed\")\n        True\n        ```\n    \"\"\"\n    return send_notification(\"system\", title, body, level=\"info\")\n</code></pre>"},{"location":"reference/api/#axium.core.api.drain_notifications","title":"<code>drain_notifications()</code>","text":"<p>Get and clear all queued notifications from daemon.</p> <p>This drains the notification queue - notifications are removed after reading.</p> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of notification dicts, each containing:</p> <code>list[dict[str, Any]]</code> <ul> <li>spoke: Source spoke name</li> </ul> <code>list[dict[str, Any]]</code> <ul> <li>title: Notification title</li> </ul> <code>list[dict[str, Any]]</code> <ul> <li>body: Notification body</li> </ul> <code>list[dict[str, Any]]</code> <ul> <li>level: Notification level (info/warning/error)</li> </ul> <code>list[dict[str, Any]]</code> <ul> <li>timestamp: ISO 8601 timestamp</li> </ul> Example <pre><code>&gt;&gt;&gt; notifications = api.drain_notifications()\n&gt;&gt;&gt; for notif in notifications:\n...     print(f\"{notif['level']}: {notif['title']}\")\n&gt;&gt;&gt; print(f\"Processed {len(notifications)} notifications\")\nwarning: Credentials expired\nProcessed 3 notifications\n</code></pre> Source code in <code>axium/core/api.py</code> <pre><code>def drain_notifications() -&gt; list[dict[str, Any]]:\n    \"\"\"\n    Get and clear all queued notifications from daemon.\n\n    This drains the notification queue - notifications are removed after reading.\n\n    Returns:\n        List of notification dicts, each containing:\n        - spoke: Source spoke name\n        - title: Notification title\n        - body: Notification body\n        - level: Notification level (info/warning/error)\n        - timestamp: ISO 8601 timestamp\n\n    Example:\n        ```python\n        &gt;&gt;&gt; notifications = api.drain_notifications()\n        &gt;&gt;&gt; for notif in notifications:\n        ...     print(f\"{notif['level']}: {notif['title']}\")\n        &gt;&gt;&gt; print(f\"Processed {len(notifications)} notifications\")\n        warning: Credentials expired\n        Processed 3 notifications\n        ```\n    \"\"\"\n    try:\n        from axium.core.ipc import send_request_sync\n\n        resp = send_request_sync({\"cmd\": \"notify_drain\"})\n        if resp.get(\"ok\"):\n            return resp.get(\"notifications\", [])\n        return []\n    except Exception as e:\n        logger.debug(\"Failed to drain notifications: %s\", e)\n        return []\n</code></pre>"},{"location":"reference/api/#axium.core.api.clear_notifications","title":"<code>clear_notifications()</code>","text":"<p>Clear all queued notifications without reading them.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p> Example <pre><code>&gt;&gt;&gt; api.clear_notifications()\nTrue\n</code></pre> Source code in <code>axium/core/api.py</code> <pre><code>def clear_notifications() -&gt; bool:\n    \"\"\"\n    Clear all queued notifications without reading them.\n\n    Returns:\n        True if successful, False otherwise\n\n    Example:\n        ```python\n        &gt;&gt;&gt; api.clear_notifications()\n        True\n        ```\n    \"\"\"\n    try:\n        # Drain and discard\n        drain_notifications()\n        return True\n    except Exception:\n        return False\n</code></pre>"},{"location":"reference/api/#axium.core.api.hud_get","title":"<code>hud_get(pane_id=None)</code>","text":"<p>Get HUD status line.</p> <p>Parameters:</p> Name Type Description Default <code>pane_id</code> <code>str | None</code> <p>Optional tmux pane ID for pane-specific HUD</p> <code>None</code> <p>Returns:</p> Type Description <code>str | None</code> <p>HUD status line string or None on error</p> Example <pre><code>&gt;&gt;&gt; hud = api.hud_get()\n&gt;&gt;&gt; print(hud)\n'[env:prod] [creds:Y] [aws:us-east-1]'\n</code></pre> Source code in <code>axium/core/api.py</code> <pre><code>def hud_get(pane_id: str | None = None) -&gt; str | None:\n    \"\"\"\n    Get HUD status line.\n\n    Args:\n        pane_id: Optional tmux pane ID for pane-specific HUD\n\n    Returns:\n        HUD status line string or None on error\n\n    Example:\n        ```python\n        &gt;&gt;&gt; hud = api.hud_get()\n        &gt;&gt;&gt; print(hud)\n        '[env:prod] [creds:Y] [aws:us-east-1]'\n        ```\n    \"\"\"\n    try:\n        from axium.core.ipc import send_request_sync\n\n        req = {\"cmd\": \"hud\"}\n        if pane_id:\n            req[\"pane\"] = pane_id\n\n        resp = send_request_sync(req)\n        if resp.get(\"ok\"):\n            return resp.get(\"hud\", \"\")\n        return None\n    except Exception as e:\n        logger.debug(\"Failed to get HUD: %s\", e)\n        return None\n</code></pre>"},{"location":"reference/api/#daemon-control","title":"Daemon Control","text":"<p>Axium Core API - High-level interface for spokes.</p> <p>This module provides a simplified, public API for spokes to interact with the Axium daemon, environment state, configuration, and other core services.</p> <p>Spokes should import from this module instead of using axium.core.ipc directly. All functions handle errors gracefully and return None on failure.</p> Example <pre><code>from axium.core import api\n\n# Get current environment\nenv = api.get_active_env()\n\n# Load spoke config\nconfig = api.load_config(\"myspoke\", \"myspoke.yaml\")\n\n# Update HUD\napi.update_hud_segment(\"myspoke\", \"[myspoke:OK]\")\n\n# Send notification\napi.send_notification(\"myspoke\", \"Alert\", \"Something happened\")\n\n# Execute command via daemon\napi.daemon_exec(\"myspoke\", \"some-command\")\n</code></pre>"},{"location":"reference/api/#axium.core.api.daemon_exec","title":"<code>daemon_exec(spoke, command, mode='background')</code>","text":"<p>Execute command via daemon.</p> <p>Parameters:</p> Name Type Description Default <code>spoke</code> <code>str</code> <p>Spoke name requesting execution</p> required <code>command</code> <code>str</code> <p>Shell command to execute</p> required <code>mode</code> <code>str</code> <p>Execution mode (background, foreground)</p> <code>'background'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if request accepted, False otherwise</p> Example <pre><code>&gt;&gt;&gt; api.daemon_exec(\"creds\", \"aws sso login\")\nTrue\n</code></pre> Source code in <code>axium/core/api.py</code> <pre><code>def daemon_exec(spoke: str, command: str, mode: str = \"background\") -&gt; bool:\n    \"\"\"\n    Execute command via daemon.\n\n    Args:\n        spoke: Spoke name requesting execution\n        command: Shell command to execute\n        mode: Execution mode (background, foreground)\n\n    Returns:\n        True if request accepted, False otherwise\n\n    Example:\n        ```python\n        &gt;&gt;&gt; api.daemon_exec(\"creds\", \"aws sso login\")\n        True\n        ```\n    \"\"\"\n    try:\n        from axium.core.ipc import send_request_sync\n\n        resp = send_request_sync(\n            {\"cmd\": \"daemon_exec\", \"spoke\": spoke, \"command\": command, \"mode\": mode}\n        )\n        return resp.get(\"ok\", False)\n    except Exception as e:\n        logger.debug(\"Failed to execute command via daemon: %s\", e)\n        return False\n</code></pre>"},{"location":"reference/api/#axium.core.api.daemon_status","title":"<code>daemon_status()</code>","text":"<p>Get daemon status information.</p> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>Status dictionary or None if unreachable</p> Example <pre><code>&gt;&gt;&gt; api.daemon_status()\n{'running': True, 'uptime': 3600, ...}\n</code></pre> Source code in <code>axium/core/api.py</code> <pre><code>def daemon_status() -&gt; dict[str, Any] | None:\n    \"\"\"\n    Get daemon status information.\n\n    Returns:\n        Status dictionary or None if unreachable\n\n    Example:\n        ```python\n        &gt;&gt;&gt; api.daemon_status()\n        {'running': True, 'uptime': 3600, ...}\n        ```\n    \"\"\"\n    try:\n        from axium.core.ipc import send_request_sync\n\n        resp = send_request_sync({\"cmd\": \"daemon_status\"})\n        if resp.get(\"ok\"):\n            return resp.get(\"status\")\n        return None\n    except Exception as e:\n        logger.debug(\"Failed to get daemon status: %s\", e)\n        return None\n</code></pre>"},{"location":"reference/api/#axium.core.api.daemon_logs","title":"<code>daemon_logs(tail=False, lines=100)</code>","text":"<p>Get daemon logs.</p> <p>Parameters:</p> Name Type Description Default <code>tail</code> <code>bool</code> <p>If True, follow logs (streaming)</p> <code>False</code> <code>lines</code> <code>int</code> <p>Number of lines to return</p> <code>100</code> <p>Returns:</p> Type Description <code>str | None</code> <p>Log content as string, or None if unreachable</p> Example <pre><code>&gt;&gt;&gt; api.daemon_logs(lines=50)\n'[2024-10-07 10:30:00] Daemon started\\n...'\n</code></pre> Source code in <code>axium/core/api.py</code> <pre><code>def daemon_logs(tail: bool = False, lines: int = 100) -&gt; str | None:\n    \"\"\"\n    Get daemon logs.\n\n    Args:\n        tail: If True, follow logs (streaming)\n        lines: Number of lines to return\n\n    Returns:\n        Log content as string, or None if unreachable\n\n    Example:\n        ```python\n        &gt;&gt;&gt; api.daemon_logs(lines=50)\n        '[2024-10-07 10:30:00] Daemon started\\\\n...'\n        ```\n    \"\"\"\n    try:\n        from axium.core.ipc import send_request_sync\n\n        resp = send_request_sync({\"cmd\": \"daemon_logs\", \"tail\": tail, \"lines\": lines})\n        if resp.get(\"ok\"):\n            return resp.get(\"logs\")\n        return None\n    except Exception as e:\n        logger.debug(\"Failed to get daemon logs: %s\", e)\n        return None\n</code></pre>"},{"location":"reference/api/#axium.core.api.daemon_start","title":"<code>daemon_start(debug=False)</code>","text":"<p>Start the Axium daemon.</p> <p>Parameters:</p> Name Type Description Default <code>debug</code> <code>bool</code> <p>If True, run daemon in debug mode</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p> Example <pre><code>&gt;&gt;&gt; api.daemon_start()\nTrue\n</code></pre> Source code in <code>axium/core/api.py</code> <pre><code>def daemon_start(debug: bool = False) -&gt; bool:\n    \"\"\"\n    Start the Axium daemon.\n\n    Args:\n        debug: If True, run daemon in debug mode\n\n    Returns:\n        True if successful, False otherwise\n\n    Example:\n        ```python\n        &gt;&gt;&gt; api.daemon_start()\n        True\n        ```\n    \"\"\"\n    try:\n        from axium.core import daemon as axiumd\n\n        return axiumd.start(debug=debug)\n    except Exception as e:\n        logger.debug(\"Failed to start daemon: %s\", e)\n        return False\n</code></pre>"},{"location":"reference/api/#axium.core.api.daemon_stop","title":"<code>daemon_stop(force=True)</code>","text":"<p>Stop the daemon gracefully (or forcefully if needed).</p> <p>Parameters:</p> Name Type Description Default <code>force</code> <code>bool</code> <p>If True and graceful stop fails, kill daemon process</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p> Example <pre><code>&gt;&gt;&gt; api.daemon_stop()\nTrue\n</code></pre> Source code in <code>axium/core/api.py</code> <pre><code>def daemon_stop(force: bool = True) -&gt; bool:\n    \"\"\"\n    Stop the daemon gracefully (or forcefully if needed).\n\n    Args:\n        force: If True and graceful stop fails, kill daemon process\n\n    Returns:\n        True if successful, False otherwise\n\n    Example:\n        ```python\n        &gt;&gt;&gt; api.daemon_stop()\n        True\n        ```\n    \"\"\"\n    try:\n        from axium.core.ipc import send_request_sync\n\n        resp = send_request_sync({\"cmd\": \"stop\"})\n        return resp.get(\"ok\", False)\n    except Exception as e:\n        logger.debug(\"Failed to stop daemon gracefully: %s\", e)\n        if force:\n            try:\n                from axium.core.daemon import kill_daemon_pid\n\n                kill_daemon_pid()\n                return True\n            except Exception as kill_err:\n                logger.debug(\"Failed to force-kill daemon: %s\", kill_err)\n        return False\n</code></pre>"},{"location":"reference/api/#tmux-integration-gears-only","title":"Tmux Integration (Gears Only)","text":"<p>Permission Required</p> <p>These functions require explicit permissions in your gear's <code>manifest.yaml</code>:</p> <pre><code>permissions:\n  ipc:\n    - tmux_split_run\n    - tmux_send_keys\n    - tmux_capture_pane\n</code></pre> <p>Axium Core API - High-level interface for spokes.</p> <p>This module provides a simplified, public API for spokes to interact with the Axium daemon, environment state, configuration, and other core services.</p> <p>Spokes should import from this module instead of using axium.core.ipc directly. All functions handle errors gracefully and return None on failure.</p> Example <pre><code>from axium.core import api\n\n# Get current environment\nenv = api.get_active_env()\n\n# Load spoke config\nconfig = api.load_config(\"myspoke\", \"myspoke.yaml\")\n\n# Update HUD\napi.update_hud_segment(\"myspoke\", \"[myspoke:OK]\")\n\n# Send notification\napi.send_notification(\"myspoke\", \"Alert\", \"Something happened\")\n\n# Execute command via daemon\napi.daemon_exec(\"myspoke\", \"some-command\")\n</code></pre>"},{"location":"reference/api/#axium.core.api.tmux_split_run","title":"<code>tmux_split_run(spoke, command, height=20)</code>","text":"<p>Create tmux split pane and run command.</p> <p>Requires 'tmux_split_run' in spoke/gear's ipc permissions.</p> <p>Parameters:</p> Name Type Description Default <code>spoke</code> <code>str</code> <p>Spoke/gear name (for permission check)</p> required <code>command</code> <code>str</code> <p>Shell command to execute in split</p> required <code>height</code> <code>int</code> <p>Split height as percentage (default 20%, range 1-99)</p> <code>20</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Response dict with:</p> <code>dict[str, Any]</code> <ul> <li>ok: True if successful, False if failed</li> </ul> <code>dict[str, Any]</code> <ul> <li>pane_id: Tmux pane ID (e.g., \"%42\") if successful</li> </ul> <code>dict[str, Any]</code> <ul> <li>error: Error message if failed</li> </ul> Example <pre><code>&gt;&gt;&gt; result = api.tmux_split_run(\"ansible\", \"ansible-playbook site.yml\", height=25)\n&gt;&gt;&gt; if result[\"ok\"]:\n...     print(f\"Running in pane: {result['pane_id']}\")\nRunning in pane: %42\n</code></pre> Permission <p>Requires spoke/gear to have 'tmux_split_run' in permissions.ipc list.</p> Note <p>Command runs with shell=True in the split pane. Returns immediately (does not wait for command completion).</p> Source code in <code>axium/core/api.py</code> <pre><code>def tmux_split_run(spoke: str, command: str, height: int = 20) -&gt; dict[str, Any]:\n    \"\"\"\n    Create tmux split pane and run command.\n\n    Requires 'tmux_split_run' in spoke/gear's ipc permissions.\n\n    Args:\n        spoke: Spoke/gear name (for permission check)\n        command: Shell command to execute in split\n        height: Split height as percentage (default 20%, range 1-99)\n\n    Returns:\n        Response dict with:\n        - ok: True if successful, False if failed\n        - pane_id: Tmux pane ID (e.g., \"%42\") if successful\n        - error: Error message if failed\n\n    Example:\n        ```python\n        &gt;&gt;&gt; result = api.tmux_split_run(\"ansible\", \"ansible-playbook site.yml\", height=25)\n        &gt;&gt;&gt; if result[\"ok\"]:\n        ...     print(f\"Running in pane: {result['pane_id']}\")\n        Running in pane: %42\n        ```\n\n    Permission:\n        Requires spoke/gear to have 'tmux_split_run' in permissions.ipc list.\n\n    Note:\n        Command runs with shell=True in the split pane.\n        Returns immediately (does not wait for command completion).\n    \"\"\"\n    try:\n        from axium.core.ipc import send_request_sync\n\n        resp = send_request_sync(\n            {\n                \"cmd\": \"tmux_split_run\",\n                \"spoke\": spoke,\n                \"command\": command,\n                \"height\": height,\n            }\n        )\n        return resp\n    except Exception as e:\n        logger.debug(\"tmux_split_run failed: %s\", e)\n        return {\"ok\": False, \"error\": str(e)}\n</code></pre>"},{"location":"reference/api/#axium.core.api.tmux_send_keys","title":"<code>tmux_send_keys(spoke, pane_id, keys)</code>","text":"<p>Send keys to specific tmux pane.</p> <p>Requires 'tmux_send_keys' in spoke/gear's ipc permissions.</p> <p>Parameters:</p> Name Type Description Default <code>spoke</code> <code>str</code> <p>Spoke/gear name (for permission check)</p> required <code>pane_id</code> <code>str</code> <p>Target pane ID (e.g., \"%42\")</p> required <code>keys</code> <code>str</code> <p>Keys to send to pane</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p> Example <pre><code>&gt;&gt;&gt; api.tmux_send_keys(\"ansible\", \"%42\", \"q\")  # Send 'q' to quit\nTrue\n</code></pre> Source code in <code>axium/core/api.py</code> <pre><code>def tmux_send_keys(spoke: str, pane_id: str, keys: str) -&gt; bool:\n    \"\"\"\n    Send keys to specific tmux pane.\n\n    Requires 'tmux_send_keys' in spoke/gear's ipc permissions.\n\n    Args:\n        spoke: Spoke/gear name (for permission check)\n        pane_id: Target pane ID (e.g., \"%42\")\n        keys: Keys to send to pane\n\n    Returns:\n        True if successful, False otherwise\n\n    Example:\n        ```python\n        &gt;&gt;&gt; api.tmux_send_keys(\"ansible\", \"%42\", \"q\")  # Send 'q' to quit\n        True\n        ```\n    \"\"\"\n    try:\n        from axium.core.ipc import send_request_sync\n\n        resp = send_request_sync(\n            {\"cmd\": \"tmux_send_keys\", \"spoke\": spoke, \"pane_id\": pane_id, \"keys\": keys}\n        )\n        return resp.get(\"ok\", False)\n    except Exception as e:\n        logger.debug(\"tmux_send_keys failed: %s\", e)\n        return False\n</code></pre>"},{"location":"reference/api/#axium.core.api.tmux_capture_pane","title":"<code>tmux_capture_pane(spoke, pane_id)</code>","text":"<p>Capture visible contents of tmux pane.</p> <p>Requires 'tmux_capture_pane' in spoke/gear's ipc permissions.</p> <p>Parameters:</p> Name Type Description Default <code>spoke</code> <code>str</code> <p>Spoke/gear name (for permission check)</p> required <code>pane_id</code> <code>str</code> <p>Target pane ID (e.g., \"%42\")</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>Pane contents as string, or None if failed</p> Example <pre><code>&gt;&gt;&gt; output = api.tmux_capture_pane(\"ansible\", \"%42\")\n&gt;&gt;&gt; if \"PLAY RECAP\" in output:\n...     print(\"Playbook completed!\")\n</code></pre> Source code in <code>axium/core/api.py</code> <pre><code>def tmux_capture_pane(spoke: str, pane_id: str) -&gt; str | None:\n    \"\"\"\n    Capture visible contents of tmux pane.\n\n    Requires 'tmux_capture_pane' in spoke/gear's ipc permissions.\n\n    Args:\n        spoke: Spoke/gear name (for permission check)\n        pane_id: Target pane ID (e.g., \"%42\")\n\n    Returns:\n        Pane contents as string, or None if failed\n\n    Example:\n        ```python\n        &gt;&gt;&gt; output = api.tmux_capture_pane(\"ansible\", \"%42\")\n        &gt;&gt;&gt; if \"PLAY RECAP\" in output:\n        ...     print(\"Playbook completed!\")\n        ```\n    \"\"\"\n    try:\n        from axium.core.ipc import send_request_sync\n\n        resp = send_request_sync(\n            {\"cmd\": \"tmux_capture_pane\", \"spoke\": spoke, \"pane_id\": pane_id}\n        )\n        return resp.get(\"content\") if resp.get(\"ok\") else None\n    except Exception as e:\n        logger.debug(\"tmux_capture_pane failed: %s\", e)\n        return None\n</code></pre>"},{"location":"reference/api/#file-operations-gears-only","title":"File Operations (Gears Only)","text":"<p>Permission Required</p> <p>These functions require explicit file path permissions in your gear's <code>manifest.yaml</code>:</p> <pre><code>permissions:\n  fs_read:\n    - ~/.my-tool/**\n    - /etc/my-tool/*.conf\n  fs_write:\n    - ~/.my-tool/cache/**\n    - ~/.my-tool/logs/**\n</code></pre> <p>Axium Core API - High-level interface for spokes.</p> <p>This module provides a simplified, public API for spokes to interact with the Axium daemon, environment state, configuration, and other core services.</p> <p>Spokes should import from this module instead of using axium.core.ipc directly. All functions handle errors gracefully and return None on failure.</p> Example <pre><code>from axium.core import api\n\n# Get current environment\nenv = api.get_active_env()\n\n# Load spoke config\nconfig = api.load_config(\"myspoke\", \"myspoke.yaml\")\n\n# Update HUD\napi.update_hud_segment(\"myspoke\", \"[myspoke:OK]\")\n\n# Send notification\napi.send_notification(\"myspoke\", \"Alert\", \"Something happened\")\n\n# Execute command via daemon\napi.daemon_exec(\"myspoke\", \"some-command\")\n</code></pre>"},{"location":"reference/api/#axium.core.api.read_file","title":"<code>read_file(spoke, path)</code>","text":"<p>Read file contents (permission checked).</p> <p>Daemon checks path against spoke/gear's fs_read glob patterns.</p> <p>Parameters:</p> Name Type Description Default <code>spoke</code> <code>str</code> <p>Spoke/gear name (for permission check)</p> required <code>path</code> <code>str</code> <p>File path to read</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>File contents as string, or None if denied/failed</p> Example <pre><code>&gt;&gt;&gt; content = api.read_file(\"ansible\", \"~/.ansible/config\")\n&gt;&gt;&gt; if content:\n...     print(f\"Config size: {len(content)} bytes\")\n</code></pre> Permission <p>Requires path to match a pattern in spoke/gear's fs_read list. Supports glob patterns (*, ?, []).</p> Note <p>Max file size: 10MB (larger files return error). Tilde (~) expansion performed automatically.</p> Source code in <code>axium/core/api.py</code> <pre><code>def read_file(spoke: str, path: str) -&gt; str | None:\n    \"\"\"\n    Read file contents (permission checked).\n\n    Daemon checks path against spoke/gear's fs_read glob patterns.\n\n    Args:\n        spoke: Spoke/gear name (for permission check)\n        path: File path to read\n\n    Returns:\n        File contents as string, or None if denied/failed\n\n    Example:\n        ```python\n        &gt;&gt;&gt; content = api.read_file(\"ansible\", \"~/.ansible/config\")\n        &gt;&gt;&gt; if content:\n        ...     print(f\"Config size: {len(content)} bytes\")\n        ```\n\n    Permission:\n        Requires path to match a pattern in spoke/gear's fs_read list.\n        Supports glob patterns (*, ?, []).\n\n    Note:\n        Max file size: 10MB (larger files return error).\n        Tilde (~) expansion performed automatically.\n    \"\"\"\n    try:\n        from axium.core.ipc import send_request_sync\n\n        resp = send_request_sync({\"cmd\": \"read_file\", \"spoke\": spoke, \"path\": path})\n        return resp.get(\"content\") if resp.get(\"ok\") else None\n    except Exception as e:\n        logger.debug(\"read_file failed: %s\", e)\n        return None\n</code></pre>"},{"location":"reference/api/#axium.core.api.write_file","title":"<code>write_file(spoke, path, content)</code>","text":"<p>Write file contents (permission checked).</p> <p>Daemon checks path against spoke/gear's fs_write glob patterns.</p> <p>Parameters:</p> Name Type Description Default <code>spoke</code> <code>str</code> <p>Spoke/gear name (for permission check)</p> required <code>path</code> <code>str</code> <p>File path to write</p> required <code>content</code> <code>str</code> <p>Content to write</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False if denied/failed</p> Example <pre><code>&gt;&gt;&gt; success = api.write_file(\"ansible\", \"~/ansible/logs/last_run.log\", log_data)\n&gt;&gt;&gt; if success:\n...     print(\"Log written successfully\")\n</code></pre> Permission <p>Requires path to match a pattern in spoke/gear's fs_write list. Supports glob patterns (*, ?, []).</p> Note <p>Parent directories created automatically if they don't exist. Existing files are overwritten. Tilde (~) expansion performed automatically.</p> Source code in <code>axium/core/api.py</code> <pre><code>def write_file(spoke: str, path: str, content: str) -&gt; bool:\n    \"\"\"\n    Write file contents (permission checked).\n\n    Daemon checks path against spoke/gear's fs_write glob patterns.\n\n    Args:\n        spoke: Spoke/gear name (for permission check)\n        path: File path to write\n        content: Content to write\n\n    Returns:\n        True if successful, False if denied/failed\n\n    Example:\n        ```python\n        &gt;&gt;&gt; success = api.write_file(\"ansible\", \"~/ansible/logs/last_run.log\", log_data)\n        &gt;&gt;&gt; if success:\n        ...     print(\"Log written successfully\")\n        ```\n\n    Permission:\n        Requires path to match a pattern in spoke/gear's fs_write list.\n        Supports glob patterns (*, ?, []).\n\n    Note:\n        Parent directories created automatically if they don't exist.\n        Existing files are overwritten.\n        Tilde (~) expansion performed automatically.\n    \"\"\"\n    try:\n        from axium.core.ipc import send_request_sync\n\n        resp = send_request_sync(\n            {\"cmd\": \"write_file\", \"spoke\": spoke, \"path\": path, \"content\": content}\n        )\n        return resp.get(\"ok\", False)\n    except Exception as e:\n        logger.debug(\"write_file failed: %s\", e)\n        return False\n</code></pre>"},{"location":"reference/api/#axium.core.api.write_log","title":"<code>write_log(name, message, level='info')</code>","text":"<p>Write to gear/spoke log file at ~/.config/axium/logs/.log. <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Gear/spoke name</p> required <code>message</code> <code>str</code> <p>Log message</p> required <code>level</code> <code>str</code> <p>Log level (debug, info, warning, error)</p> <code>'info'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p> Example <pre><code>&gt;&gt;&gt; api.write_log(\"ansible\", \"Starting playbook execution\")\nTrue\n&gt;&gt;&gt; api.write_log(\"ansible\", \"Playbook failed!\", level=\"error\")\nTrue\n</code></pre> Note <p>Log files automatically created in ~/.config/axium/logs/. Logs are timestamped and include level indicator.</p> Source code in <code>axium/core/api.py</code> <pre><code>def write_log(name: str, message: str, level: str = \"info\") -&gt; bool:\n    \"\"\"\n    Write to gear/spoke log file at ~/.config/axium/logs/&lt;name&gt;.log.\n\n    Args:\n        name: Gear/spoke name\n        message: Log message\n        level: Log level (debug, info, warning, error)\n\n    Returns:\n        True if successful, False otherwise\n\n    Example:\n        ```python\n        &gt;&gt;&gt; api.write_log(\"ansible\", \"Starting playbook execution\")\n        True\n        &gt;&gt;&gt; api.write_log(\"ansible\", \"Playbook failed!\", level=\"error\")\n        True\n        ```\n\n    Note:\n        Log files automatically created in ~/.config/axium/logs/.\n        Logs are timestamped and include level indicator.\n    \"\"\"\n    try:\n        from axium.core.ipc import send_request_sync\n\n        resp = send_request_sync(\n            {\"cmd\": \"write_log\", \"spoke\": name, \"message\": message, \"level\": level}\n        )\n        return resp.get(\"ok\", False)\n    except Exception as e:\n        logger.debug(\"write_log failed: %s\", e)\n        return False\n</code></pre>"},{"location":"reference/api/#prefix-system","title":"Prefix System","text":"<p>Axium Core API - High-level interface for spokes.</p> <p>This module provides a simplified, public API for spokes to interact with the Axium daemon, environment state, configuration, and other core services.</p> <p>Spokes should import from this module instead of using axium.core.ipc directly. All functions handle errors gracefully and return None on failure.</p> Example <pre><code>from axium.core import api\n\n# Get current environment\nenv = api.get_active_env()\n\n# Load spoke config\nconfig = api.load_config(\"myspoke\", \"myspoke.yaml\")\n\n# Update HUD\napi.update_hud_segment(\"myspoke\", \"[myspoke:OK]\")\n\n# Send notification\napi.send_notification(\"myspoke\", \"Alert\", \"Something happened\")\n\n# Execute command via daemon\napi.daemon_exec(\"myspoke\", \"some-command\")\n</code></pre>"},{"location":"reference/api/#axium.core.api.register_prefix","title":"<code>register_prefix(spoke, command, wrapper)</code>","text":"<p>Register command prefix rule programmatically.</p> <p>Allows gears/spokes to intercept shell commands and wrap them. Includes conflict detection - returns False if command already registered.</p> <p>Parameters:</p> Name Type Description Default <code>spoke</code> <code>str</code> <p>Spoke/gear name (owner of this rule)</p> required <code>command</code> <code>str</code> <p>Command to intercept (e.g., \"ansible-playbook\")</p> required <code>wrapper</code> <code>str</code> <p>Replacement command (e.g., \"axium ansible-run\")</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if registered, False if conflict detected</p> Example <pre><code>&gt;&gt;&gt; success = api.register_prefix(\"ansible\", \"ansible-playbook\", \"axium ansible-run\")\n&gt;&gt;&gt; if success:\n...     print(\"Prefix rule registered!\")\n... else:\n...     print(\"Conflict: command already registered\")\n</code></pre> Note <p>Conflict occurs when another spoke/gear already registered same command. Use this during gear's register() function. Rules are automatically unregistered when gear is unloaded.</p> Source code in <code>axium/core/api.py</code> <pre><code>def register_prefix(spoke: str, command: str, wrapper: str) -&gt; bool:\n    \"\"\"\n    Register command prefix rule programmatically.\n\n    Allows gears/spokes to intercept shell commands and wrap them.\n    Includes conflict detection - returns False if command already registered.\n\n    Args:\n        spoke: Spoke/gear name (owner of this rule)\n        command: Command to intercept (e.g., \"ansible-playbook\")\n        wrapper: Replacement command (e.g., \"axium ansible-run\")\n\n    Returns:\n        True if registered, False if conflict detected\n\n    Example:\n        ```python\n        &gt;&gt;&gt; success = api.register_prefix(\"ansible\", \"ansible-playbook\", \"axium ansible-run\")\n        &gt;&gt;&gt; if success:\n        ...     print(\"Prefix rule registered!\")\n        ... else:\n        ...     print(\"Conflict: command already registered\")\n        ```\n\n    Note:\n        Conflict occurs when another spoke/gear already registered same command.\n        Use this during gear's register() function.\n        Rules are automatically unregistered when gear is unloaded.\n    \"\"\"\n    try:\n        from axium.core.ipc import send_request_sync\n\n        resp = send_request_sync(\n            {\n                \"cmd\": \"register_prefix\",\n                \"spoke\": spoke,\n                \"command\": command,\n                \"wrapper\": wrapper,\n            }\n        )\n        return resp.get(\"ok\", False)\n    except Exception as e:\n        logger.debug(\"register_prefix failed: %s\", e)\n        return False\n</code></pre>"},{"location":"reference/api/#configuration","title":"Configuration","text":"<p>Axium Core API - High-level interface for spokes.</p> <p>This module provides a simplified, public API for spokes to interact with the Axium daemon, environment state, configuration, and other core services.</p> <p>Spokes should import from this module instead of using axium.core.ipc directly. All functions handle errors gracefully and return None on failure.</p> Example <pre><code>from axium.core import api\n\n# Get current environment\nenv = api.get_active_env()\n\n# Load spoke config\nconfig = api.load_config(\"myspoke\", \"myspoke.yaml\")\n\n# Update HUD\napi.update_hud_segment(\"myspoke\", \"[myspoke:OK]\")\n\n# Send notification\napi.send_notification(\"myspoke\", \"Alert\", \"Something happened\")\n\n# Execute command via daemon\napi.daemon_exec(\"myspoke\", \"some-command\")\n</code></pre>"},{"location":"reference/api/#axium.core.api.load_config","title":"<code>load_config(name, filename, env_aware=True, component_type='spoke')</code>","text":"<p>Load spoke or gear configuration.</p> <p>Wraps axium.core.config.load_spoke_config / load_gear_config with simplified interface.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Component name (spoke or gear)</p> required <code>filename</code> <code>str</code> <p>Config filename (e.g., \"myspoke.yaml\", \"ansible.yaml\")</p> required <code>env_aware</code> <code>bool</code> <p>Whether to apply environment-specific overrides</p> <code>True</code> <code>component_type</code> <code>str</code> <p>\"spoke\" or \"gear\" (default: \"spoke\")</p> <code>'spoke'</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Configuration dictionary (empty dict on error)</p> Example <pre><code>&gt;&gt;&gt; api.load_config(\"creds\", \"creds.yaml\")\n{'check': {'type': 'mtime', 'path': '~/.aws/credentials'}, ...}\n\n&gt;&gt;&gt; api.load_config(\"ansible\", \"ansible.yaml\", component_type=\"gear\")\n{'defaults': {'ansible_bin': 'ansible-playbook'}, 'profiles': {...}}\n</code></pre> Source code in <code>axium/core/api.py</code> <pre><code>def load_config(\n    name: str, filename: str, env_aware: bool = True, component_type: str = \"spoke\"\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Load spoke or gear configuration.\n\n    Wraps axium.core.config.load_spoke_config / load_gear_config with simplified interface.\n\n    Args:\n        name: Component name (spoke or gear)\n        filename: Config filename (e.g., \"myspoke.yaml\", \"ansible.yaml\")\n        env_aware: Whether to apply environment-specific overrides\n        component_type: \"spoke\" or \"gear\" (default: \"spoke\")\n\n    Returns:\n        Configuration dictionary (empty dict on error)\n\n    Example:\n        ```python\n        &gt;&gt;&gt; api.load_config(\"creds\", \"creds.yaml\")\n        {'check': {'type': 'mtime', 'path': '~/.aws/credentials'}, ...}\n\n        &gt;&gt;&gt; api.load_config(\"ansible\", \"ansible.yaml\", component_type=\"gear\")\n        {'defaults': {'ansible_bin': 'ansible-playbook'}, 'profiles': {...}}\n        ```\n    \"\"\"\n    try:\n        if component_type == \"gear\":\n            from axium.core.config import load_gear_config\n\n            return load_gear_config(name, filename, env_aware=env_aware)\n        else:\n            from axium.core.config import load_spoke_config\n\n            return load_spoke_config(name, filename, env_aware=env_aware)\n    except Exception as e:\n        logger.debug(\"Failed to load config for %s: %s\", name, e)\n        return {}\n</code></pre>"},{"location":"reference/api/#axium.core.api.get_permissions","title":"<code>get_permissions()</code>","text":"<p>Get current daemon permissions.</p> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>Permissions dictionary or None if unreachable</p> Example <pre><code>&gt;&gt;&gt; api.get_permissions()\n{'exec': ['creds'], 'network': [], ...}\n</code></pre> Source code in <code>axium/core/api.py</code> <pre><code>def get_permissions() -&gt; dict[str, Any] | None:\n    \"\"\"\n    Get current daemon permissions.\n\n    Returns:\n        Permissions dictionary or None if unreachable\n\n    Example:\n        ```python\n        &gt;&gt;&gt; api.get_permissions()\n        {'exec': ['creds'], 'network': [], ...}\n        ```\n    \"\"\"\n    try:\n        from axium.core.ipc import send_request_sync\n\n        resp = send_request_sync({\"cmd\": \"get_permissions\"})\n        if resp.get(\"ok\"):\n            return resp.get(\"permissions\")\n        return None\n    except Exception as e:\n        logger.debug(\"Failed to get permissions: %s\", e)\n        return None\n</code></pre>"},{"location":"reference/api/#axium.core.api.check_permission","title":"<code>check_permission(spoke, permission)</code>","text":"<p>Check if spoke has specific permission.</p> <p>Parameters:</p> Name Type Description Default <code>spoke</code> <code>str</code> <p>Spoke name</p> required <code>permission</code> <code>str</code> <p>Permission type (exec, network, etc.)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if permission granted, False otherwise</p> Example <pre><code>&gt;&gt;&gt; api.check_permission(\"creds\", \"exec\")\nTrue\n</code></pre> Source code in <code>axium/core/api.py</code> <pre><code>def check_permission(spoke: str, permission: str) -&gt; bool:\n    \"\"\"\n    Check if spoke has specific permission.\n\n    Args:\n        spoke: Spoke name\n        permission: Permission type (exec, network, etc.)\n\n    Returns:\n        True if permission granted, False otherwise\n\n    Example:\n        ```python\n        &gt;&gt;&gt; api.check_permission(\"creds\", \"exec\")\n        True\n        ```\n    \"\"\"\n    perms = get_permissions()\n    if not perms:\n        return False\n\n    perm_list = perms.get(permission, [])\n    return spoke in perm_list\n</code></pre>"},{"location":"reference/api/#axium.core.api.config_show","title":"<code>config_show()</code>","text":"<p>Get current configuration as YAML string.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>Configuration YAML or None on error</p> Example <pre><code>&gt;&gt;&gt; config = api.config_show()\n&gt;&gt;&gt; print(config)\n</code></pre> Source code in <code>axium/core/api.py</code> <pre><code>def config_show() -&gt; str | None:\n    \"\"\"\n    Get current configuration as YAML string.\n\n    Returns:\n        Configuration YAML or None on error\n\n    Example:\n        ```python\n        &gt;&gt;&gt; config = api.config_show()\n        &gt;&gt;&gt; print(config)\n        ```\n    \"\"\"\n    try:\n        from axium.core import config as config_module\n\n        return config_module.show_config()\n    except Exception as e:\n        logger.debug(\"Failed to show config: %s\", e)\n        return None\n</code></pre>"},{"location":"reference/api/#axium.core.api.config_edit","title":"<code>config_edit()</code>","text":"<p>Open configuration in editor.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if editor launched successfully, False otherwise</p> Example <pre><code>&gt;&gt;&gt; api.config_edit()\nTrue\n</code></pre> Source code in <code>axium/core/api.py</code> <pre><code>def config_edit() -&gt; bool:\n    \"\"\"\n    Open configuration in editor.\n\n    Returns:\n        True if editor launched successfully, False otherwise\n\n    Example:\n        ```python\n        &gt;&gt;&gt; api.config_edit()\n        True\n        ```\n    \"\"\"\n    try:\n        from axium.core import config as config_module\n\n        config_module.edit_config()\n        return True\n    except Exception as e:\n        logger.debug(\"Failed to edit config: %s\", e)\n        return False\n</code></pre>"},{"location":"reference/api/#spoke-management","title":"Spoke Management","text":"<p>Axium Core API - High-level interface for spokes.</p> <p>This module provides a simplified, public API for spokes to interact with the Axium daemon, environment state, configuration, and other core services.</p> <p>Spokes should import from this module instead of using axium.core.ipc directly. All functions handle errors gracefully and return None on failure.</p> Example <pre><code>from axium.core import api\n\n# Get current environment\nenv = api.get_active_env()\n\n# Load spoke config\nconfig = api.load_config(\"myspoke\", \"myspoke.yaml\")\n\n# Update HUD\napi.update_hud_segment(\"myspoke\", \"[myspoke:OK]\")\n\n# Send notification\napi.send_notification(\"myspoke\", \"Alert\", \"Something happened\")\n\n# Execute command via daemon\napi.daemon_exec(\"myspoke\", \"some-command\")\n</code></pre>"},{"location":"reference/api/#axium.core.api.list_spokes","title":"<code>list_spokes()</code>","text":"<p>List all installed spokes.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of spoke names (empty list on error)</p> Example <pre><code>&gt;&gt;&gt; api.list_spokes()\n['creds', 'aws', 'k8s']\n</code></pre> Source code in <code>axium/core/api.py</code> <pre><code>def list_spokes() -&gt; list[str]:\n    \"\"\"\n    List all installed spokes.\n\n    Returns:\n        List of spoke names (empty list on error)\n\n    Example:\n        ```python\n        &gt;&gt;&gt; api.list_spokes()\n        ['creds', 'aws', 'k8s']\n        ```\n    \"\"\"\n    try:\n        from axium.core.ipc import send_request_sync\n\n        resp = send_request_sync({\"cmd\": \"spoke_list\"})\n        if resp.get(\"ok\"):\n            return resp.get(\"spokes\", [])\n        return []\n    except Exception as e:\n        logger.debug(\"Failed to list spokes: %s\", e)\n        return []\n</code></pre>"},{"location":"reference/api/#axium.core.api.install_spoke","title":"<code>install_spoke(name)</code>","text":"<p>Install a spoke.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Spoke name</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p> Example <pre><code>&gt;&gt;&gt; api.install_spoke(\"aws\")\nTrue\n</code></pre> Note <p>Stub for future implementation</p> Source code in <code>axium/core/api.py</code> <pre><code>def install_spoke(name: str) -&gt; bool:\n    \"\"\"\n    Install a spoke.\n\n    Args:\n        name: Spoke name\n\n    Returns:\n        True if successful, False otherwise\n\n    Example:\n        ```python\n        &gt;&gt;&gt; api.install_spoke(\"aws\")\n        True\n        ```\n\n    Note:\n        Stub for future implementation\n    \"\"\"\n    try:\n        from axium.core.ipc import send_request_sync\n\n        resp = send_request_sync({\"cmd\": \"spoke_install\", \"spoke\": name})\n        return resp.get(\"ok\", False)\n    except Exception as e:\n        logger.debug(\"Failed to install spoke: %s\", e)\n        return False\n</code></pre>"},{"location":"reference/api/#axium.core.api.validate_spoke","title":"<code>validate_spoke(name)</code>","text":"<p>Validate spoke schema and structure.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Spoke name</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if valid, False otherwise</p> Example <pre><code>&gt;&gt;&gt; api.validate_spoke(\"creds\")\nTrue\n</code></pre> Note <p>Stub for future implementation</p> Source code in <code>axium/core/api.py</code> <pre><code>def validate_spoke(name: str) -&gt; bool:\n    \"\"\"\n    Validate spoke schema and structure.\n\n    Args:\n        name: Spoke name\n\n    Returns:\n        True if valid, False otherwise\n\n    Example:\n        ```python\n        &gt;&gt;&gt; api.validate_spoke(\"creds\")\n        True\n        ```\n\n    Note:\n        Stub for future implementation\n    \"\"\"\n    # TODO: Implement local validation logic\n    logger.debug(\"validate_spoke not yet implemented\")\n    return False\n</code></pre>"},{"location":"reference/api/#axium.core.api.list_commands","title":"<code>list_commands(sort_by='grouped')</code>","text":"<p>List all registered commands with full metadata.</p> <p>Returns all commands from the command registry, including core commands and spoke-registered commands. Each command includes name, summary, description, category, source, and group information.</p> <p>Parameters:</p> Name Type Description Default <code>sort_by</code> <code>str</code> <p>Sort method - \"alpha\" (alphabetical), \"grouped\" (source grouped),     or \"usage\" (future: by usage frequency). Default: \"grouped\"</p> <code>'grouped'</code> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of command dictionaries with complete metadata, or empty list on error</p> Example <pre><code>&gt;&gt;&gt; commands = api.list_commands()\n&gt;&gt;&gt; for cmd in commands:\n...     print(f\"{cmd['name']}: {cmd['summary']}\")\ndaemon start: Start the Axium daemon\nenv set: Set the active environment\ncreds-status: Check credential status\n</code></pre> Note <ul> <li>Used by palette for command discovery</li> <li>Sorted by category by default (core first, then spokes)</li> <li>Safe to call even if registry is empty (returns [])</li> </ul> Source code in <code>axium/core/api.py</code> <pre><code>def list_commands(sort_by: str = \"grouped\") -&gt; list[dict[str, Any]]:\n    \"\"\"\n    List all registered commands with full metadata.\n\n    Returns all commands from the command registry, including core commands\n    and spoke-registered commands. Each command includes name, summary,\n    description, category, source, and group information.\n\n    Args:\n        sort_by: Sort method - \"alpha\" (alphabetical), \"grouped\" (source grouped),\n                or \"usage\" (future: by usage frequency). Default: \"grouped\"\n\n    Returns:\n        List of command dictionaries with complete metadata, or empty list on error\n\n    Example:\n        ```python\n        &gt;&gt;&gt; commands = api.list_commands()\n        &gt;&gt;&gt; for cmd in commands:\n        ...     print(f\"{cmd['name']}: {cmd['summary']}\")\n        daemon start: Start the Axium daemon\n        env set: Set the active environment\n        creds-status: Check credential status\n        ```\n\n    Note:\n        - Used by palette for command discovery\n        - Sorted by category by default (core first, then spokes)\n        - Safe to call even if registry is empty (returns [])\n    \"\"\"\n    try:\n        from axium.core import registry\n\n        return registry.get_all_commands(sort_by=sort_by)\n    except Exception as e:\n        logger.debug(\"Failed to list commands: %s\", e)\n        return []\n</code></pre>"},{"location":"reference/api/#axium.core.api.spoke_new","title":"<code>spoke_new(name, prefix=None, check_type=None, check_command=None)</code>","text":"<p>Create new spoke from template.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Spoke name</p> required <code>prefix</code> <code>str | None</code> <p>Command prefix (optional)</p> <code>None</code> <code>check_type</code> <code>str | None</code> <p>Check type (command, mtime, etc.)</p> <code>None</code> <code>check_command</code> <code>str | None</code> <p>Check command if check_type is 'command'</p> <code>None</code> <p>Returns:</p> Type Description <code>str | None</code> <p>Path to created spoke directory, or None on error</p> Example <pre><code>&gt;&gt;&gt; spoke_path = api.spoke_new(\"myspoke\", prefix=\"myapp\")\n&gt;&gt;&gt; print(spoke_path)\n'/home/user/.config/axium/spokes/myspoke'\n</code></pre> Source code in <code>axium/core/api.py</code> <pre><code>def spoke_new(\n    name: str,\n    prefix: str | None = None,\n    check_type: str | None = None,\n    check_command: str | None = None,\n) -&gt; str | None:\n    \"\"\"\n    Create new spoke from template.\n\n    Args:\n        name: Spoke name\n        prefix: Command prefix (optional)\n        check_type: Check type (command, mtime, etc.)\n        check_command: Check command if check_type is 'command'\n\n    Returns:\n        Path to created spoke directory, or None on error\n\n    Example:\n        ```python\n        &gt;&gt;&gt; spoke_path = api.spoke_new(\"myspoke\", prefix=\"myapp\")\n        &gt;&gt;&gt; print(spoke_path)\n        '/home/user/.config/axium/spokes/myspoke'\n        ```\n    \"\"\"\n    try:\n        from axium.core import spokes as spokes_module\n\n        return spokes_module.create_spoke(\n            name=name,\n            prefix=prefix,\n            check_type=check_type,\n            check_command=check_command,\n        )\n    except Exception as e:\n        logger.debug(\"Failed to create spoke: %s\", e)\n        return None\n</code></pre>"},{"location":"reference/api/#axium.core.api.spoke_install_from_path","title":"<code>spoke_install_from_path(path)</code>","text":"<p>Install spoke from local path or git URL.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Local directory path or git URL</p> required <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>Spoke metadata dict or None on error</p> Example <pre><code>&gt;&gt;&gt; metadata = api.spoke_install_from_path(\"./my-spoke\")\n&gt;&gt;&gt; print(metadata['name'])\n'my-spoke'\n</code></pre> Source code in <code>axium/core/api.py</code> <pre><code>def spoke_install_from_path(path: str) -&gt; dict[str, Any] | None:\n    \"\"\"\n    Install spoke from local path or git URL.\n\n    Args:\n        path: Local directory path or git URL\n\n    Returns:\n        Spoke metadata dict or None on error\n\n    Example:\n        ```python\n        &gt;&gt;&gt; metadata = api.spoke_install_from_path(\"./my-spoke\")\n        &gt;&gt;&gt; print(metadata['name'])\n        'my-spoke'\n        ```\n    \"\"\"\n    try:\n        from axium.core import spokes as spokes_module\n\n        return spokes_module.install_spoke(path)\n    except Exception as e:\n        logger.debug(\"Failed to install spoke: %s\", e)\n        return None\n</code></pre>"},{"location":"reference/api/#axium.core.api.spoke_reload_all","title":"<code>spoke_reload_all()</code>","text":"<p>Reload all spokes from disk.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of reloaded spoke names (empty list on error)</p> Example <pre><code>&gt;&gt;&gt; reloaded = api.spoke_reload_all()\n&gt;&gt;&gt; print(f\"Reloaded {len(reloaded)} spokes\")\n</code></pre> Source code in <code>axium/core/api.py</code> <pre><code>def spoke_reload_all() -&gt; list[str]:\n    \"\"\"\n    Reload all spokes from disk.\n\n    Returns:\n        List of reloaded spoke names (empty list on error)\n\n    Example:\n        ```python\n        &gt;&gt;&gt; reloaded = api.spoke_reload_all()\n        &gt;&gt;&gt; print(f\"Reloaded {len(reloaded)} spokes\")\n        ```\n    \"\"\"\n    try:\n        from axium.core.ipc import send_request_sync\n\n        resp = send_request_sync({\"cmd\": \"reload_spokes\"})\n        if resp.get(\"ok\"):\n            return resp.get(\"spokes\", [])\n        return []\n    except Exception as e:\n        logger.debug(\"Failed to reload spokes: %s\", e)\n        return []\n</code></pre>"},{"location":"reference/api/#axium.core.api.spoke_reload_one","title":"<code>spoke_reload_one(name)</code>","text":"<p>Reload specific spoke from disk.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Spoke name</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p> Example <pre><code>&gt;&gt;&gt; api.spoke_reload_one(\"creds\")\nTrue\n</code></pre> Source code in <code>axium/core/api.py</code> <pre><code>def spoke_reload_one(name: str) -&gt; bool:\n    \"\"\"\n    Reload specific spoke from disk.\n\n    Args:\n        name: Spoke name\n\n    Returns:\n        True if successful, False otherwise\n\n    Example:\n        ```python\n        &gt;&gt;&gt; api.spoke_reload_one(\"creds\")\n        True\n        ```\n    \"\"\"\n    try:\n        from axium.core.ipc import send_request_sync\n\n        resp = send_request_sync({\"cmd\": \"reload_spoke\", \"spoke\": name})\n        return resp.get(\"ok\", False)\n    except Exception as e:\n        logger.debug(\"Failed to reload spoke: %s\", e)\n        return False\n</code></pre>"},{"location":"reference/api/#command-execution","title":"Command Execution","text":"<p>Axium Core API - High-level interface for spokes.</p> <p>This module provides a simplified, public API for spokes to interact with the Axium daemon, environment state, configuration, and other core services.</p> <p>Spokes should import from this module instead of using axium.core.ipc directly. All functions handle errors gracefully and return None on failure.</p> Example <pre><code>from axium.core import api\n\n# Get current environment\nenv = api.get_active_env()\n\n# Load spoke config\nconfig = api.load_config(\"myspoke\", \"myspoke.yaml\")\n\n# Update HUD\napi.update_hud_segment(\"myspoke\", \"[myspoke:OK]\")\n\n# Send notification\napi.send_notification(\"myspoke\", \"Alert\", \"Something happened\")\n\n# Execute command via daemon\napi.daemon_exec(\"myspoke\", \"some-command\")\n</code></pre>"},{"location":"reference/api/#axium.core.api.run_command","title":"<code>run_command(command, args)</code>","text":"<p>Execute prefixed command via Axium run system.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>Command name (e.g., \"aws\", \"terraform\")</p> required <code>args</code> <code>list[str]</code> <p>Command arguments</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if command executed successfully, False otherwise</p> Example <pre><code>&gt;&gt;&gt; api.run_command(\"aws\", [\"s3\", \"ls\"])\nTrue\n</code></pre> Source code in <code>axium/core/api.py</code> <pre><code>def run_command(command: str, args: list[str]) -&gt; bool:\n    \"\"\"\n    Execute prefixed command via Axium run system.\n\n    Args:\n        command: Command name (e.g., \"aws\", \"terraform\")\n        args: Command arguments\n\n    Returns:\n        True if command executed successfully, False otherwise\n\n    Example:\n        ```python\n        &gt;&gt;&gt; api.run_command(\"aws\", [\"s3\", \"ls\"])\n        True\n        ```\n    \"\"\"\n    try:\n        from axium.core import run as run_module\n\n        return run_module.execute_command(command, args)\n    except Exception as e:\n        logger.debug(\"Failed to run command: %s\", e)\n        return False\n</code></pre>"},{"location":"reference/api/#axium.core.api.notify_send_cli","title":"<code>notify_send_cli(spoke, title, body, level='info')</code>","text":"<p>Send notification via CLI (not from spoke).</p> <p>Parameters:</p> Name Type Description Default <code>spoke</code> <code>str</code> <p>Spoke name (for categorization)</p> required <code>title</code> <code>str</code> <p>Notification title</p> required <code>body</code> <code>str</code> <p>Notification body</p> required <code>level</code> <code>str</code> <p>Notification level (info, warning, error)</p> <code>'info'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p> Example <pre><code>&gt;&gt;&gt; api.notify_send_cli(\"system\", \"Test\", \"Hello\", level=\"info\")\nTrue\n</code></pre> Source code in <code>axium/core/api.py</code> <pre><code>def notify_send_cli(spoke: str, title: str, body: str, level: str = \"info\") -&gt; bool:\n    \"\"\"\n    Send notification via CLI (not from spoke).\n\n    Args:\n        spoke: Spoke name (for categorization)\n        title: Notification title\n        body: Notification body\n        level: Notification level (info, warning, error)\n\n    Returns:\n        True if successful, False otherwise\n\n    Example:\n        ```python\n        &gt;&gt;&gt; api.notify_send_cli(\"system\", \"Test\", \"Hello\", level=\"info\")\n        True\n        ```\n    \"\"\"\n    return send_notification(spoke, title, body, level)\n</code></pre>"},{"location":"reference/api/#axium.core.api.notify_drain","title":"<code>notify_drain()</code>","text":"<p>Drain all pending notifications.</p> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of notification dictionaries (empty list on error)</p> Example <pre><code>&gt;&gt;&gt; notifications = api.notify_drain()\n&gt;&gt;&gt; for notif in notifications:\n...     print(f\"{notif['title']}: {notif['body']}\")\n</code></pre> Source code in <code>axium/core/api.py</code> <pre><code>def notify_drain() -&gt; list[dict[str, Any]]:\n    \"\"\"\n    Drain all pending notifications.\n\n    Returns:\n        List of notification dictionaries (empty list on error)\n\n    Example:\n        ```python\n        &gt;&gt;&gt; notifications = api.notify_drain()\n        &gt;&gt;&gt; for notif in notifications:\n        ...     print(f\"{notif['title']}: {notif['body']}\")\n        ```\n    \"\"\"\n    try:\n        from axium.core.ipc import send_request_sync\n\n        resp = send_request_sync({\"cmd\": \"notify_drain\"})\n        if resp.get(\"ok\"):\n            return resp.get(\"notifications\", [])\n        return []\n    except Exception as e:\n        logger.debug(\"Failed to drain notifications: %s\", e)\n        return []\n</code></pre>"},{"location":"reference/api/#usage-examples","title":"Usage Examples","text":""},{"location":"reference/api/#environment-aware-configuration","title":"Environment-Aware Configuration","text":"<pre><code>from axium.core import api\n\ndef register(app, events):\n    \"\"\"Spoke registration with environment-aware config.\"\"\"\n\n    @app.command(\"mycommand\")\n    def my_command():\n        # Get current environment\n        env = api.get_active_env()\n\n        # Load config with env-specific overrides\n        config = api.load_config(\"myspoke\", \"config.yaml\", env_aware=True)\n\n        # Access environment-specific settings\n        endpoint = config.get(\"endpoint\")\n        timeout = config.get(\"timeout\", 30)\n\n        print(f\"Running in {env} with endpoint: {endpoint}\")\n</code></pre>"},{"location":"reference/api/#notification-patterns","title":"Notification Patterns","text":"<pre><code>from axium.core import api\n\n# Simple info notification\napi.show_toast(\"Success\", \"Operation completed\")\n\n# Categorized notification with level\napi.send_notification(\n    spoke=\"creds\",\n    title=\"Credentials Expired\",\n    body=\"Run 'axium creds-refresh' to renew\",\n    level=\"warning\"\n)\n\n# Error notification\napi.send_notification(\n    spoke=\"deploy\",\n    title=\"Deployment Failed\",\n    body=f\"Error: {error_message}\",\n    level=\"error\"\n)\n</code></pre>"},{"location":"reference/api/#gear-with-permissions","title":"Gear with Permissions","text":"<pre><code># manifest.yaml\npermissions:\n  exec: true\n  notify: true\n  ipc:\n    - tmux_split_run\n  fs_write:\n    - ~/.my-gear/logs/**\n\n# main.py\nfrom axium.core import api\n\ndef register(app, events):\n    @app.command(\"my-gear-run\")\n    def run_command():\n        # Execute command (requires exec permission)\n        api.daemon_exec(\"my-gear\", \"long-running-task\")\n\n        # Create split pane (requires tmux_split_run permission)\n        result = api.tmux_split_run(\n            spoke=\"my-gear\",\n            command=\"tail -f /var/log/app.log\",\n            height=25\n        )\n\n        if result[\"ok\"]:\n            pane_id = result[\"pane_id\"]\n\n            # Write log (requires fs_write permission)\n            api.write_log(\n                \"my-gear\",\n                f\"Created monitoring pane: {pane_id}\",\n                level=\"info\"\n            )\n\n            # Notify user (requires notify permission)\n            api.send_notification(\n                \"my-gear\",\n                \"Monitoring Started\",\n                f\"Logs visible in pane {pane_id}\"\n            )\n</code></pre>"},{"location":"reference/api/#event-handlers-with-state-updates","title":"Event Handlers with State Updates","text":"<pre><code>from axium.core import api\n\ndef register(app, events):\n    def on_env_change(new_env: str, old_env: str, **kwargs):\n        \"\"\"React to environment changes.\"\"\"\n\n        # Load new environment config\n        config = api.load_config(\"myspoke\", \"config.yaml\", env_aware=True)\n\n        # Validate credentials for new environment\n        is_valid = check_credentials(new_env, config)\n\n        if not is_valid:\n            api.send_notification(\n                \"myspoke\",\n                \"Credentials Required\",\n                f\"Please authenticate for {new_env}\",\n                level=\"warning\"\n            )\n\n    events.on(\"env_change\", on_env_change)\n</code></pre>"},{"location":"reference/api/#error-handling","title":"Error Handling","text":"<p>All API functions handle errors gracefully and return sensible defaults:</p> <pre><code># Returns None on failure (never raises)\nenv = api.get_active_env()\nif env is None:\n    print(\"Daemon not reachable or env not set\")\n\n# Returns False on failure\nsuccess = api.set_active_env(\"prod\")\nif not success:\n    print(\"Failed to set environment\")\n\n# Returns empty dict/list on failure\nconfig = api.load_config(\"myspoke\", \"config.yaml\")  # {} on error\nenvs = api.list_environments()  # [] on error\n</code></pre> <p>Check logs for detailed error information:</p> <pre><code>tail -f ~/.config/axium/daemon.log\n</code></pre>"},{"location":"reference/api/#see-also","title":"See Also","text":"<ul> <li>IPC Commands Reference - Low-level IPC protocol</li> <li>Events Reference - Event system documentation</li> <li>Gears Guide - Gear permissions and development</li> <li>Spokes Guide - Spoke development guide</li> </ul>"},{"location":"reference/events/","title":"Event System Reference","text":"<p>Axium provides a synchronous event bus for coordinating between core functionality and Spokes/Gears. Events are emitted at key lifecycle points, allowing extensions to react to state changes.</p>"},{"location":"reference/events/#event-bus-architecture","title":"Event Bus Architecture","text":"<p>The EventBus uses a publish-subscribe pattern where:</p> <ul> <li>Publishers: Axium core (daemon, CLI) emits events at specific lifecycle points</li> <li>Subscribers: Spokes and Gears register callbacks to react to events</li> <li>Synchronous: All callbacks execute in registration order before emit() returns</li> <li>Error Handling: Exceptions in callbacks are logged but don't stop propagation</li> </ul>"},{"location":"reference/events/#standard-events","title":"Standard Events","text":""},{"location":"reference/events/#environment-events","title":"Environment Events","text":""},{"location":"reference/events/#env_change","title":"<code>env_change</code>","text":"<p>Emitted when the active environment changes.</p> <p>Signature: <pre><code>def on_env_change(new_env: str, old_env: str, pane: str | None = None):\n    pass\n</code></pre></p> <p>Parameters: - <code>new_env</code>: Name of newly activated environment (or <code>None</code> if clearing) - <code>old_env</code>: Name of previously active environment (or <code>None</code> if none was set) - <code>pane</code>: (keyword) Optional tmux pane ID if change is pane-specific</p> <p>Emitted By: - <code>axium env set &lt;name&gt;</code> - Global environment change - <code>axium env set &lt;name&gt; --pane &lt;id&gt;</code> - Pane-specific environment change - IPC <code>set_env</code> command - IPC <code>set_pane_env</code> command</p> <p>When: - After environment state is updated in daemon - Before HUD cache is refreshed</p> <p>Common Uses: - Refresh credentials when switching environments - Update HUD segments with environment-specific data - Clear caches tied to previous environment - Notify user of environment-specific warnings</p> <p>Example: <pre><code>def register(app, events):\n    def on_env_change(new_env: str, old_env: str, **kwargs):\n        pane = kwargs.get(\"pane\")\n        if pane:\n            print(f\"Pane {pane}: {old_env} \u2192 {new_env}\")\n        else:\n            print(f\"Global: {old_env} \u2192 {new_env}\")\n\n        # Check credentials for new environment\n        check_credentials(new_env)\n\n    events.on(\"env_change\", on_env_change)\n</code></pre></p>"},{"location":"reference/events/#spoke-lifecycle-events","title":"Spoke Lifecycle Events","text":""},{"location":"reference/events/#spoke_loaded","title":"<code>spoke_loaded</code>","text":"<p>Emitted when a Spoke finishes initial loading.</p> <p>Signature: <pre><code>def on_spoke_loaded(spoke_name: str):\n    pass\n</code></pre></p> <p>Parameters: - <code>spoke_name</code>: Name of the Spoke that loaded</p> <p>Emitted By: - Daemon during startup when loading all Spokes - <code>axium spoke install &lt;name&gt;</code> after successful installation</p> <p>When: - After Spoke's <code>register()</code> function has been called - After Spoke is marked as \"active\" in metadata</p> <p>Common Uses: - Initialize spoke state (e.g., check credentials on first load) - Set initial HUD segments - One-time setup that shouldn't run on reload</p> <p>Example: <pre><code>from axium.core.hud import get_registry\n\ndef register(app, events):\n    def on_spoke_loaded(spoke_name: str):\n        if spoke_name == \"creds\":\n            # Perform initial credential check and update cached HUD\n            from axium.core import api\n            registry = get_registry()\n            env_name = api.get_active_env()\n            context = {\"env\": env_name}\n            registry.update_cached_segments(context)\n\n    events.on(\"spoke_loaded\", on_spoke_loaded)\n</code></pre></p>"},{"location":"reference/events/#spoke_reloaded","title":"<code>spoke_reloaded</code>","text":"<p>Emitted when a Spoke is reloaded.</p> <p>Signature: <pre><code>def on_spoke_reloaded(spoke_name: str):\n    pass\n</code></pre></p> <p>Parameters: - <code>spoke_name</code>: Name of the Spoke that reloaded</p> <p>Emitted By: - <code>axium daemon reload</code> after reloading all Spokes - <code>axium spoke reload &lt;name&gt;</code> after reloading specific Spoke</p> <p>When: - After Spoke's <code>register()</code> function has been re-called - After Spoke metadata is updated</p> <p>Common Uses: - Re-initialize state that was lost during reload - Refresh configuration from files - Clear stale caches</p> <p>Example: <pre><code>def register(app, events):\n    def on_spoke_reloaded(spoke_name: str):\n        if spoke_name == \"aws\":\n            # Reload AWS configuration\n            reload_aws_config()\n\n    events.on(\"spoke_reloaded\", on_spoke_reloaded)\n</code></pre></p>"},{"location":"reference/events/#spoke_unloaded","title":"<code>spoke_unloaded</code>","text":"<p>Emitted when a Spoke is unloaded.</p> <p>Signature: <pre><code>def on_spoke_unloaded(spoke_name: str):\n    pass\n</code></pre></p> <p>Parameters: - <code>spoke_name</code>: Name of the Spoke that unloaded</p> <p>Emitted By: - <code>axium spoke uninstall &lt;name&gt;</code> after removing Spoke - Daemon shutdown (for all loaded Spokes)</p> <p>When: - After Spoke has been removed from active registry - Before Spoke files are deleted (on uninstall)</p> <p>Common Uses: - Cleanup resources - Save state to disk - Remove HUD segments</p> <p>Example: <pre><code>def register(app, events):\n    def on_spoke_unloaded(spoke_name: str):\n        if spoke_name == \"creds\":\n            # Clear HUD segment\n            api.update_hud_segment(\"creds\", \"\")\n\n    events.on(\"spoke_unloaded\", on_spoke_unloaded)\n</code></pre></p>"},{"location":"reference/events/#gear-lifecycle-events","title":"Gear Lifecycle Events","text":""},{"location":"reference/events/#gear_loaded","title":"<code>gear_loaded</code>","text":"<p>Emitted when a Gear finishes loading.</p> <p>Signature: <pre><code>def on_gear_loaded(gear_name: str):\n    pass\n</code></pre></p> <p>Parameters: - <code>gear_name</code>: Name of the Gear that loaded</p> <p>Emitted By: - Daemon during startup when loading all Gears - <code>axium gear install &lt;name&gt;</code> after successful installation</p> <p>When: - After Gear's register function has been called - After Gear is marked as \"active\" in metadata</p> <p>Common Uses: - Initialize gear-specific state - Register gear-provided commands in tmux - Verify gear permissions</p>"},{"location":"reference/events/#gear_unloaded","title":"<code>gear_unloaded</code>","text":"<p>Emitted when a Gear is unloaded.</p> <p>Signature: <pre><code>def on_gear_unloaded(gear_name: str):\n    pass\n</code></pre></p> <p>Parameters: - <code>gear_name</code>: Name of the Gear that unloaded</p> <p>Emitted By: - <code>axium gear uninstall &lt;name&gt;</code> after removing Gear - Daemon shutdown</p> <p>When: - After Gear has been removed from active registry</p> <p>Common Uses: - Cleanup gear resources - Remove tmux key bindings</p>"},{"location":"reference/events/#daemon-events","title":"Daemon Events","text":""},{"location":"reference/events/#daemon_reload","title":"<code>daemon_reload</code>","text":"<p>Emitted when daemon configuration is reloaded.</p> <p>Signature: <pre><code>def on_daemon_reload():\n    pass\n</code></pre></p> <p>Parameters: None</p> <p>Emitted By: - <code>axium daemon reload</code> command - IPC <code>reload</code> command</p> <p>When: - After all Spokes have been reloaded - After configuration files (envs.yaml, prefixes.yaml, etc.) are re-read - After HUD cache is cleared</p> <p>Common Uses: - Refresh spoke-specific configuration - Clear caches that depend on config files - Re-validate setup</p> <p>Example: <pre><code>def register(app, events):\n    def on_daemon_reload():\n        # Reload our configuration\n        global config\n        config = load_config()\n\n    events.on(\"daemon_reload\", on_daemon_reload)\n</code></pre></p>"},{"location":"reference/events/#config_reloaded","title":"<code>config_reloaded</code>","text":"<p>Emitted when all spoke configurations are cleared and reloaded.</p> <p>Signature: <pre><code>def on_config_reloaded():\n    pass\n</code></pre></p> <p>Parameters: None</p> <p>Emitted By: - <code>axium daemon reload</code> command - Configuration file changes (if file watching is enabled)</p> <p>When: - After all cached spoke configs are cleared - After config files are re-read from disk</p> <p>Common Uses: - Reload spoke-specific configuration from <code>~/.config/axium/overrides/</code> - Validate new configuration values - Update state based on config changes</p>"},{"location":"reference/events/#hud-events","title":"HUD Events","text":""},{"location":"reference/events/#hud_segment_updated","title":"<code>hud_segment_updated</code>","text":"<p>Emitted when a HUD segment value changes.</p> <p>Signature: <pre><code>def on_hud_segment_updated(spoke: str, value: str):\n    pass\n</code></pre></p> <p>Parameters: - <code>spoke</code>: Name of the spoke that updated its segment - <code>value</code>: New segment value (empty string if cleared)</p> <p>Emitted By: - <code>api.update_hud_segment()</code> calls from Spokes - IPC <code>update_hud_segment</code> command</p> <p>When: - After segment value is stored in daemon - After HUD cache is refreshed for all panes</p> <p>Common Uses: - Track when other spokes update their HUD - Coordinate related HUD segments - Debug HUD rendering issues</p> <p>Example: <pre><code>def register(app, events):\n    def on_hud_updated(spoke: str, value: str):\n        logger.debug(f\"HUD segment updated: {spoke} = {value}\")\n\n    events.on(\"hud_segment_updated\", on_hud_updated)\n</code></pre></p>"},{"location":"reference/events/#hud_refresh","title":"<code>hud_refresh</code>","text":"<p>Emitted when HUD should be regenerated.</p> <p>Signature: <pre><code>def on_hud_refresh():\n    pass\n</code></pre></p> <p>Parameters: None</p> <p>Emitted By: - <code>axium daemon reload</code> - Environment changes - HUD segment updates</p> <p>When: - Before HUD cache is regenerated for all panes</p> <p>Common Uses: - Trigger expensive HUD calculations only when needed - Update dynamic HUD segments - Clear HUD-related caches</p>"},{"location":"reference/events/#event-flow-diagrams","title":"Event Flow Diagrams","text":""},{"location":"reference/events/#environment-change-flow","title":"Environment Change Flow","text":"<pre><code>User runs: axium env set prod\n    \u2193\nCLI \u2192 IPC set_env {\"env\": \"prod\"}\n    \u2193\nDaemon updates state: active_env = \"prod\"\n    \u2193\nDaemon emits: env_change(\"prod\", \"dev\")\n    \u2193\nSpokes receive callbacks (in registration order)\n    \u2193\nDaemon refreshes HUD cache for all panes\n    \u2193\nCLI exits silently (success)\n</code></pre>"},{"location":"reference/events/#daemon-reload-flow","title":"Daemon Reload Flow","text":"<pre><code>User runs: axium daemon reload\n    \u2193\nCLI \u2192 IPC reload {}\n    \u2193\nDaemon reloads config files\n    \u2193\nDaemon emits: hud_refresh\n    \u2193\nDaemon reloads all Spokes\n    \u2193\nDaemon emits: spoke_reloaded for each Spoke\n    \u2193\nDaemon emits: daemon_reload\n    \u2193\nDaemon emits: config_reloaded\n    \u2193\nDaemon refreshes HUD cache\n    \u2193\nCLI exits silently (success)\n</code></pre>"},{"location":"reference/events/#spoke-installation-flow","title":"Spoke Installation Flow","text":"<pre><code>User runs: axium spoke install myspoke\n    \u2193\nCLI copies/symlinks spoke to ~/.config/axium/spokes/myspoke\n    \u2193\nCLI creates metadata entry\n    \u2193\nCLI \u2192 IPC reload {} (triggers daemon reload)\n    \u2193\nDaemon discovers new spoke\n    \u2193\nDaemon calls myspoke.register(app, events)\n    \u2193\nDaemon emits: spoke_loaded(\"myspoke\")\n    \u2193\nOther spokes receive callbacks\n    \u2193\nCLI outputs: \"Spoke 'myspoke' installed successfully\"\n</code></pre>"},{"location":"reference/events/#best-practices","title":"Best Practices","text":""},{"location":"reference/events/#event-handler-guidelines","title":"Event Handler Guidelines","text":"<ol> <li>Keep handlers fast: Events are synchronous, slow handlers block daemon</li> <li>Handle errors gracefully: Exceptions are logged but don't stop propagation</li> <li>Use keyword arguments: Event signatures may gain parameters in future</li> <li>Avoid recursion: Don't emit events from within handlers for same event</li> <li>Log appropriately: Use <code>logger.debug()</code> for routine events, <code>logger.info()</code> for important changes</li> </ol>"},{"location":"reference/events/#example-robust-event-handler","title":"Example: Robust Event Handler","text":"<pre><code>import logging\n\nlogger = logging.getLogger(\"myspoke\")\n\ndef register(app, events):\n    def on_env_change(new_env: str, old_env: str, **kwargs):\n        \"\"\"Handle environment change with proper error handling.\"\"\"\n        try:\n            # Fast operations only\n            pane = kwargs.get(\"pane\")\n\n            # Check if this is relevant to us\n            if not new_env:\n                logger.debug(\"Environment cleared\")\n                return\n\n            # Perform lightweight updates\n            update_hud_for_env(new_env)\n\n            # Defer expensive operations\n            if needs_heavy_work(new_env):\n                # Use daemon_exec for background work\n                from axium.core import api\n                api.daemon_exec(\"myspoke\", f\"myspoke refresh --env {new_env}\")\n\n        except Exception as e:\n            # Log but don't crash\n            logger.error(f\"Failed to handle env_change: {e}\")\n\n    events.on(\"env_change\", on_env_change)\n</code></pre>"},{"location":"reference/events/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Environment changes: May happen frequently in tmux (pane switching)</li> <li>HUD refresh: Triggers on every status line update (~1-5 seconds in tmux)</li> <li>Daemon reload: Infrequent, can do heavier work</li> </ul> <p>Choose the right event for your use case: - Fast checks (&lt;10ms): Use events directly - Medium checks (10-100ms): Use events but cache results - Slow checks (&gt;100ms): Use <code>daemon_exec()</code> for background processing</p>"},{"location":"reference/events/#custom-events","title":"Custom Events","text":"<p>Spokes can emit custom events for coordination:</p> <pre><code>def register(app, events):\n    # Emit custom event\n    events.emit(\"myspoke_ready\", version=\"1.0.0\")\n\n    # Listen to custom events from other spokes\n    def on_other_spoke_event(data):\n        print(f\"Received: {data}\")\n\n    events.on(\"other_spoke_ready\", on_other_spoke_event)\n</code></pre> <p>Note: Custom events are not guaranteed to persist across daemon versions. Use for inter-spoke coordination only, not for core functionality.</p>"},{"location":"reference/events/#see-also","title":"See Also","text":"<ul> <li>Writing Spokes Guide - Complete spoke development guide</li> <li>API Reference - EventBus API documentation</li> <li>HUD Segments Guide - HUD integration patterns</li> </ul>"},{"location":"reference/ipc-commands/","title":"IPC Commands Reference","text":"<p>Axium's daemon exposes an IPC protocol over a Unix domain socket for communication between CLI commands, spokes, and gears. This document catalogs all available IPC commands.</p> <p>Use API Instead</p> <p>Spokes and gears should use <code>axium.core.api</code> instead of direct IPC calls.</p> <p>The API provides better error handling, type safety, and future compatibility. Only use direct IPC for:</p> <ul> <li>Core daemon internal operations</li> <li>Debugging and testing</li> <li>Understanding the underlying protocol</li> </ul> <p>See API Reference for the recommended high-level interface.</p>"},{"location":"reference/ipc-commands/#connection","title":"Connection","text":"<ul> <li>Socket Path: <code>~/.config/axium/daemon.sock</code></li> <li>Protocol: JSON over Unix socket (newline-delimited)</li> <li>Client Library: <code>axium.core.ipc.send_request_sync(payload, timeout=2.0)</code></li> </ul>"},{"location":"reference/ipc-commands/#command-format","title":"Command Format","text":"<p>All commands follow this structure:</p> <pre><code>{\n    \"cmd\": \"command_name\",\n    # Additional parameters...\n}\n</code></pre> <p>Responses follow this structure:</p> <pre><code>{\n    \"ok\": True,  # or False\n    # Additional response data...\n}\n</code></pre>"},{"location":"reference/ipc-commands/#core-commands","title":"Core Commands","text":""},{"location":"reference/ipc-commands/#ping","title":"ping","text":"<p>Check if daemon is alive.</p> <p>Request: <pre><code>{\"cmd\": \"ping\"}\n</code></pre></p> <p>Response: <pre><code>{\"ok\": True, \"pong\": True}\n</code></pre></p> <p>Example: <pre><code>from axium.core.ipc import send_request_sync\nresponse = send_request_sync({\"cmd\": \"ping\"})\n# {\"ok\": True, \"pong\": True}\n</code></pre></p>"},{"location":"reference/ipc-commands/#get_state","title":"get_state","text":"<p>Get full daemon state (active environment, panes, uptime, etc.).</p> <p>Request: <pre><code>{\"cmd\": \"get_state\"}\n</code></pre></p> <p>Response: <pre><code>{\n    \"ok\": True,\n    \"state\": {\n        \"active_env\": \"prod\",\n        \"started\": 1697123456.789,\n        \"panes\": {\"%1\": {\"env\": \"dev\"}, ...}\n    }\n}\n</code></pre></p>"},{"location":"reference/ipc-commands/#daemon_status","title":"daemon_status","text":"<p>Get daemon status summary.</p> <p>Request: <pre><code>{\"cmd\": \"daemon_status\"}\n</code></pre></p> <p>Response: <pre><code>{\n    \"ok\": True,\n    \"status\": {\n        \"running\": True,\n        \"uptime\": \"2h 15m 30s\",\n        \"active_env\": \"prod\",\n        \"panes\": 3\n    }\n}\n</code></pre></p>"},{"location":"reference/ipc-commands/#stop","title":"stop","text":"<p>Stop the daemon gracefully.</p> <p>Request: <pre><code>{\"cmd\": \"stop\"}\n</code></pre></p> <p>Response: <pre><code>{\"ok\": True, \"stopping\": True}\n</code></pre></p> <p>Note: Connection closes immediately after response. Daemon exits cleanly.</p>"},{"location":"reference/ipc-commands/#environment-management","title":"Environment Management","text":""},{"location":"reference/ipc-commands/#set_env","title":"set_env","text":"<p>Set the active environment globally.</p> <p>Request: <pre><code>{\"cmd\": \"set_env\", \"value\": \"prod\"}\n</code></pre></p> <p>Response: <pre><code>{\"ok\": True}\n</code></pre></p> <p>Side Effects: - Saves state to disk - Invalidates all config caches - Emits <code>env_change</code> event with <code>(new_env, old_env)</code></p> <p>Example: <pre><code>response = send_request_sync({\"cmd\": \"set_env\", \"value\": \"staging\"})\n# Spokes receive env_change event automatically\n</code></pre></p>"},{"location":"reference/ipc-commands/#set_pane_env","title":"set_pane_env","text":"<p>Set environment override for a specific tmux pane.</p> <p>Request: <pre><code>{\"cmd\": \"set_pane_env\", \"pane\": \"%3\", \"env\": \"dev\"}\n</code></pre></p> <p>Response: <pre><code>{\"ok\": True}\n</code></pre></p> <p>Use Case: Different environments in different tmux panes.</p>"},{"location":"reference/ipc-commands/#get_pane_env","title":"get_pane_env","text":"<p>Get environment for a specific pane (returns override or global).</p> <p>Request: <pre><code>{\"cmd\": \"get_pane_env\", \"pane\": \"%3\"}\n</code></pre></p> <p>Response: <pre><code>{\"ok\": True, \"env\": \"dev\"}\n</code></pre></p>"},{"location":"reference/ipc-commands/#clear_pane_env","title":"clear_pane_env","text":"<p>Clear environment override for a pane (falls back to global).</p> <p>Request: <pre><code>{\"cmd\": \"clear_pane_env\", \"pane\": \"%3\"}\n</code></pre></p> <p>Response: <pre><code>{\"ok\": True}\n</code></pre></p>"},{"location":"reference/ipc-commands/#hud-system","title":"HUD System","text":""},{"location":"reference/ipc-commands/#get_hud","title":"get_hud","text":"<p>Render HUD string for a specific pane.</p> <p>Request: <pre><code>{\"cmd\": \"get_hud\", \"pane\": \"%3\"}\n</code></pre></p> <p>Response: <pre><code>{\n    \"ok\": True,\n    \"hud\": \"[axium] env:prod  uptime:2h15m  creds:Y\"\n}\n</code></pre></p> <p>Notes: - HUD is rendered fresh on each call (includes dynamic uptime) - Falls back to <code>[axium] inactive</code> on error - Used by <code>axium hud</code> command and tmux status-right</p>"},{"location":"reference/ipc-commands/#configuration","title":"Configuration","text":""},{"location":"reference/ipc-commands/#get_config","title":"get_config","text":"<p>Get configuration value by key.</p> <p>Request: <pre><code>{\"cmd\": \"get_config\", \"key\": \"hud\"}\n</code></pre></p> <p>Response: <pre><code>{\n    \"ok\": True,\n    \"value\": {\n        \"style\": {\n            \"wrapper\": {\"left\": \"[\", \"right\": \"]\"},\n            \"theme\": {\"enabled\": True, \"name\": \"teal\"}\n        }\n    }\n}\n</code></pre></p> <p>Available Keys: - <code>hud</code> - HUD configuration from <code>~/.config/axium/hud.yaml</code> - Spoke configs (via spoke-specific loaders)</p>"},{"location":"reference/ipc-commands/#reload","title":"reload","text":"<p>Reload all configuration and refresh caches.</p> <p>Request: <pre><code>{\"cmd\": \"reload\"}\n</code></pre></p> <p>Response: <pre><code>{\"ok\": True, \"reloaded\": True}\n</code></pre></p> <p>Side Effects: - Reloads state from disk - Reloads HUD config - Reloads prefix config - Reloads all spoke configs - Regenerates state cache - Refreshes HUD cache for all panes - Emits events: <code>hud_refresh</code>, <code>daemon_reload</code>, <code>config_reloaded</code></p> <p>Use Case: Apply config changes without restarting daemon.</p>"},{"location":"reference/ipc-commands/#prefix-system","title":"Prefix System","text":""},{"location":"reference/ipc-commands/#apply_prefixes","title":"apply_prefixes","text":"<p>Apply prefix rules to a command.</p> <p>Request: <pre><code>{\n    \"cmd\": \"apply_prefixes\",\n    \"command\": \"kubectl\",\n    \"args\": [\"get\", \"pods\"],\n    \"context\": {\"env\": \"prod\"}\n}\n</code></pre></p> <p>Response: <pre><code>{\n    \"ok\": True,\n    \"command\": [\"kubectl\", \"--context=prod-cluster\", \"get\", \"pods\"],\n    \"env_vars\": {\"KUBECONFIG\": \"/path/to/prod.kubeconfig\"}\n}\n</code></pre></p>"},{"location":"reference/ipc-commands/#list_prefixed_commands","title":"list_prefixed_commands","text":"<p>List all commands that have prefix rules.</p> <p>Request: <pre><code>{\"cmd\": \"list_prefixed_commands\"}\n</code></pre></p> <p>Response: <pre><code>{\n    \"ok\": True,\n    \"commands\": [\"kubectl\", \"terraform\", \"aws\"]\n}\n</code></pre></p>"},{"location":"reference/ipc-commands/#register_prefix","title":"register_prefix","text":"<p>Register a new prefix rule dynamically.</p> <p>Request: <pre><code>{\n    \"cmd\": \"register_prefix\",\n    \"command\": \"kubectl\",\n    \"strategy\": \"args_append\",\n    \"config\": {\"args\": [\"--context={{env}}\"]}\n}\n</code></pre></p> <p>Response: <pre><code>{\"ok\": True}\n</code></pre></p> <p>Strategies: - <code>args_append</code> - Append arguments - <code>args_prepend</code> - Prepend arguments - <code>env_vars</code> - Set environment variables - <code>wrapper</code> - Wrap command in another command</p>"},{"location":"reference/ipc-commands/#spoke-management","title":"Spoke Management","text":""},{"location":"reference/ipc-commands/#reload_spoke","title":"reload_spoke","text":"<p>Reload a specific spoke.</p> <p>Request: <pre><code>{\"cmd\": \"reload_spoke\", \"spoke\": \"creds\"}\n</code></pre></p> <p>Response: <pre><code>{\"ok\": True, \"spoke\": \"creds\"}\n</code></pre></p> <p>Side Effects: - Reloads spoke Python module - Re-registers spoke commands and event handlers - Emits <code>spoke_reloaded</code> event with <code>spoke_name</code></p>"},{"location":"reference/ipc-commands/#reload_spokes","title":"reload_spokes","text":"<p>Reload all spokes.</p> <p>Request: <pre><code>{\"cmd\": \"reload_spokes\"}\n</code></pre></p> <p>Response: <pre><code>{\n    \"ok\": True,\n    \"spokes\": [\"creds\", \"tmux-workflow\", \"aws-sso\"]\n}\n</code></pre></p> <p>Side Effects: - Reloads all spoke modules - Emits <code>spoke_reloaded</code> event for each spoke</p>"},{"location":"reference/ipc-commands/#permissions-gears-only","title":"Permissions (Gears Only)","text":""},{"location":"reference/ipc-commands/#get_permissions","title":"get_permissions","text":"<p>Get permissions for a specific gear.</p> <p>Request: <pre><code>{\"cmd\": \"get_permissions\", \"gear\": \"my-gear\"}\n</code></pre></p> <p>Response: <pre><code>{\n    \"ok\": True,\n    \"permissions\": {\n        \"exec\": True,\n        \"notify\": True,\n        \"ipc\": [\"tmux_split_run\", \"notify\"],\n        \"fs_read\": [\"~/.my-tool/**\"],\n        \"fs_write\": [\"~/.my-tool/cache/**\"]\n    }\n}\n</code></pre></p>"},{"location":"reference/ipc-commands/#load_spoke_permissions","title":"load_spoke_permissions","text":"<p>Load permissions manifest for a gear.</p> <p>Request: <pre><code>{\"cmd\": \"load_spoke_permissions\", \"spoke\": \"my-gear\"}\n</code></pre></p> <p>Response: <pre><code>{\"ok\": True}\n</code></pre></p> <p>Note: Reads <code>manifest.yaml</code> from gear directory and caches permissions.</p>"},{"location":"reference/ipc-commands/#notifications","title":"Notifications","text":""},{"location":"reference/ipc-commands/#notify","title":"notify","text":"<p>Send a notification (requires <code>notify</code> permission for gears).</p> <p>Request: <pre><code>{\n    \"cmd\": \"notify\",\n    \"title\": \"Build Complete\",\n    \"message\": \"Production deployment successful\",\n    \"level\": \"info\"\n}\n</code></pre></p> <p>Response: <pre><code>{\"ok\": True}\n</code></pre></p> <p>Levels: <code>info</code>, <code>warning</code>, <code>error</code>, <code>success</code></p>"},{"location":"reference/ipc-commands/#notify_drain","title":"notify_drain","text":"<p>Retrieve and clear pending notifications.</p> <p>Request: <pre><code>{\"cmd\": \"notify_drain\"}\n</code></pre></p> <p>Response: <pre><code>{\n    \"ok\": True,\n    \"notifications\": [\n        {\"title\": \"...\", \"message\": \"...\", \"level\": \"info\", \"timestamp\": 1697123456}\n    ]\n}\n</code></pre></p> <p>Use Case: HUD polling for inline notifications (Feature 9).</p>"},{"location":"reference/ipc-commands/#tmux-integration-gears-only","title":"Tmux Integration (Gears Only)","text":""},{"location":"reference/ipc-commands/#tmux_split_run","title":"tmux_split_run","text":"<p>Create a tmux split pane and run a command.</p> <p>Request: <pre><code>{\n    \"cmd\": \"tmux_split_run\",\n    \"command\": \"tail -f /var/log/app.log\",\n    \"split\": \"horizontal\"  # or \"vertical\"\n}\n</code></pre></p> <p>Response: <pre><code>{\"ok\": True, \"pane\": \"%5\"}\n</code></pre></p> <p>Requires: <code>tmux_split_run</code> in gear's <code>ipc</code> permissions.</p>"},{"location":"reference/ipc-commands/#tmux_send_keys","title":"tmux_send_keys","text":"<p>Send keys to a tmux pane.</p> <p>Request: <pre><code>{\n    \"cmd\": \"tmux_send_keys\",\n    \"pane\": \"%5\",\n    \"keys\": \"echo hello\\n\"\n}\n</code></pre></p> <p>Response: <pre><code>{\"ok\": True}\n</code></pre></p>"},{"location":"reference/ipc-commands/#tmux_capture_pane","title":"tmux_capture_pane","text":"<p>Capture content from a tmux pane.</p> <p>Request: <pre><code>{\n    \"cmd\": \"tmux_capture_pane\",\n    \"pane\": \"%5\",\n    \"start\": -10,  # Last 10 lines\n    \"end\": -1\n}\n</code></pre></p> <p>Response: <pre><code>{\n    \"ok\": True,\n    \"content\": \"captured pane content...\"\n}\n</code></pre></p>"},{"location":"reference/ipc-commands/#file-operations-gears-only","title":"File Operations (Gears Only)","text":""},{"location":"reference/ipc-commands/#read_file","title":"read_file","text":"<p>Read a file (requires <code>fs_read</code> permission with matching path).</p> <p>Request: <pre><code>{\n    \"cmd\": \"read_file\",\n    \"path\": \"/home/user/.my-tool/config.yaml\"\n}\n</code></pre></p> <p>Response: <pre><code>{\n    \"ok\": True,\n    \"content\": \"file contents...\"\n}\n</code></pre></p> <p>Error Response: <pre><code>{\n    \"ok\": False,\n    \"error\": \"Permission denied: path not in fs_read whitelist\"\n}\n</code></pre></p>"},{"location":"reference/ipc-commands/#write_file","title":"write_file","text":"<p>Write a file (requires <code>fs_write</code> permission with matching path).</p> <p>Request: <pre><code>{\n    \"cmd\": \"write_file\",\n    \"path\": \"/home/user/.my-tool/cache/data.json\",\n    \"content\": \"{\\\"key\\\": \\\"value\\\"}\"\n}\n</code></pre></p> <p>Response: <pre><code>{\"ok\": True}\n</code></pre></p>"},{"location":"reference/ipc-commands/#write_log","title":"write_log","text":"<p>Write to daemon log file.</p> <p>Request: <pre><code>{\n    \"cmd\": \"write_log\",\n    \"level\": \"info\",\n    \"message\": \"Custom log message\",\n    \"gear\": \"my-gear\"\n}\n</code></pre></p> <p>Response: <pre><code>{\"ok\": True}\n</code></pre></p> <p>Levels: <code>debug</code>, <code>info</code>, <code>warning</code>, <code>error</code></p>"},{"location":"reference/ipc-commands/#process-execution-gears-only","title":"Process Execution (Gears Only)","text":""},{"location":"reference/ipc-commands/#daemon_exec","title":"daemon_exec","text":"<p>Execute a command in the daemon process (requires <code>exec</code> permission).</p> <p>Request: <pre><code>{\n    \"cmd\": \"daemon_exec\",\n    \"command\": [\"git\", \"status\"],\n    \"cwd\": \"/path/to/repo\",\n    \"env\": {\"GIT_DIR\": \"/custom/git\"}\n}\n</code></pre></p> <p>Response: <pre><code>{\n    \"ok\": True,\n    \"stdout\": \"On branch main...\",\n    \"stderr\": \"\",\n    \"returncode\": 0\n}\n</code></pre></p> <p>Warning: Use sparingly. Commands run in daemon process with elevated privileges.</p>"},{"location":"reference/ipc-commands/#usage-patterns","title":"Usage Patterns","text":""},{"location":"reference/ipc-commands/#core-spokes-no-permissions","title":"Core Spokes (No Permissions)","text":"<p>Core spokes have unrestricted access to all IPC commands:</p> <pre><code>from axium.core.ipc import send_request_sync\n\n# Set environment\nsend_request_sync({\"cmd\": \"set_env\", \"value\": \"prod\"})\n\n# Get HUD\nhud = send_request_sync({\"cmd\": \"get_hud\", \"pane\": \"%3\"})\nprint(hud[\"hud\"])\n</code></pre>"},{"location":"reference/ipc-commands/#gears-permission-restricted","title":"Gears (Permission-Restricted)","text":"<p>Gears must declare required permissions in <code>manifest.yaml</code>:</p> <pre><code># manifest.yaml\npermissions:\n  exec: true\n  notify: true\n  ipc:\n    - tmux_split_run\n    - notify\n  fs_read:\n    - ~/.my-tool/**\n  fs_write:\n    - ~/.my-tool/cache/**\n</code></pre> <p>Then use API with automatic permission checking:</p> <pre><code>from axium.core import api\n\n# Automatically checks permissions before sending IPC\napi.notify(\"Build Complete\", \"Deploy succeeded\")\napi.tmux_split_run(\"tail -f /var/log/app.log\")\n</code></pre>"},{"location":"reference/ipc-commands/#error-handling","title":"Error Handling","text":"<p>Always handle IPC errors gracefully:</p> <pre><code>try:\n    resp = send_request_sync({\"cmd\": \"set_env\", \"value\": \"prod\"}, timeout=2.0)\n    if not resp.get(\"ok\"):\n        print(f\"Error: {resp.get('error')}\")\nexcept Exception as e:\n    print(f\"IPC failed: {e}\")\n</code></pre>"},{"location":"reference/ipc-commands/#see-also","title":"See Also","text":"<ul> <li>Events Reference - Events emitted by IPC commands</li> <li>API Reference - High-level Python API wrappers</li> <li>Gears Guide - Gear permissions system</li> </ul>"},{"location":"reference/api/cli/","title":"CLI API","text":"<p>Command-line interface implementation.</p>"},{"location":"reference/api/cli/#cli","title":"cli","text":"<p>Main CLI entrypoint and command definitions.</p>"},{"location":"reference/api/cli/#axium.core.cli","title":"<code>cli</code>","text":"<p>Axium CLI - Main command-line interface.</p> <p>This module provides the Typer-based CLI for Axium, including daemon management, environment controls, command execution with prefix wrapping, HUD status display, and interactive palette.</p> <p>The CLI automatically bootstraps configuration on first run and loads any installed Spokes to extend functionality.</p> Example <pre><code>$ axium daemon start\n$ axium env set prod\n$ axium run aws s3 ls\n$ axium hud\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.HelpfulGroup","title":"<code>HelpfulGroup</code>","text":"<p>               Bases: <code>TyperGroup</code></p> <p>Custom Typer group that shows full help on invalid commands.</p> <p>When a user mistypes a command, instead of just showing an error, displays the full command list to guide them to the correct command.</p> <p>This improves CLI usability by making Axium self-documenting and reducing friction when users make typos.</p> Source code in <code>axium/core/cli.py</code> <pre><code>class HelpfulGroup(TyperGroup):\n    \"\"\"\n    Custom Typer group that shows full help on invalid commands.\n\n    When a user mistypes a command, instead of just showing an error,\n    displays the full command list to guide them to the correct command.\n\n    This improves CLI usability by making Axium self-documenting and\n    reducing friction when users make typos.\n    \"\"\"\n\n    def resolve_command(\n        self, ctx: click.Context, args: list[str]\n    ) -&gt; tuple[str | None, click.Command | None, list[str]]:\n        \"\"\"\n        Override resolve_command to show help on command not found.\n\n        This is called by Click to resolve which command to run.\n        If the command is not found, we print an error, show help, and exit.\n\n        Args:\n            ctx: Click context containing app state and configuration\n            args: Command-line arguments to resolve\n\n        Returns:\n            Tuple of (command_name, command_object, remaining_args)\n\n        Raises:\n            click.exceptions.UsageError: For errors other than command not found\n        \"\"\"\n        try:\n            return super().resolve_command(ctx, args)\n        except click.exceptions.UsageError as e:\n            # Check if it's a \"No such command\" error\n            if \"No such command\" in str(e):\n                # Print error message\n                click.echo(f\"Error: {e.format_message()}\", err=True)\n                click.echo()  # Blank line for readability\n                # Show full help\n                click.echo(ctx.get_help())\n                ctx.exit(1)\n            # Re-raise other usage errors\n            raise\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.HelpfulGroup.resolve_command","title":"<code>resolve_command(ctx, args)</code>","text":"<p>Override resolve_command to show help on command not found.</p> <p>This is called by Click to resolve which command to run. If the command is not found, we print an error, show help, and exit.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>Click context containing app state and configuration</p> required <code>args</code> <code>list[str]</code> <p>Command-line arguments to resolve</p> required <p>Returns:</p> Type Description <code>tuple[str | None, Command | None, list[str]]</code> <p>Tuple of (command_name, command_object, remaining_args)</p> <p>Raises:</p> Type Description <code>UsageError</code> <p>For errors other than command not found</p> Source code in <code>axium/core/cli.py</code> <pre><code>def resolve_command(\n    self, ctx: click.Context, args: list[str]\n) -&gt; tuple[str | None, click.Command | None, list[str]]:\n    \"\"\"\n    Override resolve_command to show help on command not found.\n\n    This is called by Click to resolve which command to run.\n    If the command is not found, we print an error, show help, and exit.\n\n    Args:\n        ctx: Click context containing app state and configuration\n        args: Command-line arguments to resolve\n\n    Returns:\n        Tuple of (command_name, command_object, remaining_args)\n\n    Raises:\n        click.exceptions.UsageError: For errors other than command not found\n    \"\"\"\n    try:\n        return super().resolve_command(ctx, args)\n    except click.exceptions.UsageError as e:\n        # Check if it's a \"No such command\" error\n        if \"No such command\" in str(e):\n            # Print error message\n            click.echo(f\"Error: {e.format_message()}\", err=True)\n            click.echo()  # Blank line for readability\n            # Show full help\n            click.echo(ctx.get_help())\n            ctx.exit(1)\n        # Re-raise other usage errors\n        raise\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.is_verbose","title":"<code>is_verbose()</code>","text":"<p>Check if verbose mode is enabled.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if --verbose flag was passed, False otherwise</p> Example <pre><code>from axium.core.cli import is_verbose\n\nif is_verbose():\n    print(\"Detailed operation info...\")\n</code></pre> Source code in <code>axium/core/cli.py</code> <pre><code>def is_verbose() -&gt; bool:\n    \"\"\"\n    Check if verbose mode is enabled.\n\n    Returns:\n        True if --verbose flag was passed, False otherwise\n\n    Example:\n        ```python\n        from axium.core.cli import is_verbose\n\n        if is_verbose():\n            print(\"Detailed operation info...\")\n        ```\n    \"\"\"\n    return _verbose\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.info","title":"<code>info()</code>","text":"<p>Display Axium information and tagline.</p> Example <pre><code>$ axium info\nAxium core \u2014 everything revolves around you.\n</code></pre> Source code in <code>axium/core/cli.py</code> <pre><code>@app.command()\ndef info() -&gt; None:\n    \"\"\"\n    Display Axium information and tagline.\n\n    Example:\n        ```bash\n        $ axium info\n        Axium core \u2014 everything revolves around you.\n        ```\n    \"\"\"\n    print(\"Axium core \u2014 everything revolves around you.\")\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.help","title":"<code>help()</code>","text":"<p>Show unified help with all commands grouped by category.</p> <p>Displays all available commands from core, spokes, and gears in a structured, categorized format.</p> Example <pre><code>$ axium help\nAxium: structure for your terminal\n\nCore Commands:\n  bootstrap          Initialize or update Axium configuration\n  info               Display Axium information and tagline\n  ...\n\nDaemon &amp; System:\n  daemon start       Start Axium daemon\n  daemon stop        Stop Axium daemon\n  ...\n</code></pre> Note <p>This replaces the need to run --help on each command group. For detailed help on a specific command, use: axium  --help Source code in <code>axium/core/cli.py</code> <pre><code>@app.command()\ndef help() -&gt; None:\n    \"\"\"\n    Show unified help with all commands grouped by category.\n\n    Displays all available commands from core, spokes, and gears\n    in a structured, categorized format.\n\n    Example:\n        ```bash\n        $ axium help\n        Axium: structure for your terminal\n\n        Core Commands:\n          bootstrap          Initialize or update Axium configuration\n          info               Display Axium information and tagline\n          ...\n\n        Daemon &amp; System:\n          daemon start       Start Axium daemon\n          daemon stop        Stop Axium daemon\n          ...\n        ```\n\n    Note:\n        This replaces the need to run --help on each command group.\n        For detailed help on a specific command, use:\n        axium &lt;command&gt; --help\n    \"\"\"\n    from axium.core.help import get_grouped_commands, format_help_output\n\n    grouped = get_grouped_commands()\n    output = format_help_output(grouped)\n    print(output)\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.discover","title":"<code>discover()</code>","text":"<p>Show installed components and configuration.</p> <p>Displays: - Configured environments - Installed spokes - Installed gears - Active wrappers</p> <p>Useful for understanding what's available in your Axium installation.</p> Example <pre><code>$ axium discover\nAxium Discovery\n\nEnvironments (3):\n  \u2022 dev\n  \u2022 staging\n  \u2022 prod\n\nInstalled Spokes (2):\n  \u2022 aws-spoke\n  \u2022 k8s-spoke\n\nInstalled Gears (1):\n  \u2022 ansible-gear\n\nActive Wrappers: 5\n</code></pre> Note <p>Use 'axium help' to see all available commands.</p> Source code in <code>axium/core/cli.py</code> <pre><code>@app.command()\ndef discover() -&gt; None:\n    \"\"\"\n    Show installed components and configuration.\n\n    Displays:\n    - Configured environments\n    - Installed spokes\n    - Installed gears\n    - Active wrappers\n\n    Useful for understanding what's available in your Axium installation.\n\n    Example:\n        ```bash\n        $ axium discover\n        Axium Discovery\n\n        Environments (3):\n          \u2022 dev\n          \u2022 staging\n          \u2022 prod\n\n        Installed Spokes (2):\n          \u2022 aws-spoke\n          \u2022 k8s-spoke\n\n        Installed Gears (1):\n          \u2022 ansible-gear\n\n        Active Wrappers: 5\n        ```\n\n    Note:\n        Use 'axium help' to see all available commands.\n    \"\"\"\n    from axium.core.help import get_discovery_info, format_discovery_output\n\n    info = get_discovery_info()\n    output = format_discovery_output(info)\n    print(output)\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.doctor","title":"<code>doctor()</code>","text":"<p>Check Axium configuration and system health.</p> <p>Runs diagnostics on: - Config directory structure - Daemon connectivity - Environment definitions - Spoke/gear loading - File permissions - Shell integration</p> <p>Provides actionable fix suggestions for any issues found.</p> Example <pre><code>$ axium doctor\nAxium Health Check\n\n\u2713 Config directory: /Users/user/.config/axium\n\u2713 Daemon running: PID 12345\n\u2713 IPC socket: Accessible\n\u2713 Environments: 3 configured\n\u2713 Spokes: 2 installed, 2 active\n\u2713 Gears: 1 installed\n\u2717 Shell integration: Not detected\n  \u2192 Add to ~/.bashrc: source ~/.config/axium/bash/init.sh\n\nOverall: 6/7 checks passed\n</code></pre> Note <p>Run this command if you're experiencing issues with Axium. All checks are read-only and safe to run repeatedly.</p> Source code in <code>axium/core/cli.py</code> <pre><code>@app.command()\ndef doctor() -&gt; None:\n    \"\"\"\n    Check Axium configuration and system health.\n\n    Runs diagnostics on:\n    - Config directory structure\n    - Daemon connectivity\n    - Environment definitions\n    - Spoke/gear loading\n    - File permissions\n    - Shell integration\n\n    Provides actionable fix suggestions for any issues found.\n\n    Example:\n        ```bash\n        $ axium doctor\n        Axium Health Check\n\n        \u2713 Config directory: /Users/user/.config/axium\n        \u2713 Daemon running: PID 12345\n        \u2713 IPC socket: Accessible\n        \u2713 Environments: 3 configured\n        \u2713 Spokes: 2 installed, 2 active\n        \u2713 Gears: 1 installed\n        \u2717 Shell integration: Not detected\n          \u2192 Add to ~/.bashrc: source ~/.config/axium/bash/init.sh\n\n        Overall: 6/7 checks passed\n        ```\n\n    Note:\n        Run this command if you're experiencing issues with Axium.\n        All checks are read-only and safe to run repeatedly.\n    \"\"\"\n    from axium.core.doctor import run_all_checks, format_doctor_output\n\n    checks = run_all_checks()\n    output = format_doctor_output(checks)\n    print(output)\n\n    # Exit with error code if any checks failed\n    failed = sum(1 for c in checks if not c.passed)\n    if failed &gt; 0:\n        raise typer.Exit(code=1)\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.completions_list_cmd","title":"<code>completions_list_cmd(shell=typer.Option('zsh', '--shell', help='Shell type (zsh, bash, fish)'), prefix=typer.Argument('', help='Prefix to filter completions'))</code>","text":"<p>List matching completions for shell integration.</p> <p>Used by shell completion functions to get matching commands. Returns one command per line for easy parsing by shell scripts.</p> <p>The completion cache is automatically regenerated when: - Spokes are loaded, reloaded, or unloaded - Gears are loaded or unloaded - Daemon configuration is reloaded</p> <p>Parameters:</p> Name Type Description Default <code>shell</code> <code>str</code> <p>Shell type (zsh, bash, fish) - currently all use same format</p> <code>Option('zsh', '--shell', help='Shell type (zsh, bash, fish)')</code> <code>prefix</code> <code>str</code> <p>Command prefix to match (e.g., \"env\", \"daemon s\")</p> <code>Argument('', help='Prefix to filter completions')</code> Example <pre><code>$ axium completions list \"\"\nbootstrap\ndaemon logs\ndaemon reload\ndaemon start\n...\n\n$ axium completions list \"env\"\nenv get\nenv list\nenv set\nenv show\n\n$ axium completions list --shell zsh \"daemon s\"\ndaemon start\ndaemon status\n</code></pre> Performance <p>Target response time: &lt;50ms including cache load and filtering</p> Usage in shell <pre><code># In zsh completion function:\ncompletions=$(axium completions list \"$word\" 2&gt;/dev/null)\n</code></pre> Note <p>If the cache doesn't exist, returns empty list. Cache is regenerated automatically by the daemon on command structure changes.</p> Source code in <code>axium/core/cli.py</code> <pre><code>@completions_app.command(\"list\")\ndef completions_list_cmd(\n    shell: str = typer.Option(\"zsh\", \"--shell\", help=\"Shell type (zsh, bash, fish)\"),\n    prefix: str = typer.Argument(\"\", help=\"Prefix to filter completions\"),\n) -&gt; None:\n    \"\"\"\n    List matching completions for shell integration.\n\n    Used by shell completion functions to get matching commands.\n    Returns one command per line for easy parsing by shell scripts.\n\n    The completion cache is automatically regenerated when:\n    - Spokes are loaded, reloaded, or unloaded\n    - Gears are loaded or unloaded\n    - Daemon configuration is reloaded\n\n    Args:\n        shell: Shell type (zsh, bash, fish) - currently all use same format\n        prefix: Command prefix to match (e.g., \"env\", \"daemon s\")\n\n    Example:\n        ```bash\n        $ axium completions list \"\"\n        bootstrap\n        daemon logs\n        daemon reload\n        daemon start\n        ...\n\n        $ axium completions list \"env\"\n        env get\n        env list\n        env set\n        env show\n\n        $ axium completions list --shell zsh \"daemon s\"\n        daemon start\n        daemon status\n        ```\n\n    Performance:\n        Target response time: &lt;50ms including cache load and filtering\n\n    Usage in shell:\n        ```zsh\n        # In zsh completion function:\n        completions=$(axium completions list \"$word\" 2&gt;/dev/null)\n        ```\n\n    Note:\n        If the cache doesn't exist, returns empty list. Cache is regenerated\n        automatically by the daemon on command structure changes.\n    \"\"\"\n    from axium.core.completions import get_completions\n\n    matches = get_completions(prefix)\n    for cmd in matches:\n        print(cmd)\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.completions_install_cmd","title":"<code>completions_install_cmd(shell=typer.Option(None, '--shell', help='Shell type (auto-detect if not specified)'))</code>","text":"<p>Print shell completion setup instructions.</p> <p>Outputs the completion script to add to your shell configuration file. Auto-detects shell from $SHELL environment variable if not specified.</p> <p>Parameters:</p> Name Type Description Default <code>shell</code> <code>str</code> <p>Shell type (zsh, bash, fish). Auto-detected if omitted.</p> <code>Option(None, '--shell', help='Shell type (auto-detect if not specified)')</code> Example <pre><code>$ axium completions install\n# Add this to ~/.zshrc:\n_axium_completion() { ... }\ncompdef _axium_completion axium\n\n$ axium completions install --shell bash\n# Add this to ~/.bashrc:\n_axium_completion() { ... }\ncomplete -F _axium_completion axium\n</code></pre> Supported Shells <ul> <li>zsh: Fast completion using compadd</li> <li>bash: Completion using complete -F</li> <li>fish: Completion using complete -c</li> </ul> Note <p>After adding the script to your shell config, reload it with: - zsh: source ~/.zshrc - bash: source ~/.bashrc - fish: Completions work immediately after file creation</p> Source code in <code>axium/core/cli.py</code> <pre><code>@completions_app.command(\"install\")\ndef completions_install_cmd(\n    shell: str = typer.Option(\n        None, \"--shell\", help=\"Shell type (auto-detect if not specified)\"\n    ),\n) -&gt; None:\n    \"\"\"\n    Print shell completion setup instructions.\n\n    Outputs the completion script to add to your shell configuration file.\n    Auto-detects shell from $SHELL environment variable if not specified.\n\n    Args:\n        shell: Shell type (zsh, bash, fish). Auto-detected if omitted.\n\n    Example:\n        ```bash\n        $ axium completions install\n        # Add this to ~/.zshrc:\n        _axium_completion() { ... }\n        compdef _axium_completion axium\n\n        $ axium completions install --shell bash\n        # Add this to ~/.bashrc:\n        _axium_completion() { ... }\n        complete -F _axium_completion axium\n        ```\n\n    Supported Shells:\n        - zsh: Fast completion using compadd\n        - bash: Completion using complete -F\n        - fish: Completion using complete -c\n\n    Note:\n        After adding the script to your shell config, reload it with:\n        - zsh: source ~/.zshrc\n        - bash: source ~/.bashrc\n        - fish: Completions work immediately after file creation\n    \"\"\"\n    import os\n    import sys\n    from pathlib import Path\n\n    # Auto-detect shell if not specified\n    if not shell:\n        shell_path = os.getenv(\"SHELL\", \"/bin/zsh\")\n        shell = Path(shell_path).name\n\n    if shell == \"zsh\":\n        print(\"# Axium shell completion for zsh\")\n        print(\"# Add this to ~/.zshrc:\")\n        print()\n        print(\"_axium_completion() {\")\n        print(\"  local prefix current\")\n        print('  current=\"${words[CURRENT]}\"')\n        print(\"  \")\n        print(\"  # Build prefix from all axium arguments up to current position\")\n        print(\"  if [[ $CURRENT -eq 2 ]]; then\")\n        print(\"    # Completing first argument after 'axium'\")\n        print('    prefix=\"$current\"')\n        print(\"  else\")\n        print(\"    # Completing subsequent arguments\")\n        print(\"    # Join all previous words (2 to CURRENT-1) with spaces\")\n        print('    prefix=\"${(j: :)words[2,CURRENT-1]}\"')\n        print(\n            \"    # Add trailing space if current word is empty (user pressed space before tab)\"\n        )\n        print(\n            '    [[ -z \"$current\" ]] &amp;&amp; prefix=\"$prefix \" || prefix=\"$prefix $current\"'\n        )\n        print(\"  fi\")\n        print(\"  \")\n        print(\"  local -a completions\")\n        print(\n            '  completions=($(axium completions list --shell zsh \"$prefix\" 2&gt;/dev/null))'\n        )\n        print('  compadd -Q -- \"${completions[@]}\"')\n        print(\"}\")\n        print(\"compdef _axium_completion axium\")\n        print()\n        print(\"# Then run: source ~/.zshrc\")\n\n    elif shell == \"bash\":\n        print(\"# Axium shell completion for bash\")\n        print(\"# Add this to ~/.bashrc:\")\n        print()\n        print(\"_axium_completion() {\")\n        print(\"  local cur prev words cword\")\n        print(\"  _init_completion || return\")\n        print('  COMPREPLY=($(axium completions list --shell bash \"$cur\" 2&gt;/dev/null))')\n        print(\"}\")\n        print(\"complete -F _axium_completion axium\")\n        print()\n        print(\"# Then run: source ~/.bashrc\")\n\n    elif shell == \"fish\":\n        print(\"# Axium shell completion for fish\")\n        print(\"# Add this to ~/.config/fish/completions/axium.fish:\")\n        print()\n        print(\n            \"complete -c axium -f -a '(axium completions list --shell fish (commandline -ct) 2&gt;/dev/null)'\"\n        )\n        print()\n        print(\"# Completions will be available immediately\")\n\n    else:\n        print(f\"\u2717 Unsupported shell: {shell}\", file=sys.stderr)\n        print(\"  Supported shells: zsh, bash, fish\", file=sys.stderr)\n        raise typer.Exit(1)\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.completions_refresh_cmd","title":"<code>completions_refresh_cmd()</code>","text":"<p>Regenerate completion cache immediately.</p> <p>Forces regeneration of ~/.config/axium/completions.json from the current command registry. Normally the cache is regenerated automatically when spokes load/reload, so manual refresh is rarely needed.</p> <p>Use this command after: - Manually editing spoke files - Installing spokes outside of <code>axium spoke install</code> - Debugging completion issues</p> Example <pre><code>$ axium completions refresh\n\u2713 Regenerated completion cache (42 commands)\n\n$ axium completions refresh\n\u2717 Failed to regenerate completion cache\n</code></pre> Performance <p>Typically completes in &lt;20ms with 100+ commands</p> Note <p>This command requires all spokes to be loaded, so it may trigger spoke loading if not already done. The daemon performs automatic regeneration, so manual refresh is usually unnecessary.</p> Source code in <code>axium/core/cli.py</code> <pre><code>@completions_app.command(\"refresh\")\ndef completions_refresh_cmd() -&gt; None:\n    \"\"\"\n    Regenerate completion cache immediately.\n\n    Forces regeneration of ~/.config/axium/completions.json from the\n    current command registry. Normally the cache is regenerated automatically\n    when spokes load/reload, so manual refresh is rarely needed.\n\n    Use this command after:\n    - Manually editing spoke files\n    - Installing spokes outside of `axium spoke install`\n    - Debugging completion issues\n\n    Example:\n        ```bash\n        $ axium completions refresh\n        \u2713 Regenerated completion cache (42 commands)\n\n        $ axium completions refresh\n        \u2717 Failed to regenerate completion cache\n        ```\n\n    Performance:\n        Typically completes in &lt;20ms with 100+ commands\n\n    Note:\n        This command requires all spokes to be loaded, so it may trigger\n        spoke loading if not already done. The daemon performs automatic\n        regeneration, so manual refresh is usually unnecessary.\n    \"\"\"\n    import sys\n\n    from axium.core.completions import generate_completion_cache, load_completion_cache\n\n    success = generate_completion_cache()\n    if success:\n        if is_verbose():\n            count = len(load_completion_cache())\n            print(f\"\u2713 Regenerated completion cache ({count} commands)\")\n    else:\n        print(\"\u2717 Failed to regenerate completion cache\", file=sys.stderr)\n        raise typer.Exit(1)\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.wrapper_list_cmd","title":"<code>wrapper_list_cmd()</code>","text":"<p>List all currently wrapped commands.</p> <p>Shows commands that have prefix rules configured in prefixes.yaml. These commands will be intercepted by shell wrapper functions that call 'axium run' to apply environment-specific prefixes.</p> Example <pre><code>$ axium wrapper list\naws\nterraform\n\n$ axium wrapper list | wc -l\n2\n</code></pre> Note <p>This reads from ~/.config/axium/state_cache.json which is automatically updated when: - Daemon starts - <code>axium daemon reload</code> is run - Prefix rules in prefixes.yaml change</p> Source code in <code>axium/core/cli.py</code> <pre><code>@wrapper_app.command(\"list\")\ndef wrapper_list_cmd() -&gt; None:\n    \"\"\"\n    List all currently wrapped commands.\n\n    Shows commands that have prefix rules configured in prefixes.yaml.\n    These commands will be intercepted by shell wrapper functions that\n    call 'axium run' to apply environment-specific prefixes.\n\n    Example:\n        ```bash\n        $ axium wrapper list\n        aws\n        terraform\n\n        $ axium wrapper list | wc -l\n        2\n        ```\n\n    Note:\n        This reads from ~/.config/axium/state_cache.json which is\n        automatically updated when:\n        - Daemon starts\n        - `axium daemon reload` is run\n        - Prefix rules in prefixes.yaml change\n    \"\"\"\n    import json\n    from pathlib import Path\n\n    cache_file = Path.home() / \".config\" / \"axium\" / \"state_cache.json\"\n\n    if not cache_file.exists():\n        return\n\n    try:\n        data = json.loads(cache_file.read_text())\n        commands = data.get(\"prefixed_commands\", [])\n        for cmd in commands:\n            print(cmd)\n    except Exception:\n        # Silently fail if cache is invalid\n        pass\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.wrapper_refresh_cmd","title":"<code>wrapper_refresh_cmd()</code>","text":"<p>Print shell commands to refresh wrappers in current shell.</p> <p>Outputs bash/zsh code that clears old wrapper functions and regenerates them from the latest state_cache.json. Run this after modifying prefixes.yaml and reloading the daemon.</p> Example <pre><code># After editing prefixes.yaml:\n$ axium daemon reload\n$ eval \"$(axium wrapper refresh)\"\n# Wrappers now reflect new prefix rules\n\n# Or in one line:\n$ axium daemon reload &amp;&amp; eval \"$(axium wrapper refresh)\"\n</code></pre> Usage <p>The output must be eval'd to take effect in your current shell. Simply running this command will only print the code, not execute it.</p> What it does <ol> <li>Unsets all previously wrapped command functions</li> <li>Reads latest wrapped commands from state_cache.json</li> <li>Creates new wrapper functions for each command</li> </ol> Note <p>This requires Axium shell integration to be loaded (i.e., bash/init.sh must be sourced in your shell config).</p> Source code in <code>axium/core/cli.py</code> <pre><code>@wrapper_app.command(\"refresh\")\ndef wrapper_refresh_cmd() -&gt; None:\n    \"\"\"\n    Print shell commands to refresh wrappers in current shell.\n\n    Outputs bash/zsh code that clears old wrapper functions and\n    regenerates them from the latest state_cache.json. Run this\n    after modifying prefixes.yaml and reloading the daemon.\n\n    Example:\n        ```bash\n        # After editing prefixes.yaml:\n        $ axium daemon reload\n        $ eval \"$(axium wrapper refresh)\"\n        # Wrappers now reflect new prefix rules\n\n        # Or in one line:\n        $ axium daemon reload &amp;&amp; eval \"$(axium wrapper refresh)\"\n        ```\n\n    Usage:\n        The output must be eval'd to take effect in your current shell.\n        Simply running this command will only print the code, not execute it.\n\n    What it does:\n        1. Unsets all previously wrapped command functions\n        2. Reads latest wrapped commands from state_cache.json\n        3. Creates new wrapper functions for each command\n\n    Note:\n        This requires Axium shell integration to be loaded\n        (i.e., bash/init.sh must be sourced in your shell config).\n    \"\"\"\n    print(\"axium_refresh_wrappers 2&gt;/dev/null\")\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.wrapper_clear_cmd","title":"<code>wrapper_clear_cmd()</code>","text":"<p>Print shell commands to remove all wrapper functions.</p> <p>Outputs bash/zsh code that unsets all wrapper functions, restoring original command behavior. Useful for debugging or temporarily disabling Axium's command wrapping.</p> Example <pre><code>$ eval \"$(axium wrapper clear)\"\n# All wrapper functions removed\n\n$ aws --version\n# Now runs /usr/local/bin/aws directly, not through axium run\n</code></pre> Usage <p>The output must be eval'd to take effect in your current shell.</p> What it does <p>Unsets all tracked wrapper functions (from $AXIUM_WRAPPED_COMMANDS), allowing you to call the original commands directly.</p> Note <p>To re-enable wrappers after clearing, run: $ eval \"$(axium wrapper refresh)\"</p> Source code in <code>axium/core/cli.py</code> <pre><code>@wrapper_app.command(\"clear\")\ndef wrapper_clear_cmd() -&gt; None:\n    \"\"\"\n    Print shell commands to remove all wrapper functions.\n\n    Outputs bash/zsh code that unsets all wrapper functions, restoring\n    original command behavior. Useful for debugging or temporarily\n    disabling Axium's command wrapping.\n\n    Example:\n        ```bash\n        $ eval \"$(axium wrapper clear)\"\n        # All wrapper functions removed\n\n        $ aws --version\n        # Now runs /usr/local/bin/aws directly, not through axium run\n        ```\n\n    Usage:\n        The output must be eval'd to take effect in your current shell.\n\n    What it does:\n        Unsets all tracked wrapper functions (from $AXIUM_WRAPPED_COMMANDS),\n        allowing you to call the original commands directly.\n\n    Note:\n        To re-enable wrappers after clearing, run:\n        $ eval \"$(axium wrapper refresh)\"\n    \"\"\"\n    print(\"axium_clear_wrappers 2&gt;/dev/null\")\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.bootstrap","title":"<code>bootstrap(force=typer.Option(False, '--force', '-f', help='Force update shell integration scripts (bash/init.sh, tmux/init.sh)'))</code>","text":"<p>Initialize or update Axium configuration.</p> <p>Creates ~/.config/axium/ with default configuration files if missing. Use --force to update shell integration scripts even if they exist.</p> <p>Silent on success (use --verbose for details), shows errors only.</p> Example <pre><code>$ axium bootstrap             # Silent success\n$ echo $?                      # 0\n\n$ axium bootstrap --verbose\n\u2713 Axium config initialized at ~/.config/axium\n\n$ axium bootstrap --force -v\n\u2713 Shell integration scripts updated\n</code></pre> Note <p>User config files (envs.yaml, prefixes.yaml, state.json) are never overwritten, even with --force.</p> Source code in <code>axium/core/cli.py</code> <pre><code>@app.command()\ndef bootstrap(\n    force: bool = typer.Option(\n        False,\n        \"--force\",\n        \"-f\",\n        help=\"Force update shell integration scripts (bash/init.sh, tmux/init.sh)\",\n    ),\n) -&gt; None:\n    \"\"\"\n    Initialize or update Axium configuration.\n\n    Creates ~/.config/axium/ with default configuration files if missing.\n    Use --force to update shell integration scripts even if they exist.\n\n    Silent on success (use --verbose for details), shows errors only.\n\n    Example:\n        ```bash\n        $ axium bootstrap             # Silent success\n        $ echo $?                      # 0\n\n        $ axium bootstrap --verbose\n        \u2713 Axium config initialized at ~/.config/axium\n\n        $ axium bootstrap --force -v\n        \u2713 Shell integration scripts updated\n        ```\n\n    Note:\n        User config files (envs.yaml, prefixes.yaml, state.json) are\n        never overwritten, even with --force.\n    \"\"\"\n    from axium.core import bootstrap as bootstrap_module\n\n    if force:\n        # Force update init scripts\n        bootstrap_module.update_init_scripts()\n        if is_verbose():\n            print(\"\u2713 Shell integration scripts updated\")\n            print(f\"  - {bootstrap_module.BASH_INIT_PATH}\")\n            print(f\"  - {bootstrap_module.TMUX_INIT_PATH}\")\n    else:\n        # Normal bootstrap\n        initialized = bootstrap_module.ensure_axium_config()\n        if is_verbose():\n            if initialized:\n                print(f\"\u2713 Axium config initialized at {bootstrap_module.CONF_DIR}\")\n                print(\n                    \"\\nTo enable shell integration, add to your ~/.bashrc or ~/.zshrc:\"\n                )\n                print(f\"  source {bootstrap_module.BASH_INIT_PATH}\")\n            else:\n                print(f\"\u2713 Axium config already exists at {bootstrap_module.CONF_DIR}\")\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.spoke_new","title":"<code>spoke_new(name=typer.Argument(..., help='Name of the new spoke (lowercase, no spaces)'), description=typer.Option(None, '--description', '-d', help='Short description of the spoke'), version=typer.Option('0.1.0', '--version', '-v', help='Initial version'), interactive=typer.Option(True, '--interactive/--no-interactive', help='Prompt for values interactively'))</code>","text":"<p>Create a new Spoke with scaffolded structure.</p> <p>Generates a new Spoke directory in ~/.config/axium/spokes// with: - spoke.yaml manifest - main.py with register() template - Basic directory structure Example <pre><code>$ axium spoke new my-spoke\n$ axium spoke new aws --description \"AWS operations\" --version 1.0.0\n</code></pre> Source code in <code>axium/core/cli.py</code> <pre><code>@spoke_app.command(\"new\")\ndef spoke_new(\n    name: str = typer.Argument(\n        ..., help=\"Name of the new spoke (lowercase, no spaces)\"\n    ),\n    description: str = typer.Option(\n        None, \"--description\", \"-d\", help=\"Short description of the spoke\"\n    ),\n    version: str = typer.Option(\"0.1.0\", \"--version\", \"-v\", help=\"Initial version\"),\n    interactive: bool = typer.Option(\n        True, \"--interactive/--no-interactive\", help=\"Prompt for values interactively\"\n    ),\n) -&gt; None:\n    \"\"\"\n    Create a new Spoke with scaffolded structure.\n\n    Generates a new Spoke directory in ~/.config/axium/spokes/&lt;name&gt;/ with:\n    - spoke.yaml manifest\n    - main.py with register() template\n    - Basic directory structure\n\n    Example:\n        ```bash\n        $ axium spoke new my-spoke\n        $ axium spoke new aws --description \"AWS operations\" --version 1.0.0\n        ```\n    \"\"\"\n    from axium.core.spokes import create_spoke\n\n    try:\n        spoke_path = create_spoke(\n            name=name,\n            description=description,\n            version=version,\n            interactive=interactive,\n        )\n        if is_verbose():\n            print(f\"\\n\u2713 Created new Spoke: {name}\")\n            print(f\"  Location: {spoke_path}\")\n            print(f\"\\nNext steps:\")\n            print(f\"  1. Edit {spoke_path / 'main.py'} to add commands\")\n            print(f\"  2. Run: axium spoke reload {name}\")\n    except Exception as e:\n        import sys\n\n        print(f\"\u2717 Failed to create spoke: {e}\", file=sys.stderr)\n        raise typer.Exit(code=1)\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.spoke_install","title":"<code>spoke_install(source=typer.Argument(..., help='Source path (local path, git URL, or registry name)'), editable=typer.Option(False, '--editable', '-e', help='Install as symlink for development'), name=typer.Option(None, '--name', '-n', help='Override spoke name'))</code>","text":"<p>Install a Spoke from source.</p> <p>Supports: - Local paths: /path/to/my-spoke or ~/spokes/my-spoke - Git URLs: git+https://github.com/user/spoke.git (future) - Registry: my-spoke (future)</p> <p>Installation modes: - Normal (copy): Copies spoke to ~/.config/axium/spokes// - Editable (symlink): Creates symlink for live development Example <pre><code>$ axium spoke install ~/dev/my-spoke\n$ axium spoke install ~/dev/my-spoke --editable\n$ axium spoke install ~/dev/my-spoke --name custom-name\n</code></pre> Source code in <code>axium/core/cli.py</code> <pre><code>@spoke_app.command(\"install\")\ndef spoke_install(\n    source: str = typer.Argument(\n        ..., help=\"Source path (local path, git URL, or registry name)\"\n    ),\n    editable: bool = typer.Option(\n        False, \"--editable\", \"-e\", help=\"Install as symlink for development\"\n    ),\n    name: str = typer.Option(None, \"--name\", \"-n\", help=\"Override spoke name\"),\n) -&gt; None:\n    \"\"\"\n    Install a Spoke from source.\n\n    Supports:\n    - Local paths: /path/to/my-spoke or ~/spokes/my-spoke\n    - Git URLs: git+https://github.com/user/spoke.git (future)\n    - Registry: my-spoke (future)\n\n    Installation modes:\n    - Normal (copy): Copies spoke to ~/.config/axium/spokes/&lt;name&gt;/\n    - Editable (symlink): Creates symlink for live development\n\n    Example:\n        ```bash\n        $ axium spoke install ~/dev/my-spoke\n        $ axium spoke install ~/dev/my-spoke --editable\n        $ axium spoke install ~/dev/my-spoke --name custom-name\n        ```\n    \"\"\"\n    from axium.core.spokes import install_spoke\n    from axium.core.api import spoke_reload_one\n\n    try:\n        metadata = install_spoke(source=source, editable=editable, name=name)\n        if is_verbose():\n            print(f\"\u2713 Installed: {metadata.name} v{metadata.version}\")\n            print(f\"  Mode: {metadata.install_mode}\")\n            print(f\"  Source: {metadata.source}\")\n            print(f\"  Loading spoke...\")\n\n        # Automatically reload the spoke to make it immediately available\n        reload_success = spoke_reload_one(metadata.name)\n        if reload_success:\n            if is_verbose():\n                print(f\"\u2713 Spoke loaded and ready to use\")\n        else:\n            if is_verbose():\n                print(\n                    f\"\u26a0 Spoke installed but failed to load. Try: axium spoke reload {metadata.name}\"\n                )\n    except Exception as e:\n        import sys\n\n        print(f\"\u2717 Installation failed: {e}\", file=sys.stderr)\n        raise typer.Exit(code=1)\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.spoke_reinstall","title":"<code>spoke_reinstall(name=typer.Argument(..., help='Spoke name to reinstall'))</code>","text":"<p>Reinstall a spoke from its original source.</p> <p>Preserves the installation mode (copy/symlink) and reinstalls from the original source location. Useful for updating spokes or fixing installation issues.</p> Example <pre><code>$ axium spoke reinstall creds\n\u2713 Reinstalled: creds v0.1.0\n\u2713 Spoke loaded and ready to use\n\n$ axium spoke reinstall aws\n\u2713 Reinstalled: aws v2.0.0 (upgraded from v1.5.0)\n\u2713 Spoke loaded and ready to use\n</code></pre> Source code in <code>axium/core/cli.py</code> <pre><code>@spoke_app.command(\"reinstall\")\ndef spoke_reinstall(\n    name: str = typer.Argument(..., help=\"Spoke name to reinstall\"),\n) -&gt; None:\n    \"\"\"\n    Reinstall a spoke from its original source.\n\n    Preserves the installation mode (copy/symlink) and reinstalls from\n    the original source location. Useful for updating spokes or fixing\n    installation issues.\n\n    Example:\n        ```bash\n        $ axium spoke reinstall creds\n        \u2713 Reinstalled: creds v0.1.0\n        \u2713 Spoke loaded and ready to use\n\n        $ axium spoke reinstall aws\n        \u2713 Reinstalled: aws v2.0.0 (upgraded from v1.5.0)\n        \u2713 Spoke loaded and ready to use\n        ```\n    \"\"\"\n    from axium.core.spokes import get_spoke_metadata, install_spoke\n    from axium.core.api import spoke_reload_one\n    import shutil\n\n    # Get current spoke metadata\n    spokes = get_spoke_metadata()\n    spoke_meta = next((s for s in spokes if s.name == name), None)\n\n    if not spoke_meta:\n        print(f\"\u2717 Spoke '{name}' is not installed\")\n        raise typer.Exit(1)\n\n    # Extract source path from metadata\n    source = spoke_meta.source\n    if source.startswith(\"local:\"):\n        source = source[6:]  # Remove \"local:\" prefix\n\n    install_mode = spoke_meta.install_mode\n    old_version = spoke_meta.version\n\n    try:\n        # Remove old installation\n        from axium.core.spokes import SPOKES_DIR\n\n        spoke_path = SPOKES_DIR / name\n        if spoke_path.exists():\n            if spoke_path.is_symlink():\n                spoke_path.unlink()\n            else:\n                shutil.rmtree(spoke_path)\n\n        # Reinstall with same mode\n        editable = install_mode == \"symlink\"\n        metadata = install_spoke(source=source, editable=editable, name=name)\n\n        if is_verbose():\n            if metadata.version != old_version:\n                print(\n                    f\"\u2713 Reinstalled: {metadata.name} v{metadata.version} (upgraded from v{old_version})\"\n                )\n            else:\n                print(f\"\u2713 Reinstalled: {metadata.name} v{metadata.version}\")\n            print(f\"  Mode: {metadata.install_mode}\")\n            print(f\"  Source: {metadata.source}\")\n            print(f\"  Loading spoke...\")\n\n        # Automatically reload the spoke\n        reload_success = spoke_reload_one(metadata.name)\n        if reload_success:\n            if is_verbose():\n                print(f\"\u2713 Spoke loaded and ready to use\")\n        else:\n            if is_verbose():\n                print(\n                    f\"\u26a0 Spoke reinstalled but failed to load. Try: axium spoke reload {metadata.name}\"\n                )\n\n    except Exception as e:\n        import sys\n\n        print(f\"\u2717 Reinstall failed: {e}\", file=sys.stderr)\n        raise typer.Exit(code=1)\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.spoke_list","title":"<code>spoke_list()</code>","text":"<p>List all installed Spokes with metadata.</p> <p>Displays: - Spoke name and version - Description - Installation mode (copy/symlink) - Load status (active/error/not-loaded) - Last loaded timestamp</p> Example <pre><code>$ axium spoke list\nInstalled Spokes:\n\naws (v1.0.0) [active]\n  AWS operations and utilities\n  Mode: copy | Last loaded: 2025-01-15 14:30:00\n\nk8s (v0.2.0) [not-loaded]\n  Kubernetes cluster management\n  Mode: symlink | Installed: 2025-01-10 09:15:00\n</code></pre> Source code in <code>axium/core/cli.py</code> <pre><code>@spoke_app.command(\"list\")\ndef spoke_list() -&gt; None:\n    \"\"\"\n    List all installed Spokes with metadata.\n\n    Displays:\n    - Spoke name and version\n    - Description\n    - Installation mode (copy/symlink)\n    - Load status (active/error/not-loaded)\n    - Last loaded timestamp\n\n    Example:\n        ```bash\n        $ axium spoke list\n        Installed Spokes:\n\n        aws (v1.0.0) [active]\n          AWS operations and utilities\n          Mode: copy | Last loaded: 2025-01-15 14:30:00\n\n        k8s (v0.2.0) [not-loaded]\n          Kubernetes cluster management\n          Mode: symlink | Installed: 2025-01-10 09:15:00\n        ```\n    \"\"\"\n    from axium.core.spokes import get_spoke_metadata\n\n    spokes = get_spoke_metadata()\n\n    if not spokes:\n        print(\"No Spokes installed.\")\n        print(\"\\nTry: axium spoke new &lt;name&gt;\")\n        return\n\n    print(\"Installed Spokes:\\n\")\n\n    for spoke in spokes:\n        status_icon = (\n            \"\u2713\"\n            if spoke.status == \"active\"\n            else (\"\u2717\" if spoke.status == \"error\" else \"\u25cb\")\n        )\n        print(f\"{status_icon} {spoke.name} (v{spoke.version}) [{spoke.status}]\")\n        print(f\"  {spoke.description}\")\n        print(f\"  Mode: {spoke.install_mode}\", end=\"\")\n\n        if spoke.last_loaded:\n            print(f\" | Last loaded: {spoke.last_loaded}\")\n        else:\n            print(f\" | Installed: {spoke.installed_at}\")\n\n        print()\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.spoke_reload","title":"<code>spoke_reload(name=typer.Argument(None, help='Spoke name to reload (omit to reload all)'))</code>","text":"<p>Reload spoke(s) without restarting daemon.</p> <p>Dynamically reloads spoke code and re-registers commands. Useful during development to test changes immediately.</p> Example <pre><code>$ axium spoke reload aws       # Reload specific spoke\n\u2713 Reloaded spoke: aws\n\n$ axium spoke reload           # Reload all spokes\n\u2713 Reloaded 3 spokes: creds, aws, system\n</code></pre> Source code in <code>axium/core/cli.py</code> <pre><code>@spoke_app.command(\"reload\")\ndef spoke_reload(\n    name: str = typer.Argument(None, help=\"Spoke name to reload (omit to reload all)\"),\n) -&gt; None:\n    \"\"\"\n    Reload spoke(s) without restarting daemon.\n\n    Dynamically reloads spoke code and re-registers commands.\n    Useful during development to test changes immediately.\n\n    Example:\n        ```bash\n        $ axium spoke reload aws       # Reload specific spoke\n        \u2713 Reloaded spoke: aws\n\n        $ axium spoke reload           # Reload all spokes\n        \u2713 Reloaded 3 spokes: creds, aws, system\n        ```\n    \"\"\"\n    from axium.core.api import spoke_reload_all, spoke_reload_one\n\n    if name:\n        # Reload specific spoke\n        ok = spoke_reload_one(name)\n        if ok:\n            if is_verbose():\n                print(f\"\u2713 Reloaded spoke: {name}\")\n            raise typer.Exit(code=0)\n        else:\n            import sys\n\n            print(f\"\u2717 Failed to reload spoke: {name}\", file=sys.stderr)\n            print(\n                \"  Ensure the daemon is running and the spoke exists\", file=sys.stderr\n            )\n            raise typer.Exit(code=1)\n    else:\n        # Reload all spokes\n        reloaded = spoke_reload_all()\n        if len(reloaded) &gt; 0:\n            if is_verbose():\n                print(\n                    f\"\u2713 Reloaded {len(reloaded)} spoke{'s' if len(reloaded) != 1 else ''}: {', '.join(reloaded)}\"\n                )\n            raise typer.Exit(code=0)\n        else:\n            import sys\n\n            print(\"\u2717 Failed to reload spokes\", file=sys.stderr)\n            print(\"  Ensure the daemon is running\", file=sys.stderr)\n            raise typer.Exit(code=1)\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.perms_list","title":"<code>perms_list()</code>","text":"<p>List all spokes with their effective permissions.</p> <p>Displays a table showing: - Spoke name - exec permission (\u2713 or \u2717) - notify permission (\u2713 or \u2717) - net permission (\u2713 or \u2717) - fs_read count - fs_write count</p> Example <pre><code>$ axium perms list\nSpoke Permissions:\n\ncreds     \u2713 exec  \u2713 notify  \u2717 net  fs_read: 2  fs_write: 0\nsystem    \u2717 exec  \u2717 notify  \u2717 net  fs_read: 0  fs_write: 0\n</code></pre> Source code in <code>axium/core/cli.py</code> <pre><code>@perms_app.command(\"list\")\ndef perms_list() -&gt; None:\n    \"\"\"\n    List all spokes with their effective permissions.\n\n    Displays a table showing:\n    - Spoke name\n    - exec permission (\u2713 or \u2717)\n    - notify permission (\u2713 or \u2717)\n    - net permission (\u2713 or \u2717)\n    - fs_read count\n    - fs_write count\n\n    Example:\n        ```bash\n        $ axium perms list\n        Spoke Permissions:\n\n        creds     \u2713 exec  \u2713 notify  \u2717 net  fs_read: 2  fs_write: 0\n        system    \u2717 exec  \u2717 notify  \u2717 net  fs_read: 0  fs_write: 0\n        ```\n    \"\"\"\n    from axium.core.spokes import get_spoke_metadata\n\n    try:\n        # Get all installed spokes\n        spokes = get_spoke_metadata()\n\n        if not spokes:\n            print(\"No spokes installed.\")\n            return\n\n        print(\"Spoke Permissions:\\n\")\n\n        # Query daemon for each spoke's permissions\n        for spoke in spokes:\n            try:\n                resp = send_request_sync(\n                    {\"cmd\": \"get_permissions\", \"spoke\": spoke.name}\n                )\n\n                if not resp.get(\"ok\"):\n                    print(f\"{spoke.name:&lt;12} (not loaded)\")\n                    continue\n\n                perms = resp[\"permissions\"]\n\n                # Format permission indicators\n                exec_icon = \"\u2713\" if perms.get(\"exec\") else \"\u2717\"\n                notify_icon = \"\u2713\" if perms.get(\"notify\") else \"\u2717\"\n                net_icon = \"\u2713\" if perms.get(\"net\") else \"\u2717\"\n                fs_read_count = len(perms.get(\"fs_read\", []))\n                fs_write_count = len(perms.get(\"fs_write\", []))\n\n                # Highlight overridden fields with color (future: use palette)\n                print(\n                    f\"{spoke.name:&lt;12} {exec_icon} exec  {notify_icon} notify  {net_icon} net  \"\n                    f\"fs_read: {fs_read_count}  fs_write: {fs_write_count}\"\n                )\n\n            except Exception as e:\n                print(f\"{spoke.name:&lt;12} (error: {e})\")\n\n    except Exception as e:\n        print(f\"\u2717 Failed to list permissions: {e}\")\n        raise typer.Exit(code=1)\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.perms_show","title":"<code>perms_show(spoke=typer.Argument(..., help='Spoke name'))</code>","text":"<p>Show detailed permissions for a spoke.</p> <p>Displays: - All permission fields with values - Source annotation (base/override/default) - Full list of fs_read and fs_write patterns</p> Example <pre><code>$ axium perms show creds\nPermissions for: creds\n\nexec: true (from override)\nnotify: true (from base)\nnet: false (from base)\nfs_read:\n  - ~/.aws/credentials (from base)\n  - /opt/company/creds.json (from override)\nfs_write: []\n</code></pre> Source code in <code>axium/core/cli.py</code> <pre><code>@perms_app.command(\"show\")\ndef perms_show(spoke: str = typer.Argument(..., help=\"Spoke name\")) -&gt; None:\n    \"\"\"\n    Show detailed permissions for a spoke.\n\n    Displays:\n    - All permission fields with values\n    - Source annotation (base/override/default)\n    - Full list of fs_read and fs_write patterns\n\n    Example:\n        ```bash\n        $ axium perms show creds\n        Permissions for: creds\n\n        exec: true (from override)\n        notify: true (from base)\n        net: false (from base)\n        fs_read:\n          - ~/.aws/credentials (from base)\n          - /opt/company/creds.json (from override)\n        fs_write: []\n        ```\n    \"\"\"\n    try:\n        resp = send_request_sync({\"cmd\": \"get_permissions\", \"spoke\": spoke})\n\n        if not resp.get(\"ok\"):\n            print(f\"\u2717 {resp.get('error', 'unknown error')}\")\n            raise typer.Exit(code=1)\n\n        perms = resp[\"permissions\"]\n        sources = resp.get(\"sources\", {})\n\n        print(f\"Permissions for: {spoke}\\n\")\n\n        # Boolean permissions\n        for field in [\"exec\", \"notify\", \"net\"]:\n            value = perms.get(field, False)\n            source = sources.get(field, \"default\")\n            print(f\"{field}: {value} (from {source})\")\n\n        # List permissions\n        print(f\"fs_read:\")\n        fs_read = perms.get(\"fs_read\", [])\n        if fs_read:\n            for path in fs_read:\n                source = sources.get(\"fs_read\", \"base\")\n                print(f\"  - {path} (from {source})\")\n        else:\n            print(\"  (none)\")\n\n        print(f\"fs_write:\")\n        fs_write = perms.get(\"fs_write\", [])\n        if fs_write:\n            for path in fs_write:\n                source = sources.get(\"fs_write\", \"base\")\n                print(f\"  - {path} (from {source})\")\n        else:\n            print(\"  (none)\")\n\n    except Exception as e:\n        print(f\"\u2717 Failed to get permissions: {e}\")\n        raise typer.Exit(code=1)\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.perms_edit","title":"<code>perms_edit(spoke=typer.Argument(..., help='Spoke name'))</code>","text":"<p>Edit user permission overrides for a spoke.</p> <p>Opens ~/.config/axium/permissions.yaml in $EDITOR. If file doesn't exist, prints example configuration to create.</p> Example <pre><code>$ axium perms edit creds\n# Opens editor at permissions.yaml\n\n$ axium perms edit newspoke\n# Prints example if file doesn't exist\n</code></pre> Source code in <code>axium/core/cli.py</code> <pre><code>@perms_app.command(\"edit\")\ndef perms_edit(spoke: str = typer.Argument(..., help=\"Spoke name\")) -&gt; None:\n    \"\"\"\n    Edit user permission overrides for a spoke.\n\n    Opens ~/.config/axium/permissions.yaml in $EDITOR.\n    If file doesn't exist, prints example configuration to create.\n\n    Example:\n        ```bash\n        $ axium perms edit creds\n        # Opens editor at permissions.yaml\n\n        $ axium perms edit newspoke\n        # Prints example if file doesn't exist\n        ```\n    \"\"\"\n    import os\n    import subprocess\n    from pathlib import Path\n\n    perms_path = Path.home() / \".config\" / \"axium\" / \"permissions.yaml\"\n\n    if not perms_path.exists():\n        # Print example\n        print(f\"Permissions file not found: {perms_path}\")\n        print(\"\\nCreate it with this template:\\n\")\n        print(\"---\")\n        print(f\"{spoke}:\")\n        print(\"  exec: true\")\n        print(\"  notify: true\")\n        print(\"  fs_read:\")\n        print(\"    - ~/path/to/file\")\n        print(\"  fs_write: []\")\n        print(\"---\")\n        print(f\"\\nThen run: $EDITOR {perms_path}\")\n        return\n\n    # Open in editor\n    editor = os.getenv(\"EDITOR\", \"vi\")\n    try:\n        subprocess.run([editor, str(perms_path)], check=True)\n        print(f\"\\n\u2713 Edited {perms_path}\")\n        print(f\"\\nReload spoke for changes to take effect:\")\n        print(f\"  axium spoke reload {spoke}\")\n    except subprocess.CalledProcessError:\n        print(f\"\u2717 Failed to open editor: {editor}\")\n        raise typer.Exit(code=1)\n    except FileNotFoundError:\n        print(f\"\u2717 Editor not found: {editor}\")\n        print(f\"\\nSet EDITOR environment variable or edit manually:\")\n        print(f\"  {perms_path}\")\n        raise typer.Exit(code=1)\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.gear_list","title":"<code>gear_list()</code>","text":"<p>List all installed Gears with metadata.</p> <p>Displays: - Gear name and version - Description - Installation mode (copy/symlink) - Load status (active/error/not-loaded) - Last loaded timestamp</p> Example <pre><code>$ axium gear list\nInstalled Gears:\n\nansible (v1.0.0) [active]\n  Ansible playbook automation with environment context\n  Mode: copy | Last loaded: 2025-01-15 14:30:00\n\nterraform (v0.2.0) [not-loaded]\n  Terraform workspace management\n  Mode: symlink | Installed: 2025-01-10 09:15:00\n</code></pre> Source code in <code>axium/core/cli.py</code> <pre><code>@gear_app.command(\"list\")\ndef gear_list() -&gt; None:\n    \"\"\"\n    List all installed Gears with metadata.\n\n    Displays:\n    - Gear name and version\n    - Description\n    - Installation mode (copy/symlink)\n    - Load status (active/error/not-loaded)\n    - Last loaded timestamp\n\n    Example:\n        ```bash\n        $ axium gear list\n        Installed Gears:\n\n        ansible (v1.0.0) [active]\n          Ansible playbook automation with environment context\n          Mode: copy | Last loaded: 2025-01-15 14:30:00\n\n        terraform (v0.2.0) [not-loaded]\n          Terraform workspace management\n          Mode: symlink | Installed: 2025-01-10 09:15:00\n        ```\n    \"\"\"\n    from axium.core.gears import get_gear_metadata\n\n    gears = get_gear_metadata()\n\n    if not gears:\n        print(\"No Gears installed.\")\n        print(\"\\nGears are privileged extensions in ~/.config/axium/gears/\")\n        return\n\n    print(\"Installed Gears:\\n\")\n\n    for gear in gears:\n        status_icon = (\n            \"\u2713\" if gear.status == \"active\" else (\"\u2717\" if gear.status == \"error\" else \"\u25cb\")\n        )\n        print(f\"{status_icon} {gear.name} (v{gear.version}) [{gear.status}]\")\n        if gear.description:\n            print(f\"  {gear.description}\")\n        print(f\"  Mode: {gear.install_mode}\", end=\"\")\n\n        if gear.last_loaded:\n            print(f\" | Last loaded: {gear.last_loaded}\")\n        else:\n            print(f\" | Installed: {gear.installed_at}\")\n\n        print()\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.gear_install","title":"<code>gear_install(source=typer.Argument(..., help='Source path (local directory)'), editable=typer.Option(False, '--editable', '-e', help='Install as symlink for development'), name=typer.Option(None, '--name', '-n', help='Override gear name'))</code>","text":"<p>Install a Gear from source.</p> <p>Supports local directory paths. Gears are privileged extensions installed to ~/.config/axium/gears//. <p>Installation modes: - Normal (copy): Copies gear files - Editable (symlink): Creates symlink for live development</p> Example <pre><code>$ axium gear install ~/dev/my-gear\n$ axium gear install ~/dev/my-gear --editable\n$ axium gear install ~/dev/my-gear --name custom-name\n</code></pre> Source code in <code>axium/core/cli.py</code> <pre><code>@gear_app.command(\"install\")\ndef gear_install(\n    source: str = typer.Argument(..., help=\"Source path (local directory)\"),\n    editable: bool = typer.Option(\n        False, \"--editable\", \"-e\", help=\"Install as symlink for development\"\n    ),\n    name: str = typer.Option(None, \"--name\", \"-n\", help=\"Override gear name\"),\n) -&gt; None:\n    \"\"\"\n    Install a Gear from source.\n\n    Supports local directory paths. Gears are privileged extensions\n    installed to ~/.config/axium/gears/&lt;name&gt;/.\n\n    Installation modes:\n    - Normal (copy): Copies gear files\n    - Editable (symlink): Creates symlink for live development\n\n    Example:\n        ```bash\n        $ axium gear install ~/dev/my-gear\n        $ axium gear install ~/dev/my-gear --editable\n        $ axium gear install ~/dev/my-gear --name custom-name\n        ```\n    \"\"\"\n    from axium.core.api import gear_install as api_gear_install, gear_reload_one\n\n    try:\n        metadata = api_gear_install(source=source, editable=editable, name=name)\n        if metadata:\n            if is_verbose():\n                print(f\"\u2713 Installed: {metadata['name']} v{metadata['version']}\")\n                print(f\"  Mode: {metadata['install_mode']}\")\n                print(f\"  Source: {metadata['source']}\")\n                print(f\"  Loading gear...\")\n\n            # Automatically reload the gear to make it immediately available\n            reload_success = gear_reload_one(metadata[\"name\"])\n            if reload_success:\n                if is_verbose():\n                    print(f\"\u2713 Gear loaded and ready to use\")\n            else:\n                if is_verbose():\n                    print(\n                        f\"\u26a0 Gear installed but failed to load. Try: axium gear reload {metadata['name']}\"\n                    )\n        else:\n            import sys\n\n            print(\"\u2717 Installation failed\", file=sys.stderr)\n            raise typer.Exit(code=1)\n    except Exception as e:\n        import sys\n\n        print(f\"\u2717 Installation failed: {e}\", file=sys.stderr)\n        raise typer.Exit(code=1)\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.gear_reinstall","title":"<code>gear_reinstall(name=typer.Argument(..., help='Gear name to reinstall'))</code>","text":"<p>Reinstall a gear from its original source.</p> <p>Preserves the installation mode (copy/symlink) and reinstalls from the original source location. Useful for updating gears or fixing installation issues.</p> Example <pre><code>$ axium gear reinstall web\n\u2713 Reinstalled: web v0.1.0\n\u2713 Gear loaded and ready to use\n\n$ axium gear reinstall ansible\n\u2713 Reinstalled: ansible v1.1.0 (upgraded from v1.0.0)\n\u2713 Gear loaded and ready to use\n</code></pre> Source code in <code>axium/core/cli.py</code> <pre><code>@gear_app.command(\"reinstall\")\ndef gear_reinstall(\n    name: str = typer.Argument(..., help=\"Gear name to reinstall\"),\n) -&gt; None:\n    \"\"\"\n    Reinstall a gear from its original source.\n\n    Preserves the installation mode (copy/symlink) and reinstalls from\n    the original source location. Useful for updating gears or fixing\n    installation issues.\n\n    Example:\n        ```bash\n        $ axium gear reinstall web\n        \u2713 Reinstalled: web v0.1.0\n        \u2713 Gear loaded and ready to use\n\n        $ axium gear reinstall ansible\n        \u2713 Reinstalled: ansible v1.1.0 (upgraded from v1.0.0)\n        \u2713 Gear loaded and ready to use\n        ```\n    \"\"\"\n    from axium.core.gears import get_gear_metadata\n    from axium.core.api import gear_install as api_gear_install, gear_reload_one\n    import shutil\n\n    # Get current gear metadata\n    gears = get_gear_metadata()\n    gear_meta = next((g for g in gears if g.name == name), None)\n\n    if not gear_meta:\n        print(f\"\u2717 Gear '{name}' is not installed\")\n        raise typer.Exit(1)\n\n    # Extract source path from metadata\n    source = gear_meta.source\n    if source.startswith(\"local:\"):\n        source = source[6:]  # Remove \"local:\" prefix\n\n    install_mode = gear_meta.install_mode\n    old_version = gear_meta.version\n\n    try:\n        # Remove old installation\n        from axium.core.gears import GEARS_DIR\n\n        gear_path = GEARS_DIR / name\n        if gear_path.exists():\n            if gear_path.is_symlink():\n                gear_path.unlink()\n            else:\n                shutil.rmtree(gear_path)\n\n        # Reinstall with same mode\n        editable = install_mode == \"symlink\"\n        metadata = api_gear_install(source=source, editable=editable, name=name)\n\n        if metadata:\n            if is_verbose():\n                if metadata[\"version\"] != old_version:\n                    print(\n                        f\"\u2713 Reinstalled: {metadata['name']} v{metadata['version']} (upgraded from v{old_version})\"\n                    )\n                else:\n                    print(f\"\u2713 Reinstalled: {metadata['name']} v{metadata['version']}\")\n                print(f\"  Mode: {metadata['install_mode']}\")\n                print(f\"  Source: {metadata['source']}\")\n                print(f\"  Loading gear...\")\n\n            # Automatically reload the gear\n            reload_success = gear_reload_one(metadata[\"name\"])\n            if reload_success:\n                if is_verbose():\n                    print(f\"\u2713 Gear loaded and ready to use\")\n            else:\n                if is_verbose():\n                    print(\n                        f\"\u26a0 Gear reinstalled but failed to load. Try: axium gear reload {metadata['name']}\"\n                    )\n        else:\n            import sys\n\n            print(\"\u2717 Reinstall failed\", file=sys.stderr)\n            raise typer.Exit(code=1)\n\n    except Exception as e:\n        import sys\n\n        print(f\"\u2717 Reinstall failed: {e}\", file=sys.stderr)\n        raise typer.Exit(code=1)\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.gear_uninstall","title":"<code>gear_uninstall(name=typer.Argument(..., help='Gear name to uninstall'), force=typer.Option(False, '--force', '-f', help='Skip confirmation'))</code>","text":"<p>Uninstall a Gear.</p> <p>Removes the gear directory and cleans up metadata and permission overrides.</p> Example <pre><code>$ axium gear uninstall my-gear\nUninstall gear 'my-gear'? [y/N]: y\n\u2713 Uninstalled gear: my-gear\n\n$ axium gear uninstall my-gear --force\n\u2713 Uninstalled gear: my-gear\n</code></pre> Source code in <code>axium/core/cli.py</code> <pre><code>@gear_app.command(\"uninstall\")\ndef gear_uninstall(\n    name: str = typer.Argument(..., help=\"Gear name to uninstall\"),\n    force: bool = typer.Option(False, \"--force\", \"-f\", help=\"Skip confirmation\"),\n) -&gt; None:\n    \"\"\"\n    Uninstall a Gear.\n\n    Removes the gear directory and cleans up metadata and permission overrides.\n\n    Example:\n        ```bash\n        $ axium gear uninstall my-gear\n        Uninstall gear 'my-gear'? [y/N]: y\n        \u2713 Uninstalled gear: my-gear\n\n        $ axium gear uninstall my-gear --force\n        \u2713 Uninstalled gear: my-gear\n        ```\n    \"\"\"\n    from axium.core.api import gear_uninstall as api_gear_uninstall\n\n    try:\n        ok = api_gear_uninstall(name, force=force)\n        if ok:\n            if is_verbose():\n                print(f\"\u2713 Uninstalled gear: {name}\")\n            raise typer.Exit(code=0)\n        else:\n            import sys\n\n            print(f\"\u2717 Failed to uninstall gear: {name}\", file=sys.stderr)\n            raise typer.Exit(code=1)\n    except Exception as e:\n        import sys\n\n        print(f\"\u2717 Uninstall failed: {e}\", file=sys.stderr)\n        raise typer.Exit(code=1)\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.gear_reload","title":"<code>gear_reload(name=typer.Argument(None, help='Gear name to reload (omit to reload all)'))</code>","text":"<p>Reload gear(s) without restarting daemon.</p> <p>Dynamically reloads gear code and re-registers commands. Useful during development to test changes immediately.</p> Example <pre><code>$ axium gear reload ansible      # Reload specific gear\n\u2713 Reloaded gear: ansible\n\n$ axium gear reload              # Reload all gears\n\u2713 Reloaded 2 gears: ansible, axium-gear-web\n</code></pre> Source code in <code>axium/core/cli.py</code> <pre><code>@gear_app.command(\"reload\")\ndef gear_reload(\n    name: str = typer.Argument(None, help=\"Gear name to reload (omit to reload all)\"),\n) -&gt; None:\n    \"\"\"\n    Reload gear(s) without restarting daemon.\n\n    Dynamically reloads gear code and re-registers commands.\n    Useful during development to test changes immediately.\n\n    Example:\n        ```bash\n        $ axium gear reload ansible      # Reload specific gear\n        \u2713 Reloaded gear: ansible\n\n        $ axium gear reload              # Reload all gears\n        \u2713 Reloaded 2 gears: ansible, axium-gear-web\n        ```\n    \"\"\"\n    from axium.core.api import gear_reload_all, gear_reload_one\n\n    if name:\n        # Reload specific gear\n        ok = gear_reload_one(name)\n        if ok:\n            if is_verbose():\n                print(f\"\u2713 Reloaded gear: {name}\")\n            raise typer.Exit(code=0)\n        else:\n            import sys\n\n            print(f\"\u2717 Failed to reload gear: {name}\", file=sys.stderr)\n            print(\"  Ensure the gear exists and is properly installed\", file=sys.stderr)\n            raise typer.Exit(code=1)\n    else:\n        # Reload all gears\n        reloaded = gear_reload_all()\n        if len(reloaded) &gt; 0:\n            if is_verbose():\n                print(\n                    f\"\u2713 Reloaded {len(reloaded)} gear{'s' if len(reloaded) != 1 else ''}: {', '.join(reloaded)}\"\n                )\n            raise typer.Exit(code=0)\n        else:\n            import sys\n\n            print(\"\u2717 Failed to reload gears\", file=sys.stderr)\n            print(\"  No gears installed or all reloads failed\", file=sys.stderr)\n            raise typer.Exit(code=1)\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.gear_perms_show","title":"<code>gear_perms_show(gear=typer.Argument(..., help='Gear name'))</code>","text":"<p>Show effective permissions for a gear.</p> <p>Displays base permissions from gear.yaml merged with user overrides from overrides/permissions/.yaml. Example <pre><code>$ axium gear perms-show ansible\nGear: ansible\n\nPermissions:\n  exec: \u2713 (base)\n  notify: \u2717\n  net: \u2713 (override)\n  ipc: 3 actions\n    - tmux_split_run (base)\n    - read_file (base)\n    - write_file (base)\n  fs_read: 2 patterns\n    - ~/.ssh/config (override)\n    - ~/ansible/** (base)\n  fs_write: 1 pattern\n    - ~/ansible/logs/** (base)\n</code></pre> Source code in <code>axium/core/cli.py</code> <pre><code>@gear_app.command(\"perms-show\")\ndef gear_perms_show(gear: str = typer.Argument(..., help=\"Gear name\")) -&gt; None:\n    \"\"\"\n    Show effective permissions for a gear.\n\n    Displays base permissions from gear.yaml merged with user overrides\n    from overrides/permissions/&lt;gear&gt;.yaml.\n\n    Example:\n        ```bash\n        $ axium gear perms-show ansible\n        Gear: ansible\n\n        Permissions:\n          exec: \u2713 (base)\n          notify: \u2717\n          net: \u2713 (override)\n          ipc: 3 actions\n            - tmux_split_run (base)\n            - read_file (base)\n            - write_file (base)\n          fs_read: 2 patterns\n            - ~/.ssh/config (override)\n            - ~/ansible/** (base)\n          fs_write: 1 pattern\n            - ~/ansible/logs/** (base)\n        ```\n    \"\"\"\n    from axium.core.gears import GEARS_DIR, get_effective_gear_permissions\n\n    gear_path = GEARS_DIR / gear\n    gear_yaml = gear_path / \"gear.yaml\"\n\n    if not gear_yaml.exists():\n        print(f\"\u2717 Gear not found: {gear}\")\n        print(f\"  Expected: {gear_yaml}\")\n        raise typer.Exit(code=1)\n\n    try:\n        perms = get_effective_gear_permissions(gear, gear_yaml)\n    except Exception as e:\n        print(f\"\u2717 Failed to load permissions: {e}\")\n        raise typer.Exit(code=1)\n\n    print(f\"Gear: {gear}\\n\")\n    print(\"Permissions:\")\n\n    # Helper to show source\n    def src(field):\n        s = perms.get_source(field)\n        return f\" ({s})\" if s else \"\"\n\n    print(f\"  exec: {'\u2713' if perms.exec else '\u2717'}{src('exec')}\")\n    print(f\"  notify: {'\u2713' if perms.notify else '\u2717'}{src('notify')}\")\n    print(f\"  net: {'\u2713' if perms.net else '\u2717'}{src('net')}\")\n\n    if perms.ipc:\n        print(\n            f\"  ipc: {len(perms.ipc)} action{'s' if len(perms.ipc) != 1 else ''}{src('ipc')}\"\n        )\n        for action in perms.ipc:\n            print(f\"    - {action}\")\n    else:\n        print(f\"  ipc: none\")\n\n    if perms.fs_read:\n        print(\n            f\"  fs_read: {len(perms.fs_read)} pattern{'s' if len(perms.fs_read) != 1 else ''}{src('fs_read')}\"\n        )\n        for pattern in perms.fs_read:\n            print(f\"    - {pattern}\")\n    else:\n        print(f\"  fs_read: none\")\n\n    if perms.fs_write:\n        print(\n            f\"  fs_write: {len(perms.fs_write)} pattern{'s' if len(perms.fs_write) != 1 else ''}{src('fs_write')}\"\n        )\n        for pattern in perms.fs_write:\n            print(f\"    - {pattern}\")\n    else:\n        print(f\"  fs_write: none\")\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.gear_perms_edit","title":"<code>gear_perms_edit(gear=typer.Argument(..., help='Gear name'))</code>","text":"<p>Edit user permission overrides for a gear.</p> <p>Opens ~/.config/axium/overrides/permissions/.yaml in $EDITOR. If file doesn't exist, creates it with template from gear's base permissions. Example <pre><code>$ axium gear perms-edit ansible\n# Opens editor at overrides/permissions/ansible.yaml\n\n$ axium gear perms-edit newgear\n# Creates template file and opens editor\n</code></pre> Source code in <code>axium/core/cli.py</code> <pre><code>@gear_app.command(\"perms-edit\")\ndef gear_perms_edit(gear: str = typer.Argument(..., help=\"Gear name\")) -&gt; None:\n    \"\"\"\n    Edit user permission overrides for a gear.\n\n    Opens ~/.config/axium/overrides/permissions/&lt;gear&gt;.yaml in $EDITOR.\n    If file doesn't exist, creates it with template from gear's base permissions.\n\n    Example:\n        ```bash\n        $ axium gear perms-edit ansible\n        # Opens editor at overrides/permissions/ansible.yaml\n\n        $ axium gear perms-edit newgear\n        # Creates template file and opens editor\n        ```\n    \"\"\"\n    import os\n    import subprocess\n    from pathlib import Path\n    from axium.core.gears import GEARS_DIR\n\n    overrides_dir = Path.home() / \".config\" / \"axium\" / \"overrides\" / \"permissions\"\n    overrides_dir.mkdir(parents=True, exist_ok=True)\n\n    override_file = overrides_dir / f\"{gear}.yaml\"\n    gear_yaml = GEARS_DIR / gear / \"gear.yaml\"\n\n    # Create template if doesn't exist\n    if not override_file.exists():\n        if not gear_yaml.exists():\n            print(f\"\u2717 Gear not found: {gear}\")\n            print(f\"  Expected: {gear_yaml}\")\n            raise typer.Exit(code=1)\n\n        # Create template\n        override_file.write_text(\n            f\"\"\"# Permission overrides for gear: {gear}\n# See base permissions in: {gear_yaml}\n#\n# Uncomment and modify as needed:\n# exec: true\n# notify: false\n# net: true\n# ipc:\n#   - tmux_split_run\n#   - read_file\n#   - write_file\n# fs_read:\n#   - ~/some/path/**\n# fs_write:\n#   - ~/some/other/path/**\n\"\"\"\n        )\n        print(f\"\u2713 Created template: {override_file}\")\n\n    # Open in editor\n    editor = os.getenv(\"EDITOR\", \"vi\")\n    try:\n        subprocess.run([editor, str(override_file)], check=True)\n        print(f\"\\n\u2713 Edited {override_file}\")\n        print(f\"\\nReload daemon for changes to take effect:\")\n        print(f\"  axium daemon reload\")\n    except subprocess.CalledProcessError:\n        print(f\"\u2717 Failed to open editor: {editor}\")\n        raise typer.Exit(code=1)\n    except FileNotFoundError:\n        print(f\"\u2717 Editor not found: {editor}\")\n        print(f\"\\nSet EDITOR environment variable or edit manually:\")\n        print(f\"  {override_file}\")\n        raise typer.Exit(code=1)\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.notify_drain","title":"<code>notify_drain()</code>","text":"<p>Print and clear queued notifications.</p> <p>Retrieves all notifications from the daemon's queue and clears it. Useful for checking notifications emitted by spokes.</p> Example <pre><code>$ axium notify drain\nQueued Notifications (2):\n\n[2025-10-07 16:30:00] creds: Credentials expired\n  Run: aws sso login or 'axium creds refresh'\n\n[2025-10-07 16:31:15] system: Update available\n  Run: axium update\n</code></pre> Source code in <code>axium/core/cli.py</code> <pre><code>@notify_app.command(\"drain\")\ndef notify_drain() -&gt; None:\n    \"\"\"\n    Print and clear queued notifications.\n\n    Retrieves all notifications from the daemon's queue and clears it.\n    Useful for checking notifications emitted by spokes.\n\n    Example:\n        ```bash\n        $ axium notify drain\n        Queued Notifications (2):\n\n        [2025-10-07 16:30:00] creds: Credentials expired\n          Run: aws sso login or 'axium creds refresh'\n\n        [2025-10-07 16:31:15] system: Update available\n          Run: axium update\n        ```\n    \"\"\"\n    try:\n        resp = send_request_sync({\"cmd\": \"notify_drain\"})\n\n        if not resp.get(\"ok\"):\n            print(f\"\u2717 {resp.get('error', 'unknown error')}\")\n            raise typer.Exit(code=1)\n\n        notifications = resp.get(\"notifications\", [])\n\n        if not notifications:\n            print(\"No queued notifications.\")\n            return\n\n        print(f\"Queued Notifications ({len(notifications)}):\\n\")\n\n        for notif in notifications:\n            timestamp = notif.get(\"timestamp\", \"\")\n            spoke = notif.get(\"spoke\", \"unknown\")\n            title = notif.get(\"title\", \"\")\n            body = notif.get(\"body\", \"\")\n\n            # Format timestamp (remove Z, just show date/time)\n            ts_display = timestamp.replace(\"T\", \" \").replace(\"Z\", \"\").split(\".\")[0]\n\n            print(f\"[{ts_display}] {spoke}: {title}\")\n            if body:\n                print(f\"  {body}\")\n            print()\n\n    except Exception as e:\n        print(f\"\u2717 Failed to drain notifications: {e}\")\n        raise typer.Exit(code=1)\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.notify_send","title":"<code>notify_send(title=typer.Option(..., '--title', '-t', help='Notification title'), body=typer.Option('', '--body', '-b', help='Notification body'), level=typer.Option('info', '--level', '-l', help='Notification level'))</code>","text":"<p>Send test notification via daemon.</p> <p>Sends notification using \"core\" fake spoke identity for testing. Requires notify permission (granted by default for core).</p> Example <pre><code>$ axium notify send --title \"Test\" --body \"Hello world\"\n(silent on success)\n\n$ axium notify send -t \"Alert\" -b \"Something happened\" -l warning\n(silent on success)\n</code></pre> Source code in <code>axium/core/cli.py</code> <pre><code>@notify_app.command(\"send\")\ndef notify_send(\n    title: str = typer.Option(..., \"--title\", \"-t\", help=\"Notification title\"),\n    body: str = typer.Option(\"\", \"--body\", \"-b\", help=\"Notification body\"),\n    level: str = typer.Option(\"info\", \"--level\", \"-l\", help=\"Notification level\"),\n) -&gt; None:\n    \"\"\"\n    Send test notification via daemon.\n\n    Sends notification using \"core\" fake spoke identity for testing.\n    Requires notify permission (granted by default for core).\n\n    Example:\n        ```bash\n        $ axium notify send --title \"Test\" --body \"Hello world\"\n        (silent on success)\n\n        $ axium notify send -t \"Alert\" -b \"Something happened\" -l warning\n        (silent on success)\n        ```\n    \"\"\"\n    from axium.core.api import notify_send_cli\n    from axium.core.cli_util import run_and_exit_ok\n\n    run_and_exit_ok(lambda: notify_send_cli(\"core\", title, body, level))\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.notify_list","title":"<code>notify_list()</code>","text":"<p>List queued notifications without clearing them.</p> <p>Non-destructive read of notification queue. Use 'axium notify drain' to list and clear in one operation.</p> Example <pre><code>$ axium notify list\nQueued Notifications (2):\n\n[2025-10-13 17:30:00] warning - creds: Credentials expired\n  Run: aws sso login\n\n[2025-10-13 17:31:15] info - system: Update available\n  Run: axium update\n</code></pre> Source code in <code>axium/core/cli.py</code> <pre><code>@notify_app.command(\"list\")\ndef notify_list() -&gt; None:\n    \"\"\"\n    List queued notifications without clearing them.\n\n    Non-destructive read of notification queue. Use 'axium notify drain'\n    to list and clear in one operation.\n\n    Example:\n        ```bash\n        $ axium notify list\n        Queued Notifications (2):\n\n        [2025-10-13 17:30:00] warning - creds: Credentials expired\n          Run: aws sso login\n\n        [2025-10-13 17:31:15] info - system: Update available\n          Run: axium update\n        ```\n    \"\"\"\n    from axium.core.api import drain_notifications\n\n    # Note: Currently daemon only supports drain (removes after read)\n    # This command drains but we could add a non-destructive peek in future\n    notifications = drain_notifications()\n\n    if not notifications:\n        print(\"No queued notifications.\")\n        return\n\n    print(f\"Queued Notifications ({len(notifications)}):\\n\")\n\n    for notif in notifications:\n        timestamp = notif.get(\"timestamp\", \"\")\n        spoke = notif.get(\"spoke\", \"unknown\")\n        title = notif.get(\"title\", \"\")\n        body = notif.get(\"body\", \"\")\n        level = notif.get(\"level\", \"info\")\n\n        # Format timestamp\n        ts_display = timestamp.replace(\"T\", \" \").replace(\"Z\", \"\").split(\".\")[0]\n\n        print(f\"[{ts_display}] {level} - {spoke}: {title}\")\n        if body:\n            print(f\"  {body}\")\n        print()\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.notify_clear","title":"<code>notify_clear()</code>","text":"<p>Clear all queued notifications.</p> <p>Silent on success (follows silent-core pattern). Use --verbose to see confirmation message.</p> Example <pre><code>$ axium notify clear\n$ echo $?\n0\n\n$ axium notify clear --verbose\n\u2713 Cleared notification queue\n</code></pre> Source code in <code>axium/core/cli.py</code> <pre><code>@notify_app.command(\"clear\")\ndef notify_clear() -&gt; None:\n    \"\"\"\n    Clear all queued notifications.\n\n    Silent on success (follows silent-core pattern).\n    Use --verbose to see confirmation message.\n\n    Example:\n        ```bash\n        $ axium notify clear\n        $ echo $?\n        0\n\n        $ axium notify clear --verbose\n        \u2713 Cleared notification queue\n        ```\n    \"\"\"\n    from axium.core.api import clear_notifications\n\n    success = clear_notifications()\n    if success:\n        if is_verbose():\n            print(\"\u2713 Cleared notification queue\")\n    else:\n        import sys\n\n        print(\"\u2717 Failed to clear notifications\", file=sys.stderr)\n        raise typer.Exit(code=1)\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.config_path","title":"<code>config_path(spoke=typer.Argument(..., help=\"Spoke name (e.g., 'creds')\"))</code>","text":"<p>Show configuration file paths for a spoke.</p> <p>Displays the base config path (bundled with spoke) and override path (in ~/.config/axium/overrides/). Indicates which files exist.</p> Example <pre><code>$ axium config path creds\nBase config (bundled):\n  ~/.config/axium/spokes/creds/creds.yaml \u2713\n\nOverride config (user editable):\n  ~/.config/axium/overrides/creds.yaml \u2717 (not found)\n\nTo create override: axium config edit creds\n</code></pre> Source code in <code>axium/core/cli.py</code> <pre><code>@config_app.command(\"path\")\ndef config_path(\n    spoke: str = typer.Argument(..., help=\"Spoke name (e.g., 'creds')\")\n) -&gt; None:\n    \"\"\"\n    Show configuration file paths for a spoke.\n\n    Displays the base config path (bundled with spoke) and override path\n    (in ~/.config/axium/overrides/). Indicates which files exist.\n\n    Example:\n        ```bash\n        $ axium config path creds\n        Base config (bundled):\n          ~/.config/axium/spokes/creds/creds.yaml \u2713\n\n        Override config (user editable):\n          ~/.config/axium/overrides/creds.yaml \u2717 (not found)\n\n        To create override: axium config edit creds\n        ```\n    \"\"\"\n    from axium.core.config import get_config_paths\n\n    try:\n        base_path, override_path = get_config_paths(spoke)\n\n        print(\"Base config (bundled):\")\n        if base_path.exists():\n            print(f\"  {base_path} \u2713\")\n        else:\n            print(f\"  {base_path} \u2717 (not found)\")\n\n        print(\"\\nOverride config (user editable):\")\n        if override_path.exists():\n            print(f\"  {override_path} \u2713\")\n        else:\n            print(f\"  {override_path} \u2717 (not found)\")\n\n        if not override_path.exists():\n            print(f\"\\nTo create override: axium config edit {spoke}\")\n\n    except Exception as e:\n        print(f\"\u2717 Error: {e}\")\n        raise typer.Exit(code=1)\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.config_show","title":"<code>config_show(spoke=typer.Argument(..., help=\"Spoke name (e.g., 'creds')\"), key=typer.Option(None, '--key', '-k', help=\"Show specific key path (e.g., 'check.path')\"), redact=typer.Option(False, '--redact', help='Mask sensitive values (passwords, tokens, keys)'))</code>","text":"<p>Display merged configuration for a spoke via daemon.</p> <p>Shows the final merged configuration (base + override + environment) loaded and cached by the daemon. Uses IPC to query the daemon.</p> Example <pre><code>$ axium config show creds\nMerged Configuration (creds):\n{\n  \"check\": {\n    \"type\": \"mtime\",\n    \"path\": \"/home/user/.aws/credentials\"\n  }\n}\n\n$ axium config show creds --key check.path\nMerged Configuration (creds, key: check.path):\n/home/user/.aws/credentials\n\n$ axium config show creds --redact\nMerged Configuration (creds):\n{\n  \"api_key\": \"***REDACTED***\",\n  \"check\": { ... }\n}\n</code></pre> Source code in <code>axium/core/cli.py</code> <pre><code>@config_app.command(\"show\")\ndef config_show(\n    spoke: str = typer.Argument(..., help=\"Spoke name (e.g., 'creds')\"),\n    key: str\n    | None = typer.Option(\n        None, \"--key\", \"-k\", help=\"Show specific key path (e.g., 'check.path')\"\n    ),\n    redact: bool = typer.Option(\n        False, \"--redact\", help=\"Mask sensitive values (passwords, tokens, keys)\"\n    ),\n) -&gt; None:\n    \"\"\"\n    Display merged configuration for a spoke via daemon.\n\n    Shows the final merged configuration (base + override + environment)\n    loaded and cached by the daemon. Uses IPC to query the daemon.\n\n    Example:\n        ```bash\n        $ axium config show creds\n        Merged Configuration (creds):\n        {\n          \"check\": {\n            \"type\": \"mtime\",\n            \"path\": \"/home/user/.aws/credentials\"\n          }\n        }\n\n        $ axium config show creds --key check.path\n        Merged Configuration (creds, key: check.path):\n        /home/user/.aws/credentials\n\n        $ axium config show creds --redact\n        Merged Configuration (creds):\n        {\n          \"api_key\": \"***REDACTED***\",\n          \"check\": { ... }\n        }\n        ```\n    \"\"\"\n    import json\n\n    from axium.core.config import redact_secrets\n    from axium.core.ipc import send_request_sync\n\n    try:\n        # Send IPC request to daemon\n        resp = send_request_sync(\n            {\"cmd\": \"get_config\", \"spoke\": spoke, \"key\": key if key else None}\n        )\n\n        if not resp.get(\"ok\"):\n            error = resp.get(\"error\", \"unknown error\")\n            print(f\"\u2717 {error}\")\n            raise typer.Exit(code=1)\n\n        config_data = resp.get(\"config\")\n\n        # Apply redaction if requested\n        if redact and isinstance(config_data, dict):\n            config_data = redact_secrets(config_data)\n\n        # Format output\n        if key:\n            # Specific key value\n            print(f\"Merged Configuration ({spoke}, key: {key}):\")\n            if isinstance(config_data, (dict, list)):\n                print(json.dumps(config_data, indent=2))\n            else:\n                print(config_data)\n        else:\n            # Full config\n            print(f\"Merged Configuration ({spoke}):\")\n            print(json.dumps(config_data, indent=2))\n\n    except ConnectionError:\n        print(\"\u2717 Daemon not running. Start with: axium daemon start\")\n        raise typer.Exit(code=1)\n    except Exception as e:\n        print(f\"\u2717 Error: {e}\")\n        raise typer.Exit(code=1)\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.config_edit","title":"<code>config_edit(spoke=typer.Argument(..., help=\"Spoke name (e.g., 'creds')\"))</code>","text":"<p>Open override configuration in editor.</p> <p>Opens ~/.config/axium/overrides/.yaml in $EDITOR (default: vim). Creates the file and parent directory if they don't exist. <p>The override file starts empty - add only the values you want to override from the base configuration.</p> Example <pre><code>$ axium config edit creds\n# Opens ~/.config/axium/overrides/creds.yaml in $EDITOR\n\n# Example override (only customize what you need):\ndefault:\n  auto_refresh: true  # Override this value\n  check:\n    max_age: 43200    # Override just this nested value\n</code></pre> Note <p>Set EDITOR environment variable to use your preferred editor. Falls back to vim if EDITOR is not set.</p> Source code in <code>axium/core/cli.py</code> <pre><code>@config_app.command(\"edit\")\ndef config_edit(\n    spoke: str = typer.Argument(..., help=\"Spoke name (e.g., 'creds')\")\n) -&gt; None:\n    \"\"\"\n    Open override configuration in editor.\n\n    Opens ~/.config/axium/overrides/&lt;spoke&gt;.yaml in $EDITOR (default: vim).\n    Creates the file and parent directory if they don't exist.\n\n    The override file starts empty - add only the values you want to override\n    from the base configuration.\n\n    Example:\n        ```bash\n        $ axium config edit creds\n        # Opens ~/.config/axium/overrides/creds.yaml in $EDITOR\n\n        # Example override (only customize what you need):\n        default:\n          auto_refresh: true  # Override this value\n          check:\n            max_age: 43200    # Override just this nested value\n        ```\n\n    Note:\n        Set EDITOR environment variable to use your preferred editor.\n        Falls back to vim if EDITOR is not set.\n    \"\"\"\n    import os\n    import subprocess\n    from pathlib import Path\n\n    from axium.core.config import create_override_template\n\n    try:\n        # Get override path\n        override_path = (\n            Path.home() / \".config\" / \"axium\" / \"overrides\" / f\"{spoke}.yaml\"\n        )\n\n        # Create parent directory if needed\n        override_path.parent.mkdir(parents=True, exist_ok=True)\n\n        # If file doesn't exist, create minimal template\n        if not override_path.exists():\n            template = create_override_template(spoke)\n            override_path.write_text(template)\n            print(f\"Created: {override_path}\")\n\n        # Open in editor\n        editor = os.getenv(\"EDITOR\", \"vim\")\n        subprocess.run([editor, str(override_path)])\n\n        print(f\"\\nOverride saved: {override_path}\")\n        print(\"Changes take effect on next spoke reload or daemon restart.\")\n\n    except Exception as e:\n        print(f\"\u2717 Error editing config: {e}\")\n        raise typer.Exit(code=1)\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.daemon_start","title":"<code>daemon_start(debug=typer.Option(False, '--debug', help='Run in foreground with logs to stdout'))</code>","text":"<p>Start the Axium daemon process.</p> <p>The daemon manages state, handles IPC requests, and coordinates events. By default, starts as a background process with logs to ~/.config/axium/axiumd.log.</p> <p>Parameters:</p> Name Type Description Default <code>debug</code> <code>bool</code> <p>If True, run in foreground with logs to stdout (for development)</p> <code>Option(False, '--debug', help='Run in foreground with logs to stdout')</code> Example <pre><code>$ axium daemon start\n(silent on success)\n\n$ axium daemon start --debug\n[INFO] Axium daemon starting (debug=True)\n...\n</code></pre> Source code in <code>axium/core/cli.py</code> <pre><code>@daemon_app.command(\"start\")\ndef daemon_start(\n    debug: bool = typer.Option(\n        False, \"--debug\", help=\"Run in foreground with logs to stdout\"\n    )\n) -&gt; None:\n    \"\"\"\n    Start the Axium daemon process.\n\n    The daemon manages state, handles IPC requests, and coordinates events.\n    By default, starts as a background process with logs to ~/.config/axium/axiumd.log.\n\n    Args:\n        debug: If True, run in foreground with logs to stdout (for development)\n\n    Example:\n        ```bash\n        $ axium daemon start\n        (silent on success)\n\n        $ axium daemon start --debug\n        [INFO] Axium daemon starting (debug=True)\n        ...\n        ```\n    \"\"\"\n    from axium.core.api import daemon_start as api_daemon_start\n    from axium.core.cli_util import run_and_exit_ok\n\n    # Debug mode runs in foreground and prints, don't use silent pattern\n    if debug:\n        run_and_exit_ok(lambda: api_daemon_start(debug=True))\n    else:\n        run_and_exit_ok(api_daemon_start)\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.daemon_stop","title":"<code>daemon_stop()</code>","text":"<p>Stop the Axium daemon process.</p> <p>Sends a stop command via IPC. If daemon is unresponsive, attempts to send SIGTERM to the PID from ~/.config/axium/axiumd.pid.</p> Example <pre><code>$ axium daemon stop\n(silent on success, exits 1 on failure)\n</code></pre> Source code in <code>axium/core/cli.py</code> <pre><code>@daemon_app.command(\"stop\")\ndef daemon_stop() -&gt; None:\n    \"\"\"\n    Stop the Axium daemon process.\n\n    Sends a stop command via IPC. If daemon is unresponsive, attempts\n    to send SIGTERM to the PID from ~/.config/axium/axiumd.pid.\n\n    Example:\n        ```bash\n        $ axium daemon stop\n        (silent on success, exits 1 on failure)\n        ```\n    \"\"\"\n    from axium.core.api import daemon_stop as api_daemon_stop\n    from axium.core.cli_util import run_and_exit_ok\n\n    run_and_exit_ok(api_daemon_stop)\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.daemon_status","title":"<code>daemon_status()</code>","text":"<p>Check daemon status and liveness.</p> <p>Displays PID, socket path, and whether the daemon responds to ping.</p> Example <pre><code>$ axium daemon status\n{'pid': 12345, 'socket': '/tmp/axiumd.sock', 'socket_exists': True, 'alive': True}\n</code></pre> Source code in <code>axium/core/cli.py</code> <pre><code>@daemon_app.command(\"status\")\ndef daemon_status() -&gt; None:\n    \"\"\"\n    Check daemon status and liveness.\n\n    Displays PID, socket path, and whether the daemon responds to ping.\n\n    Example:\n        ```bash\n        $ axium daemon status\n        {'pid': 12345, 'socket': '/tmp/axiumd.sock', 'socket_exists': True, 'alive': True}\n        ```\n    \"\"\"\n    import asyncio\n\n    from axium.core.api import daemon_status as api_daemon_status\n\n    try:\n        stat = api_daemon_status()\n        if stat:\n            print(stat)\n        else:\n            print(\"\u2717 Daemon not responding\")\n            print(\"  Start with: axium daemon start\")\n            raise typer.Exit(1)\n    except typer.Exit:\n        raise\n    except asyncio.TimeoutError:\n        print(\"\u2717 Daemon not responding (timeout after 2s)\")\n        print(\"  Check if daemon is running: axium daemon logs\")\n        raise typer.Exit(1)\n    except (FileNotFoundError, ConnectionRefusedError):\n        print(\"\u2717 Daemon not running\")\n        print(\"  Start with: axium daemon start\")\n        raise typer.Exit(1)\n    except Exception as e:\n        print(f\"\u2717 Failed to get daemon status: {type(e).__name__}\")\n        print(f\"  {e}\")\n        raise typer.Exit(1)\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.daemon_logs","title":"<code>daemon_logs(follow=typer.Option(False, '--follow', '-f', help='Follow log output (tail -f)'), lines=typer.Option(50, '--lines', '-n', help='Number of lines to show'))</code>","text":"<p>View daemon logs from ~/.config/axium/axiumd.log.</p> <p>Parameters:</p> Name Type Description Default <code>follow</code> <code>bool</code> <p>If True, continuously tail the log file (like tail -f)</p> <code>Option(False, '--follow', '-f', help='Follow log output (tail -f)')</code> <code>lines</code> <code>int</code> <p>Number of lines to display (default: 50)</p> <code>Option(50, '--lines', '-n', help='Number of lines to show')</code> Example <pre><code>$ axium daemon logs\n[Shows last 50 lines]\n\n$ axium daemon logs -f\n[Follows log output, Ctrl+C to exit]\n\n$ axium daemon logs -n 100\n[Shows last 100 lines]\n</code></pre> <p>Raises:</p> Type Description <code>Exit</code> <p>If log file doesn't exist or can't be read</p> Source code in <code>axium/core/cli.py</code> <pre><code>@daemon_app.command(\"logs\")\ndef daemon_logs(\n    follow: bool = typer.Option(\n        False, \"--follow\", \"-f\", help=\"Follow log output (tail -f)\"\n    ),\n    lines: int = typer.Option(50, \"--lines\", \"-n\", help=\"Number of lines to show\"),\n) -&gt; None:\n    \"\"\"\n    View daemon logs from ~/.config/axium/axiumd.log.\n\n    Args:\n        follow: If True, continuously tail the log file (like tail -f)\n        lines: Number of lines to display (default: 50)\n\n    Example:\n        ```bash\n        $ axium daemon logs\n        [Shows last 50 lines]\n\n        $ axium daemon logs -f\n        [Follows log output, Ctrl+C to exit]\n\n        $ axium daemon logs -n 100\n        [Shows last 100 lines]\n        ```\n\n    Raises:\n        typer.Exit: If log file doesn't exist or can't be read\n    \"\"\"\n    import subprocess\n    from pathlib import Path\n\n    log_path = Path.home() / \".config\" / \"axium\" / \"axiumd.log\"\n\n    if not log_path.exists():\n        print(\"axium: no log file found at\", log_path)\n        raise typer.Exit(1)\n\n    try:\n        if follow:\n            subprocess.run([\"tail\", \"-f\", str(log_path)])\n        else:\n            subprocess.run([\"tail\", \"-n\", str(lines), str(log_path)])\n    except KeyboardInterrupt:\n        pass\n    except Exception as e:\n        print(f\"axium: error reading logs: {e}\")\n        raise typer.Exit(1)\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.daemon_reload","title":"<code>daemon_reload()</code>","text":"<p>Reload daemon state from disk.</p> <p>Forces the daemon to re-read state.json and refresh its internal state. Useful after manually editing configuration files.</p> Example <pre><code>$ axium daemon reload\n(silent on success, exits 1 on failure)\n</code></pre> Note <p>Requires daemon to be running. Does not reload Spokes (restart required).</p> Source code in <code>axium/core/cli.py</code> <pre><code>@daemon_app.command(\"reload\")\ndef daemon_reload() -&gt; None:\n    \"\"\"\n    Reload daemon state from disk.\n\n    Forces the daemon to re-read state.json and refresh its internal state.\n    Useful after manually editing configuration files.\n\n    Example:\n        ```bash\n        $ axium daemon reload\n        (silent on success, exits 1 on failure)\n        ```\n\n    Note:\n        Requires daemon to be running. Does not reload Spokes (restart required).\n    \"\"\"\n    from axium.core.api import reload_daemon\n    from axium.core.cli_util import run_and_exit_ok\n\n    run_and_exit_ok(reload_daemon)\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.daemon_restart","title":"<code>daemon_restart()</code>","text":"<p>Restart the Axium daemon process.</p> <p>Stops the daemon gracefully, waits for clean shutdown, then starts it again. This is equivalent to running 'axium daemon stop' followed by 'axium daemon start', but handles the timing automatically.</p> <p>Use this when you need to: - Apply configuration changes that require a full restart - Reset daemon state completely - Recover from daemon issues</p> Example <pre><code>$ axium daemon restart\n(silent on success, exits 1 on failure)\n\n$ axium daemon restart --verbose\n\u2713 Daemon restarted successfully\n</code></pre> Note <p>This will reset daemon uptime and reload all spokes/gears. For config-only changes, use 'axium daemon reload' instead.</p> Source code in <code>axium/core/cli.py</code> <pre><code>@daemon_app.command(\"restart\")\ndef daemon_restart() -&gt; None:\n    \"\"\"\n    Restart the Axium daemon process.\n\n    Stops the daemon gracefully, waits for clean shutdown, then starts it again.\n    This is equivalent to running 'axium daemon stop' followed by 'axium daemon start',\n    but handles the timing automatically.\n\n    Use this when you need to:\n    - Apply configuration changes that require a full restart\n    - Reset daemon state completely\n    - Recover from daemon issues\n\n    Example:\n        ```bash\n        $ axium daemon restart\n        (silent on success, exits 1 on failure)\n\n        $ axium daemon restart --verbose\n        \u2713 Daemon restarted successfully\n        ```\n\n    Note:\n        This will reset daemon uptime and reload all spokes/gears.\n        For config-only changes, use 'axium daemon reload' instead.\n    \"\"\"\n    from axium.core.api import daemon_restart as api_daemon_restart\n    from axium.core.cli_util import run_and_exit_ok\n\n    run_and_exit_ok(api_daemon_restart)\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.env_set","title":"<code>env_set(name)</code>","text":"<p>Set the active environment.</p> <p>Updates daemon state and triggers env_change events for Spokes to react. The environment must exist in ~/.config/axium/envs.yaml.</p> <p>In tmux: Sets environment for current pane and exports AXIUM_ENV to pane. Outside tmux: Sets global environment.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Environment name from envs.yaml (e.g., \"prod\", \"dev\", \"staging\")</p> required Example <pre><code>$ axium env set prod\n(silent on success)\n\n$ axium env set prod  # in tmux pane %1\n(silent on success)\n</code></pre> Note <p>Requires daemon to be running. Emits env_change event to all Spokes. In tmux, also calls 'tmux setenv -t  AXIUM_ENV '. Source code in <code>axium/core/cli.py</code> <pre><code>@env_app.command(\"set\")\ndef env_set(name: str | None) -&gt; None:\n    \"\"\"\n    Set the active environment.\n\n    Updates daemon state and triggers env_change events for Spokes to react.\n    The environment must exist in ~/.config/axium/envs.yaml.\n\n    In tmux: Sets environment for current pane and exports AXIUM_ENV to pane.\n    Outside tmux: Sets global environment.\n\n    Args:\n        name: Environment name from envs.yaml (e.g., \"prod\", \"dev\", \"staging\")\n\n    Example:\n        ```bash\n        $ axium env set prod\n        (silent on success)\n\n        $ axium env set prod  # in tmux pane %1\n        (silent on success)\n        ```\n\n    Note:\n        Requires daemon to be running. Emits env_change event to all Spokes.\n        In tmux, also calls 'tmux setenv -t &lt;pane&gt; AXIUM_ENV &lt;env&gt;'.\n    \"\"\"\n    import os\n    import subprocess\n    import sys\n\n    from axium.core import env as env_module\n    from axium.core.api import set_active_env\n\n    # Pre-validate environment name for immediate feedback\n    is_valid, error = env_module.validate_env_name(name)\n    if not is_valid:\n        print(f\"axium: {error}\", file=sys.stderr)\n        raise typer.Exit(1)\n\n    pane_id = os.getenv(\"TMUX_PANE\")\n\n    # Set environment via API\n    ok = set_active_env(name, pane_id=pane_id)\n\n    # If successful and in tmux, update tmux pane variable\n    if ok and pane_id:\n        try:\n            subprocess.run(\n                [\"tmux\", \"setenv\", \"-t\", pane_id, \"AXIUM_ENV\", name],\n                check=True,\n                capture_output=True,\n            )\n        except Exception:\n            pass  # Non-fatal if tmux setenv fails\n\n    raise typer.Exit(code=0 if ok else 1)\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.env_get","title":"<code>env_get(pane=typer.Option(None, '--pane', help='Get environment for specific pane ID (e.g., %1)'))</code>","text":"<p>Get the active environment name.</p> <p>In tmux: Queries daemon for current pane's environment. Outside tmux: Queries daemon for global active_env.</p> <p>Parameters:</p> Name Type Description Default <code>pane</code> <code>str | None</code> <p>Optional pane ID to query. If None, uses TMUX_PANE or global.</p> <code>Option(None, '--pane', help='Get environment for specific pane ID (e.g., %1)')</code> Example <pre><code>$ axium env get\nprod\n\n$ axium env get --pane %2\nbuilder\n\n$ axium env get  # in tmux pane %1\nroot\n</code></pre> Note <p>Requires daemon to be running. Returns None if no environment is set.</p> Source code in <code>axium/core/cli.py</code> <pre><code>@env_app.command(\"get\")\ndef env_get(\n    pane: str\n    | None = typer.Option(\n        None, \"--pane\", help=\"Get environment for specific pane ID (e.g., %1)\"\n    )\n) -&gt; None:\n    \"\"\"\n    Get the active environment name.\n\n    In tmux: Queries daemon for current pane's environment.\n    Outside tmux: Queries daemon for global active_env.\n\n    Args:\n        pane: Optional pane ID to query. If None, uses TMUX_PANE or global.\n\n    Example:\n        ```bash\n        $ axium env get\n        prod\n\n        $ axium env get --pane %2\n        builder\n\n        $ axium env get  # in tmux pane %1\n        root\n        ```\n\n    Note:\n        Requires daemon to be running. Returns None if no environment is set.\n    \"\"\"\n    import os\n\n    from axium.core.api import get_active_env, get_pane_env\n\n    # Determine which pane to query\n    pane_id = pane or os.getenv(\"TMUX_PANE\")\n\n    if pane_id:\n        # Query pane-specific environment\n        env_name = get_pane_env(pane_id)\n    else:\n        # Query global environment\n        env_name = get_active_env()\n\n    if env_name:\n        print(env_name)\n    else:\n        print(\"\u2717 No environment set or daemon not running\")\n        print(\"  Start daemon: axium daemon start\")\n        print(\"  Set environment: axium env set &lt;name&gt;\")\n        raise typer.Exit(1)\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.env_list","title":"<code>env_list(show_panes=typer.Option(False, '--panes', help='Show per-pane environment mappings'))</code>","text":"<p>List all available environments from envs.yaml.</p> <p>Displays all defined environments with their property keys. The active environment is marked with *.</p> <p>Parameters:</p> Name Type Description Default <code>show_panes</code> <code>bool</code> <p>If True, also displays pane-to-environment mappings from daemon</p> <code>Option(False, '--panes', help='Show per-pane environment mappings')</code> Example <pre><code>$ axium env list\nAvailable environments:\n  * prod (prefix, aws_profile, region, color)\n    dev (prefix, aws_profile, region, color)\n    staging (prefix, region)\n\n$ axium env list --panes\nAvailable environments:\n  * prod (prefix, aws_profile, region, color)\n    dev (prefix, aws_profile, region, color)\n\nPane Mappings:\n  %1 \u2192 root\n  %2 \u2192 builder\n  %3 \u2192 prod\n</code></pre> Note <p>Reads directly from ~/.config/axium/envs.yaml (no daemon required). --panes requires daemon to be running.</p> Source code in <code>axium/core/cli.py</code> <pre><code>@env_app.command(\"list\")\ndef env_list(\n    show_panes: bool = typer.Option(\n        False, \"--panes\", help=\"Show per-pane environment mappings\"\n    )\n) -&gt; None:\n    \"\"\"\n    List all available environments from envs.yaml.\n\n    Displays all defined environments with their property keys.\n    The active environment is marked with *.\n\n    Args:\n        show_panes: If True, also displays pane-to-environment mappings from daemon\n\n    Example:\n        ```bash\n        $ axium env list\n        Available environments:\n          * prod (prefix, aws_profile, region, color)\n            dev (prefix, aws_profile, region, color)\n            staging (prefix, region)\n\n        $ axium env list --panes\n        Available environments:\n          * prod (prefix, aws_profile, region, color)\n            dev (prefix, aws_profile, region, color)\n\n        Pane Mappings:\n          %1 \u2192 root\n          %2 \u2192 builder\n          %3 \u2192 prod\n        ```\n\n    Note:\n        Reads directly from ~/.config/axium/envs.yaml (no daemon required).\n        --panes requires daemon to be running.\n    \"\"\"\n    from axium.core import env\n\n    envs = env.load_envs()\n    if not envs:\n        print(\"No environments found in ~/.config/axium/envs.yaml\")\n        return\n\n    active = env.get_active_env_name()\n    print(\"Available environments:\")\n    for name, props in envs.items():\n        marker = \"*\" if name == active else \" \"\n        keys = \", \".join(props.keys())\n        print(f\"  {marker} {name} ({keys})\")\n\n    # Show pane mappings if requested\n    if show_panes:\n        try:\n            resp = send_request_sync({\"cmd\": \"get_state\"})\n            state = resp.get(\"state\", {})\n            panes = state.get(\"panes\", {})\n\n            if panes:\n                print(\"\\nPane Mappings:\")\n                for pane_id, env_name in sorted(panes.items()):\n                    print(f\"  {pane_id} \u2192 {env_name}\")\n            else:\n                print(\"\\nNo pane mappings (no panes have set environments)\")\n        except Exception as e:\n            print(f\"\\naxium: cannot fetch pane mappings ({e}). Try: axium daemon start\")\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.env_show","title":"<code>env_show(name=typer.Argument(None))</code>","text":"<p>Show properties for an environment.</p> <p>Displays all key-value pairs for the specified environment. If no name is provided, shows the active environment (checking pane-specific environment in tmux, then falling back to global).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Optional environment name. If None, uses active environment.</p> <code>Argument(None)</code> Example <pre><code>$ axium env show prod\nEnvironment: prod\n  prefix: enva-prod\n  aws_profile: production\n  region: us-east-1\n  color: red\n\n$ axium env show\nEnvironment: dev (pane %1)\n  prefix: enva-dev\n  region: eu-west-1\n\n$ axium env show  # outside tmux\nEnvironment: root (global)\n  prefix: enva-root\n  region: eu-west-1\n</code></pre> Note <p>Reads from ~/.config/axium/envs.yaml for properties. Queries daemon for active environment (pane-specific or global).</p> Source code in <code>axium/core/cli.py</code> <pre><code>@env_app.command(\"show\")\ndef env_show(name: str | None = typer.Argument(None)) -&gt; None:\n    \"\"\"\n    Show properties for an environment.\n\n    Displays all key-value pairs for the specified environment.\n    If no name is provided, shows the active environment (checking pane-specific\n    environment in tmux, then falling back to global).\n\n    Args:\n        name: Optional environment name. If None, uses active environment.\n\n    Example:\n        ```bash\n        $ axium env show prod\n        Environment: prod\n          prefix: enva-prod\n          aws_profile: production\n          region: us-east-1\n          color: red\n\n        $ axium env show\n        Environment: dev (pane %1)\n          prefix: enva-dev\n          region: eu-west-1\n\n        $ axium env show  # outside tmux\n        Environment: root (global)\n          prefix: enva-root\n          region: eu-west-1\n        ```\n\n    Note:\n        Reads from ~/.config/axium/envs.yaml for properties.\n        Queries daemon for active environment (pane-specific or global).\n    \"\"\"\n    import os\n\n    from axium.core import env\n    from axium.core.api import get_active_env, get_pane_env\n\n    env_source = None  # Track where we got the env from\n\n    if name is None:\n        # First try pane-specific environment (if in tmux)\n        pane_id = os.getenv(\"TMUX_PANE\")\n        if pane_id:\n            try:\n                name = get_pane_env(pane_id)\n                if name:\n                    env_source = f\"pane {pane_id}\"\n            except Exception:\n                pass\n\n        # Fall back to global active environment\n        if not name:\n            try:\n                name = get_active_env()\n                if name:\n                    env_source = \"global\"\n            except Exception:\n                pass\n\n        # Fall back to reading from state.json directly (no daemon)\n        if not name:\n            name = env.get_active_env_name()\n            if name:\n                env_source = \"global\"\n\n        if not name:\n            print(\"No active environment set. Use: axium env set &lt;name&gt;\")\n            return\n\n    envs = env.load_envs()\n    env_data = envs.get(name)\n\n    if not env_data:\n        print(f\"Environment '{name}' not found in envs.yaml\")\n        return\n\n    # Display environment name with source\n    if env_source:\n        print(f\"Environment: {name} ({env_source})\")\n    else:\n        print(f\"Environment: {name}\")\n\n    for key, value in env_data.items():\n        print(f\"  {key}: {value}\")\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.run_cmd","title":"<code>run_cmd(ctx, command)</code>","text":"<p>Execute a command with registered prefix rules applied.</p> <p>This is the core of Axium's command wrapping. If the command has a prefix rule in prefixes.yaml, the prefix is applied based on the current context (environment, tmux pane, etc.).</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>Typer context for accessing extra arguments</p> required <code>command</code> <code>str</code> <p>Command to execute (e.g., \"aws\", \"terraform\")</p> required Example <pre><code>$ axium run aws s3 ls\n# If active env is 'prod' with prefix 'enva-prod':\n# Actually executes: enva-prod aws s3 ls\n\n$ axium run terraform plan\n# With prefix rules, becomes: enva-prod terraform plan\n\n$ axium run aws s3 cp --recursive mydir s3://bucket/\n# External flags like --recursive are passed through transparently\n</code></pre> Note <ul> <li>Falls back to unwrapped command if daemon unreachable</li> <li>Falls back to unwrapped if prefix command not found</li> <li>Exits with same return code as the executed command</li> <li>Context includes: TMUX_PANE, active_env</li> <li>All arguments after command are passed through without parsing</li> </ul> Source code in <code>axium/core/cli.py</code> <pre><code>@app.command(\n    \"run\", context_settings={\"allow_extra_args\": True, \"ignore_unknown_options\": True}\n)\ndef run_cmd(ctx: typer.Context, command: str) -&gt; None:\n    \"\"\"\n    Execute a command with registered prefix rules applied.\n\n    This is the core of Axium's command wrapping. If the command has a prefix\n    rule in prefixes.yaml, the prefix is applied based on the current context\n    (environment, tmux pane, etc.).\n\n    Args:\n        ctx: Typer context for accessing extra arguments\n        command: Command to execute (e.g., \"aws\", \"terraform\")\n\n    Example:\n        ```bash\n        $ axium run aws s3 ls\n        # If active env is 'prod' with prefix 'enva-prod':\n        # Actually executes: enva-prod aws s3 ls\n\n        $ axium run terraform plan\n        # With prefix rules, becomes: enva-prod terraform plan\n\n        $ axium run aws s3 cp --recursive mydir s3://bucket/\n        # External flags like --recursive are passed through transparently\n        ```\n\n    Note:\n        - Falls back to unwrapped command if daemon unreachable\n        - Falls back to unwrapped if prefix command not found\n        - Exits with same return code as the executed command\n        - Context includes: TMUX_PANE, active_env\n        - All arguments after command are passed through without parsing\n    \"\"\"\n    import os\n    import subprocess\n    import sys\n\n    from axium.core.api import get_active_env, get_pane_env\n\n    # Collect all remaining arguments from context\n    args = list(ctx.args)\n\n    # Check if this should route to a spoke command instead\n    # e.g., \"axium run aws whoami\" -&gt; \"axium aws whoami\"\n    if args:\n        import logging\n\n        logger = logging.getLogger(\"axium.cli\")\n\n        try:\n            # Search through registered_groups (spokes/gears are added as groups)\n            for group_info in app.registered_groups:\n                if group_info.name == command:\n                    # Found matching spoke/gear group\n                    typer_group = group_info.typer_instance\n\n                    # Check if first arg is a registered subcommand\n                    subcommand_names = [\n                        cmd.name for cmd in typer_group.registered_commands\n                    ]\n                    if args[0] in subcommand_names:\n                        # Route to spoke/gear command\n                        logger.debug(\n                            f\"Routing 'axium run {command} {args[0]}' to spoke command\"\n                        )\n\n                        # Invoke the spoke command directly\n                        # We need to call the typer app with the subcommand args\n                        sys.argv = [command] + args  # Set argv for typer parsing\n                        typer_group(args, standalone_mode=True)\n                        # If we get here without exception, it worked\n                        return\n\n                    # First arg is not a spoke subcommand, fall through to prefix application\n                    logger.debug(\n                        f\"Arg '{args[0]}' not in spoke subcommands: {subcommand_names}\"\n                    )\n                    break\n\n        except SystemExit:\n            # Typer uses SystemExit for normal exits - re-raise it\n            raise\n        except Exception as e:\n            # Not a spoke command or failed lookup - continue to prefix application\n            logger.debug(f\"Spoke routing failed: {e}\")\n\n    # Build context for prefix expansion\n    pane_id = os.getenv(\"TMUX_PANE\")\n    context = {\n        \"pane\": pane_id,\n        \"env\": None,\n    }\n\n    # Get current environment (pane-specific first, then global)\n    if pane_id:\n        try:\n            # Try pane-specific environment first\n            context[\"env\"] = get_pane_env(pane_id)\n        except Exception:\n            pass\n\n    # Fall back to global active environment if no pane env\n    if not context[\"env\"]:\n        try:\n            context[\"env\"] = get_active_env()\n        except Exception:\n            pass\n\n    # Ask daemon to apply prefix rules\n    try:\n        resp = send_request_sync(\n            {\n                \"cmd\": \"apply_prefixes\",\n                \"command\": command,\n                \"args\": args,\n                \"context\": context,\n            }\n        )\n        if resp.get(\"ok\"):\n            final_cmd = resp.get(\"command\", [command] + args)\n            env_vars = resp.get(\"env_vars\", {})\n\n            # Execute with modified environment\n            env = os.environ.copy()\n            env.update(env_vars)\n\n            # Try direct execution first\n            try:\n                result = subprocess.run(final_cmd, env=env)\n                sys.exit(result.returncode)\n            except FileNotFoundError:\n                # Prefix command might be a shell function, try through interactive shell\n                import logging\n                import shlex\n\n                prefix_cmd = final_cmd[0]\n                logger = logging.getLogger(\"axium.cli\")\n                logger.debug(\n                    f\"Prefix command '{prefix_cmd}' not found as binary, trying shell execution\"\n                )\n\n                # Get user's shell\n                user_shell = os.environ.get(\"SHELL\", \"/bin/bash\")\n\n                # Build shell command string\n                shell_cmd = \" \".join(shlex.quote(arg) for arg in final_cmd)\n\n                # Execute through interactive shell to load functions\n                result = subprocess.run(\n                    [user_shell, \"-ic\", shell_cmd],\n                    env=env,\n                    stderr=subprocess.PIPE,\n                    text=True,\n                )\n\n                # Filter out shell initialization warnings from stderr\n                if result.stderr:\n                    # Only print stderr lines that aren't shell init warnings\n                    for line in result.stderr.splitlines():\n                        if not any(\n                            skip in line\n                            for skip in [\n                                \"command not found: complete\",\n                                \"command not found: axium_tmux_enable_palette\",\n                            ]\n                        ):\n                            print(line, file=sys.stderr)\n\n                sys.exit(result.returncode)\n        else:\n            # Error from daemon, fall back to unwrapped\n            result = subprocess.run([command] + args)\n            sys.exit(result.returncode)\n    except FileNotFoundError:\n        # Command not found even after fallbacks\n        print(f\"axium: command not found: {command}\", file=sys.stderr)\n        sys.exit(127)\n    except Exception as e:\n        # Daemon not reachable or other error, fall back to unwrapped\n        import logging\n\n        logger = logging.getLogger(\"axium.cli\")\n        logger.debug(f\"Error applying prefixes: {e}, falling back to unwrapped command\")\n        try:\n            result = subprocess.run([command] + args)\n            sys.exit(result.returncode)\n        except FileNotFoundError:\n            print(f\"axium: command not found: {command}\", file=sys.stderr)\n            sys.exit(127)\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.hud_callback","title":"<code>hud_callback(ctx, pane=typer.Option(None, '--pane', help='Show HUD for specific pane ID (e.g., %1)'))</code>","text":"<p>Display HUD status line for tmux/shell prompts.</p> <p>Generates a one-line status display showing environment, uptime, and other context. Designed to be called from tmux status line or shell prompt.</p> <p>Uses fast path (cached HUD from daemon) when --pane is specified for instant response times suitable for frequent tmux refreshes.</p> <p>Parameters:</p> Name Type Description Default <code>pane</code> <code>str | None</code> <p>Optional pane ID to show pane-specific environment context</p> <code>Option(None, '--pane', help='Show HUD for specific pane ID (e.g., %1)')</code> Example <pre><code>$ axium hud\n[axium] env:prod  uptime:2h15m\n\n$ axium hud --pane %1\n[axium] pane:%1  env:root  uptime:2h15m\n\n$ axium hud  # daemon not running\n[axium] inactive\n</code></pre> <p>Usage in tmux.conf:     <pre><code>set -g status-right '#(axium hud --pane #D)'\n</code></pre></p> Note <p>Gracefully handles daemon being down (shows \"inactive\"). Output format suitable for tmux status-right or PS1. In tmux, #D expands to the pane ID (e.g., %1). Fast path bypasses spoke providers for instant response.</p> Source code in <code>axium/core/cli.py</code> <pre><code>@hud_app.callback(invoke_without_command=True)\ndef hud_callback(\n    ctx: typer.Context,\n    pane: str\n    | None = typer.Option(\n        None, \"--pane\", help=\"Show HUD for specific pane ID (e.g., %1)\"\n    ),\n) -&gt; None:\n    \"\"\"\n    Display HUD status line for tmux/shell prompts.\n\n    Generates a one-line status display showing environment, uptime, and other\n    context. Designed to be called from tmux status line or shell prompt.\n\n    Uses fast path (cached HUD from daemon) when --pane is specified for\n    instant response times suitable for frequent tmux refreshes.\n\n    Args:\n        pane: Optional pane ID to show pane-specific environment context\n\n    Example:\n        ```bash\n        $ axium hud\n        [axium] env:prod  uptime:2h15m\n\n        $ axium hud --pane %1\n        [axium] pane:%1  env:root  uptime:2h15m\n\n        $ axium hud  # daemon not running\n        [axium] inactive\n        ```\n\n    Usage in tmux.conf:\n        ```\n        set -g status-right '#(axium hud --pane #D)'\n        ```\n\n    Note:\n        Gracefully handles daemon being down (shows \"inactive\").\n        Output format suitable for tmux status-right or PS1.\n        In tmux, #D expands to the pane ID (e.g., %1).\n        Fast path bypasses spoke providers for instant response.\n    \"\"\"\n    # Only run if no subcommand invoked\n    if ctx.invoked_subcommand is not None:\n        return\n\n    import os\n    import tempfile\n    from pathlib import Path\n\n    # Auto-detect pane if not specified and in tmux\n    pane_id = pane or os.getenv(\"TMUX_PANE\")\n\n    if pane_id:\n        # Fast path: Use cached HUD from daemon for instant response\n        # Check if daemon socket exists (more reliable than PID file)\n        socket_path = Path(tempfile.gettempdir()) / \"axiumd.sock\"\n\n        if not socket_path.exists():\n            print(\"[axium] inactive\")\n            return\n\n        try:\n            # Use 500ms timeout to allow for IPC overhead + HUD rendering\n            # Cached HUD returns in ~50-150ms, first-time render ~200-350ms\n            resp = send_request_sync({\"cmd\": \"get_hud\", \"pane\": pane_id}, timeout=0.5)\n            if resp.get(\"ok\"):\n                print(resp.get(\"hud\", \"[axium] inactive\"))\n            else:\n                print(\"[axium] inactive\")\n        except Exception:\n            # Daemon not responding or error - show inactive\n            print(\"[axium] inactive\")\n    else:\n        # Global mode: Use legacy hud.main() (includes spoke providers)\n        from axium.core.hud import main as hud_main\n\n        print(hud_main())\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.hud_reload_cmd","title":"<code>hud_reload_cmd()</code>","text":"<p>Reload HUD configuration and refresh all panes.</p> <p>Forces the daemon to reload hud.yaml and regenerate HUD cache for all active panes. Use this after modifying hud.yaml to apply changes.</p> Example <pre><code>$ axium hud reload\n\u2713 HUD reloaded\n</code></pre> Note <p>Requires daemon to be running. Returns exit code 1 if reload fails.</p> Source code in <code>axium/core/cli.py</code> <pre><code>@hud_app.command(\"reload\")\ndef hud_reload_cmd() -&gt; None:\n    \"\"\"\n    Reload HUD configuration and refresh all panes.\n\n    Forces the daemon to reload hud.yaml and regenerate HUD cache for all\n    active panes. Use this after modifying hud.yaml to apply changes.\n\n    Example:\n        ```bash\n        $ axium hud reload\n        \u2713 HUD reloaded\n        ```\n\n    Note:\n        Requires daemon to be running. Returns exit code 1 if reload fails.\n    \"\"\"\n    try:\n        resp = send_request_sync({\"cmd\": \"reload\"})\n        if resp.get(\"ok\"):\n            print(\"\u2713 HUD reloaded\")\n        else:\n            print(\"\u2717 Failed to reload HUD\")\n            raise typer.Exit(1)\n    except Exception as e:\n        print(f\"\u2717 Failed to reload HUD: {e}\")\n        raise typer.Exit(1)\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.hud_theme_cmd","title":"<code>hud_theme_cmd(action=typer.Argument(..., help='Action: list, show, set &lt;name&gt;'), theme_name=typer.Argument(None, help=\"Theme name for 'set' action\"))</code>","text":"<p>Manage HUD color themes.</p> <p>Themes provide customizable color schemes for HUD output. Themes are disabled by default and can be enabled by setting a theme in hud.yaml.</p> Available themes <ul> <li>classic: Standard ANSI colors (white, cyan, yellow, red, green)</li> <li>teal: Axium brand colors (#00B7C7 teal, soft white)</li> <li>dim: Dimmed colors for low-contrast terminals</li> <li>inverted: Dark colors for light backgrounds</li> <li>mono: No colors (plain text)</li> <li>soft: Pastel colors for gentle aesthetics</li> </ul> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>str</code> <p>Action to perform (list, show, set)</p> <code>Argument(..., help='Action: list, show, set &lt;name&gt;')</code> <code>theme_name</code> <code>str | None</code> <p>Theme name when using 'set' action</p> <code>Argument(None, help=\"Theme name for 'set' action\")</code> Example <pre><code>$ axium hud theme list\nAvailable themes:\n  - classic\n  - dim\n  - inverted\n  - mono\n  - soft\n  - teal\n\n$ axium hud theme show\nTheme: classic\nEnabled: false\n\n$ axium hud theme set teal\nTheme set to 'teal'\n</code></pre> Note <p>Themes are opt-in to preserve Axium's silent design philosophy. Edit ~/.config/axium/hud.yaml to manually enable/disable themes.</p> Source code in <code>axium/core/cli.py</code> <pre><code>@hud_app.command(\"theme\")\ndef hud_theme_cmd(\n    action: str = typer.Argument(..., help=\"Action: list, show, set &lt;name&gt;\"),\n    theme_name: str | None = typer.Argument(None, help=\"Theme name for 'set' action\"),\n) -&gt; None:\n    \"\"\"\n    Manage HUD color themes.\n\n    Themes provide customizable color schemes for HUD output. Themes are\n    disabled by default and can be enabled by setting a theme in hud.yaml.\n\n    Available themes:\n        - classic: Standard ANSI colors (white, cyan, yellow, red, green)\n        - teal: Axium brand colors (#00B7C7 teal, soft white)\n        - dim: Dimmed colors for low-contrast terminals\n        - inverted: Dark colors for light backgrounds\n        - mono: No colors (plain text)\n        - soft: Pastel colors for gentle aesthetics\n\n    Args:\n        action: Action to perform (list, show, set)\n        theme_name: Theme name when using 'set' action\n\n    Example:\n        ```bash\n        $ axium hud theme list\n        Available themes:\n          - classic\n          - dim\n          - inverted\n          - mono\n          - soft\n          - teal\n\n        $ axium hud theme show\n        Theme: classic\n        Enabled: false\n\n        $ axium hud theme set teal\n        Theme set to 'teal'\n        ```\n\n    Note:\n        Themes are opt-in to preserve Axium's silent design philosophy.\n        Edit ~/.config/axium/hud.yaml to manually enable/disable themes.\n    \"\"\"\n    from axium.core.hud_themes import list_themes\n\n    if action == \"list\":\n        print(\"Available themes:\")\n        for theme in list_themes():\n            print(f\"  - {theme}\")\n    elif action == \"show\":\n        # Read current theme from hud.yaml\n        try:\n            import yaml\n            from pathlib import Path\n\n            hud_yaml = Path.home() / \".config\" / \"axium\" / \"hud.yaml\"\n            if not hud_yaml.exists():\n                print(\"hud.yaml not found - run 'axium bootstrap' first\")\n                raise typer.Exit(1)\n\n            with open(hud_yaml) as f:\n                config = yaml.safe_load(f)\n\n            theme_config = config.get(\"style\", {}).get(\"theme\", {})\n            theme_name = theme_config.get(\"name\", \"classic\")\n            theme_enabled = theme_config.get(\"enabled\", False)\n\n            print(f\"Theme: {theme_name}\")\n            print(f\"Enabled: {str(theme_enabled).lower()}\")\n        except Exception as e:\n            print(f\"Failed to read theme config: {e}\")\n            raise typer.Exit(1)\n    elif action == \"set\":\n        if not theme_name:\n            print(\"Theme name required for 'set' action\")\n            print(\"Usage: axium hud theme set &lt;name&gt;\")\n            raise typer.Exit(1)\n\n        # Validate theme name\n        if theme_name not in list_themes():\n            print(f\"Invalid theme: {theme_name}\")\n            print(f\"Available themes: {', '.join(list_themes())}\")\n            raise typer.Exit(1)\n\n        # Update hud.yaml\n        try:\n            import yaml\n            from pathlib import Path\n\n            hud_yaml = Path.home() / \".config\" / \"axium\" / \"hud.yaml\"\n            if not hud_yaml.exists():\n                print(\"hud.yaml not found - run 'axium bootstrap' first\")\n                raise typer.Exit(1)\n\n            with open(hud_yaml) as f:\n                config = yaml.safe_load(f)\n\n            # Update theme config\n            if \"style\" not in config:\n                config[\"style\"] = {}\n            if \"theme\" not in config[\"style\"]:\n                config[\"style\"][\"theme\"] = {}\n\n            config[\"style\"][\"theme\"][\"name\"] = theme_name\n            config[\"style\"][\"theme\"][\"enabled\"] = True  # Enable when setting\n\n            with open(hud_yaml, \"w\") as f:\n                yaml.safe_dump(config, f, default_flow_style=False)\n\n            print(f\"Theme set to '{theme_name}'\")\n\n            # Reload daemon to apply changes immediately\n            from axium.core.ipc import send_request_sync\n\n            try:\n                send_request_sync({\"cmd\": \"reload\"})\n            except Exception:\n                pass  # Daemon may not be running, that's ok\n        except Exception as e:\n            print(f\"Failed to update theme: {e}\")\n            raise typer.Exit(1)\n    else:\n        print(f\"Unknown action: {action}\")\n        print(\"Valid actions: list, show, set &lt;name&gt;\")\n        raise typer.Exit(1)\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.palette_cmd","title":"<code>palette_cmd(reload=typer.Option(False, '--reload', help='Reload Spokes and refresh command list'))</code>","text":"<p>Launch the interactive palette TUI.</p> <p>Opens a curses-based menu for quick access to all Axium commands (core and Spokes). Commands are discovered dynamically from the command registry. Navigate with arrow keys or j/k, select with Enter, quit with q/Esc.</p> <p>Parameters:</p> Name Type Description Default <code>reload</code> <code>bool</code> <p>Force reload of Spokes and refresh command registry</p> <code>Option(False, '--reload', help='Reload Spokes and refresh command list')</code> Example <pre><code>$ axium palette\n[Opens interactive menu with all available commands]\n\n$ axium palette --reload\n[Reloads Spokes and opens menu with refreshed command list]\n</code></pre> Key Bindings <pre><code>\u2191/k: Move up\n\u2193/j: Move down\nEnter: Execute selected command\nq/Esc: Quit\n</code></pre> Note <p>Requires terminal with curses support. Commands execute in foreground, press Enter after completion to return to palette.</p> Source code in <code>axium/core/cli.py</code> <pre><code>@app.command(\"palette\")\ndef palette_cmd(\n    reload: bool = typer.Option(\n        False, \"--reload\", help=\"Reload Spokes and refresh command list\"\n    )\n) -&gt; None:\n    \"\"\"\n    Launch the interactive palette TUI.\n\n    Opens a curses-based menu for quick access to all Axium commands (core and Spokes).\n    Commands are discovered dynamically from the command registry.\n    Navigate with arrow keys or j/k, select with Enter, quit with q/Esc.\n\n    Args:\n        reload: Force reload of Spokes and refresh command registry\n\n    Example:\n        ```bash\n        $ axium palette\n        [Opens interactive menu with all available commands]\n\n        $ axium palette --reload\n        [Reloads Spokes and opens menu with refreshed command list]\n        ```\n\n    Key Bindings:\n        ```\n        \u2191/k: Move up\n        \u2193/j: Move down\n        Enter: Execute selected command\n        q/Esc: Quit\n        ```\n\n    Note:\n        Requires terminal with curses support. Commands execute in foreground,\n        press Enter after completion to return to palette.\n    \"\"\"\n    import curses\n\n    from axium.core import palette as pal\n    from axium.core import registry\n\n    if reload:\n        # Clear registry and reload spokes\n        registry.clear_registry()\n        load_spokes(app)\n        registry.introspect_typer_app(app, source=\"core\")\n\n    curses.wrapper(pal.main)\n</code></pre>"},{"location":"reference/api/cli/#axium.core.cli.main","title":"<code>main()</code>","text":"<p>CLI entrypoint.</p> <p>Called when axium is invoked from the command line (via setup.py entry point). Initializes Typer app and processes commands.</p> Source code in <code>axium/core/cli.py</code> <pre><code>def main() -&gt; None:\n    \"\"\"\n    CLI entrypoint.\n\n    Called when axium is invoked from the command line (via setup.py entry point).\n    Initializes Typer app and processes commands.\n    \"\"\"\n    import sys\n\n    # Intercept Typer's legacy completion flags for backward compatibility\n    # Redirect users to new `axium completions install` system\n    if \"--install-completion\" in sys.argv or \"--show-completion\" in sys.argv:\n        sys.argv = [\"axium\", \"completions\", \"install\"]\n\n    # Load spokes before dispatching command\n    # This must happen here (not in callback) so Typer can find spoke commands\n    if not _autoload_done:\n        _autoload()\n\n    app()\n</code></pre>"},{"location":"reference/api/core/","title":"Core API","text":"<p>Core modules providing Axium's foundational functionality.</p>"},{"location":"reference/api/core/#env","title":"env","text":"<p>Environment management and configuration.</p>"},{"location":"reference/api/core/#axium.core.env","title":"<code>env</code>","text":"<p>Environment abstraction layer for Axium.</p> <p>Provides access to environment configuration from envs.yaml and tracks the active environment in state.json. All environment properties are accessible via template expansion ${env.}. <p>Example envs.yaml:     <pre><code>envs:\n  root:\n    prefix: enva-root\n    aws_profile: root\n    color: teal\n    region: eu-west-1\n  builder:\n    prefix: enva-builder\n    aws_profile: builder\n    color: cyan\n    region: eu-west-2\n</code></pre></p> <p>Example state.json:     <pre><code>{\"active_env\": \"root\"}\n</code></pre></p> Usage <pre><code>&gt;&gt;&gt; import axium.core.env as env\n&gt;&gt;&gt; env.get_active_env_name()\n'root'\n&gt;&gt;&gt; env.get_env_value('prefix')\n'enva-root'\n&gt;&gt;&gt; env.get_env_value('region')\n'eu-west-1'\n</code></pre>"},{"location":"reference/api/core/#axium.core.env.load_envs","title":"<code>load_envs()</code>","text":"<p>Load all environments from envs.yaml.</p> <p>Returns:</p> Type Description <code>dict[str, dict[str, Any]]</code> <p>Dictionary mapping environment names to their properties.</p> <code>dict[str, dict[str, Any]]</code> <p>Returns empty dict if file doesn't exist or is invalid.</p> Example <pre><code>&gt;&gt;&gt; load_envs()\n{'root': {'prefix': 'enva-root', 'region': 'eu-west-1'}, ...}\n</code></pre> Source code in <code>axium/core/env.py</code> <pre><code>def load_envs() -&gt; dict[str, dict[str, Any]]:\n    \"\"\"\n    Load all environments from envs.yaml.\n\n    Returns:\n        Dictionary mapping environment names to their properties.\n        Returns empty dict if file doesn't exist or is invalid.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; load_envs()\n        {'root': {'prefix': 'enva-root', 'region': 'eu-west-1'}, ...}\n        ```\n    \"\"\"\n    if not ENVS_PATH.exists():\n        logger.debug(\"No envs.yaml found at %s\", ENVS_PATH)\n        return {}\n\n    try:\n        data = yaml.safe_load(ENVS_PATH.read_text())\n        if not data or \"envs\" not in data:\n            logger.warning(\"envs.yaml missing 'envs' key\")\n            return {}\n\n        envs = data[\"envs\"]\n        if not isinstance(envs, dict):\n            logger.warning(\"envs.yaml 'envs' is not a dictionary\")\n            return {}\n\n        logger.debug(\"Loaded %d environments from envs.yaml\", len(envs))\n        return envs\n\n    except Exception as e:\n        logger.error(\"Failed to load envs.yaml: %s\", e)\n        return {}\n</code></pre>"},{"location":"reference/api/core/#axium.core.env.get_active_env_name","title":"<code>get_active_env_name()</code>","text":"<p>Get the name of the currently active environment from state.json.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>Active environment name, or None if not set or file missing.</p> Example <pre><code>&gt;&gt;&gt; get_active_env_name()\n'root'\n</code></pre> Source code in <code>axium/core/env.py</code> <pre><code>def get_active_env_name() -&gt; str | None:\n    \"\"\"\n    Get the name of the currently active environment from state.json.\n\n    Returns:\n        Active environment name, or None if not set or file missing.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; get_active_env_name()\n        'root'\n        ```\n    \"\"\"\n    if not STATE_PATH.exists():\n        logger.debug(\"No state.json found at %s\", STATE_PATH)\n        return None\n\n    try:\n        data = json.loads(STATE_PATH.read_text())\n        active_env = data.get(\"active_env\")\n        logger.debug(\"Active environment: %s\", active_env)\n        return active_env\n\n    except Exception as e:\n        logger.error(\"Failed to load state.json: %s\", e)\n        return None\n</code></pre>"},{"location":"reference/api/core/#axium.core.env.get_active_env","title":"<code>get_active_env()</code>","text":"<p>Get the full configuration dictionary for the active environment.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary of environment properties, or empty dict if no active env</p> <code>dict[str, Any]</code> <p>or environment not found in envs.yaml.</p> Example <pre><code>&gt;&gt;&gt; get_active_env()\n{'prefix': 'enva-root', 'aws_profile': 'root', 'region': 'eu-west-1'}\n</code></pre> Source code in <code>axium/core/env.py</code> <pre><code>def get_active_env() -&gt; dict[str, Any]:\n    \"\"\"\n    Get the full configuration dictionary for the active environment.\n\n    Returns:\n        Dictionary of environment properties, or empty dict if no active env\n        or environment not found in envs.yaml.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; get_active_env()\n        {'prefix': 'enva-root', 'aws_profile': 'root', 'region': 'eu-west-1'}\n        ```\n    \"\"\"\n    env_name = get_active_env_name()\n    if not env_name:\n        logger.debug(\"No active environment set\")\n        return {}\n\n    envs = load_envs()\n    env_data = envs.get(env_name, {})\n\n    if not env_data:\n        logger.warning(\"Active environment '%s' not found in envs.yaml\", env_name)\n\n    return env_data\n</code></pre>"},{"location":"reference/api/core/#axium.core.env.get_env_value","title":"<code>get_env_value(key)</code>","text":"<p>Get a specific property value from the active environment.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Property name (e.g., \"prefix\", \"region\", \"aws_profile\")</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Property value, or None if key doesn't exist or no active env.</p> Example <pre><code>&gt;&gt;&gt; get_env_value('prefix')\n'enva-root'\n&gt;&gt;&gt; get_env_value('region')\n'eu-west-1'\n&gt;&gt;&gt; get_env_value('nonexistent')\nNone\n</code></pre> Source code in <code>axium/core/env.py</code> <pre><code>def get_env_value(key: str) -&gt; Any:\n    \"\"\"\n    Get a specific property value from the active environment.\n\n    Args:\n        key: Property name (e.g., \"prefix\", \"region\", \"aws_profile\")\n\n    Returns:\n        Property value, or None if key doesn't exist or no active env.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; get_env_value('prefix')\n        'enva-root'\n        &gt;&gt;&gt; get_env_value('region')\n        'eu-west-1'\n        &gt;&gt;&gt; get_env_value('nonexistent')\n        None\n        ```\n    \"\"\"\n    env_data = get_active_env()\n    value = env_data.get(key)\n\n    if value is None:\n        logger.debug(\"Key '%s' not found in active environment\", key)\n\n    return value\n</code></pre>"},{"location":"reference/api/core/#axium.core.env.validate_env_name","title":"<code>validate_env_name(name)</code>","text":"<p>Validate that an environment name exists in envs.yaml.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Environment name to validate</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Tuple of (is_valid, error_message).</p> <code>str | None</code> <p>If valid: (True, None)</p> <code>tuple[bool, str | None]</code> <p>If invalid: (False, \"error message with suggestions\")</p> Example <pre><code>&gt;&gt;&gt; validate_env_name(\"root\")\n(True, None)\n&gt;&gt;&gt; validate_env_name(\"invalid\")\n(False, \"Unknown environment: invalid\\nDid you mean: root, prod?\")\n&gt;&gt;&gt; validate_env_name(None)\n(False, \"Environment name cannot be empty\")\n</code></pre> Source code in <code>axium/core/env.py</code> <pre><code>def validate_env_name(name: str | None) -&gt; tuple[bool, str | None]:\n    \"\"\"\n    Validate that an environment name exists in envs.yaml.\n\n    Args:\n        name: Environment name to validate\n\n    Returns:\n        Tuple of (is_valid, error_message).\n        If valid: (True, None)\n        If invalid: (False, \"error message with suggestions\")\n\n    Example:\n        ```python\n        &gt;&gt;&gt; validate_env_name(\"root\")\n        (True, None)\n        &gt;&gt;&gt; validate_env_name(\"invalid\")\n        (False, \"Unknown environment: invalid\\\\nDid you mean: root, prod?\")\n        &gt;&gt;&gt; validate_env_name(None)\n        (False, \"Environment name cannot be empty\")\n        ```\n    \"\"\"\n    if not name:\n        return False, \"Environment name cannot be empty\"\n\n    envs = load_envs()\n\n    if not envs:\n        # No envs.yaml file - warn but allow (for initial setup)\n        logger.warning(\"No environments configured in envs.yaml\")\n        return True, None\n\n    if name in envs:\n        return True, None\n\n    # Environment not found - build error with suggestions\n    import difflib\n\n    suggestions = difflib.get_close_matches(name, envs.keys(), n=3, cutoff=0.6)\n\n    if suggestions:\n        error = f\"Unknown environment: {name}\\nDid you mean: {', '.join(suggestions)}?\"\n    else:\n        error = f\"Unknown environment: {name}\"\n\n    return False, error\n</code></pre>"},{"location":"reference/api/core/#prefix","title":"prefix","text":"<p>Command prefix system and template expansion.</p>"},{"location":"reference/api/core/#axium.core.prefix","title":"<code>prefix</code>","text":"<p>Prefix system for command wrapping.</p> <p>This module handles loading prefix rules from configuration and applying them to commands based on context (environment, pane, etc.).</p>"},{"location":"reference/api/core/#axium.core.prefix.PrefixRegistry","title":"<code>PrefixRegistry</code>","text":"<p>Registry for command prefix rules.</p> <p>Tracks rules from both prefixes.yaml and programmatic registration (from spokes/gears). Provides conflict detection to prevent multiple components from registering the same command.</p> Source code in <code>axium/core/prefix.py</code> <pre><code>class PrefixRegistry:\n    \"\"\"\n    Registry for command prefix rules.\n\n    Tracks rules from both prefixes.yaml and programmatic registration\n    (from spokes/gears). Provides conflict detection to prevent multiple\n    components from registering the same command.\n    \"\"\"\n\n    def __init__(self):\n        self.rules: list[dict[str, Any]] = []\n        self.owners: dict[str, str] = {}  # {command: owner_name} for conflict detection\n        self._load_yaml_rules()\n\n    def _load_yaml_rules(self) -&gt; None:\n        \"\"\"Load prefix rules from prefixes.yaml.\"\"\"\n        if not PREFIXES_PATH.exists():\n            logger.debug(\"No prefixes.yaml found at %s\", PREFIXES_PATH)\n            return\n\n        try:\n            data = yaml.safe_load(PREFIXES_PATH.read_text())\n            rules = data.get(\"prefixes\", [])\n            for rule in rules:\n                if \"command\" in rule and \"prefix\" in rule:\n                    # Mark yaml rules as owned by \"config\"\n                    rule_with_owner = rule.copy()\n                    if \"owner\" not in rule_with_owner:\n                        rule_with_owner[\"owner\"] = \"config\"\n                    self.rules.append(rule_with_owner)\n                    self.owners[rule[\"command\"]] = rule_with_owner[\"owner\"]\n            logger.info(\"Loaded %d prefix rules from prefixes.yaml\", len(self.rules))\n        except Exception as e:\n            logger.error(\"Failed to load prefixes.yaml: %s\", e)\n\n    def register_rule(self, command: str, wrapper: str, owner: str) -&gt; bool:\n        \"\"\"\n        Register a prefix rule programmatically (for Spokes/Gears).\n\n        Args:\n            command: Command to intercept (e.g., \"ansible-playbook\")\n            wrapper: Wrapper command (e.g., \"axium ansible-run\")\n            owner: Name of spoke/gear registering this rule\n\n        Returns:\n            True if registered successfully, False if conflict detected\n\n        Example:\n            ```python\n            &gt;&gt;&gt; registry = PrefixRegistry()\n            &gt;&gt;&gt; registry.register_rule(\"ansible-playbook\", \"axium ansible-run\", \"ansible\")\n            True\n            &gt;&gt;&gt; registry.register_rule(\"ansible-playbook\", \"other command\", \"terraform\")\n            False  # Conflict!\n            ```\n\n        Note:\n            Logs warning and returns False on conflict.\n            Use get_rule_owner() to check current owner before registering.\n        \"\"\"\n        # Check for conflict\n        if command in self.owners:\n            existing_owner = self.owners[command]\n            if existing_owner != owner:\n                logger.warning(\n                    \"Prefix conflict: '%s' tried to register command '%s' but already owned by '%s'\",\n                    owner,\n                    command,\n                    existing_owner,\n                )\n                return False\n            else:\n                # Same owner re-registering (e.g., during reload) - allow and update\n                logger.debug(\n                    \"Updating prefix rule for command '%s' (owner: %s)\", command, owner\n                )\n                # Remove old rule\n                self.rules = [\n                    r\n                    for r in self.rules\n                    if r.get(\"command\") != command or r.get(\"owner\") != owner\n                ]\n\n        # Register new rule\n        rule = {\n            \"command\": command,\n            \"prefix\": wrapper,  # Note: using 'prefix' key for consistency with yaml format\n            \"owner\": owner,\n        }\n        self.rules.append(rule)\n        self.owners[command] = owner\n        logger.info(\n            \"Registered prefix rule: %s \u2192 %s (owner: %s)\", command, wrapper, owner\n        )\n        return True\n\n    def unregister_rules_for_owner(self, owner: str) -&gt; int:\n        \"\"\"\n        Unregister all prefix rules for a specific owner (spoke/gear).\n\n        Used when unloading a spoke/gear to clean up its registered rules.\n\n        Args:\n            owner: Name of spoke/gear to remove rules for\n\n        Returns:\n            Number of rules removed\n\n        Example:\n            ```python\n            &gt;&gt;&gt; registry.unregister_rules_for_owner(\"ansible\")\n            2  # Removed 2 rules\n            ```\n        \"\"\"\n        removed_commands = [\n            cmd for cmd, cmd_owner in self.owners.items() if cmd_owner == owner\n        ]\n        self.rules = [r for r in self.rules if r.get(\"owner\") != owner]\n\n        for cmd in removed_commands:\n            del self.owners[cmd]\n\n        if removed_commands:\n            logger.info(\n                \"Unregistered %d prefix rules for owner: %s\",\n                len(removed_commands),\n                owner,\n            )\n\n        return len(removed_commands)\n\n    def get_rule_owner(self, command: str) -&gt; str | None:\n        \"\"\"\n        Get the owner (spoke/gear name) of a prefix rule.\n\n        Args:\n            command: Command to check\n\n        Returns:\n            Owner name or None if no rule registered\n\n        Example:\n            ```python\n            &gt;&gt;&gt; registry.get_rule_owner(\"ansible-playbook\")\n            'ansible'\n            ```\n        \"\"\"\n        return self.owners.get(command)\n\n    def get_all_rules(self) -&gt; list[dict[str, Any]]:\n        \"\"\"\n        Get all registered prefix rules with metadata.\n\n        Returns:\n            List of rule dicts with command, prefix/wrapper, and owner\n\n        Example:\n            ```python\n            &gt;&gt;&gt; rules = registry.get_all_rules()\n            &gt;&gt;&gt; for rule in rules:\n            ...     print(f\"{rule['command']} owned by {rule['owner']}\")\n            ```\n        \"\"\"\n        return self.rules.copy()\n\n    def get_prefixed_commands(self) -&gt; list[str]:\n        \"\"\"Get list of all commands that have prefix rules.\"\"\"\n        commands = set()\n        for rule in self.rules:\n            commands.add(rule[\"command\"])\n        return sorted(commands)\n\n    def apply_prefixes(\n        self, command: str, args: list[str], context: dict[str, Any]\n    ) -&gt; tuple[list[str], dict[str, str]]:\n        \"\"\"\n        Apply prefix rules to a command.\n\n        Args:\n            command: The command to prefix (e.g., \"aws\")\n            args: Command arguments (e.g., [\"s3\", \"ls\"])\n            context: Context dict with 'env', 'pane', etc.\n\n        Returns:\n            Tuple of (command_array, env_vars)\n            command_array: Full command to execute\n                (e.g., [\"enva-root\", \"aws\", \"s3\", \"ls\"])\n            env_vars: Environment variables to set\n                (currently unused, for future)\n        \"\"\"\n        # Find matching rules for this command\n        matching_rules = [r for r in self.rules if r[\"command\"] == command]\n\n        if not matching_rules:\n            # No rules, return unwrapped command\n            return ([command] + args, {})\n\n        # Apply first matching rule (TODO: support multiple rules/conditions)\n        rule = matching_rules[0]\n        prefix_template = rule[\"prefix\"]\n\n        # Expand template variables\n        expanded_prefix = self._expand_template(prefix_template, context)\n\n        if not expanded_prefix:\n            # Template expansion failed (e.g., missing variable)\n            logger.warning(\"Failed to expand prefix template: %s\", prefix_template)\n            return ([command] + args, {})\n\n        # Return prefixed command\n        final_command = [expanded_prefix, command] + args\n        logger.debug(\"Prefixed command: %s\", \" \".join(final_command))\n        return (final_command, {})\n\n    def _expand_template(self, template: str, context: dict[str, Any]) -&gt; str:\n        \"\"\"\n        Expand template variables.\n\n        Supports two types of variables:\n        1. ${env.&lt;key&gt;} - Environment properties from envs.yaml\n        2. ${var} - Context variables (tmux_pane, etc.)\n\n        Args:\n            template: Template string\n                (e.g., \"${env.prefix}\" or \"pane-${tmux_pane}\")\n            context: Context dict with variable values\n                (must include 'env' key with environment name)\n\n        Returns:\n            Expanded string, or empty string if required variables missing\n        \"\"\"\n        # First, expand ${env.&lt;key&gt;} variables from envs.yaml\n        # Load environment data from context if available\n        env_dict = None\n        env_name = context.get(\"env\")\n        if env_name:\n            # Load the specific environment's data\n            envs = env.load_envs()\n            env_dict = envs.get(env_name, {})\n\n        # Use expand_template directly with the loaded env_dict\n        from axium.core.utils import expand_template\n\n        result = expand_template(\n            template,\n            env_dict=env_dict,\n            expand_tilde=False,\n            expand_env_vars=False,\n            expand_env_keys=True,\n        )\n\n        # If expansion failed (returned original and had env vars), fail\n        if result == template and re.search(r\"\\$\\{env\\.\", template):\n            # Had ${env.} variables but they didn't expand\n            return \"\"\n\n        # Now expand context variables like ${tmux_pane}\n        pattern = r\"\\$\\{([^}]+)\\}\"\n        matches = re.findall(pattern, result)\n\n        if not matches:\n            # No more template variables\n            return result\n\n        for var_name in matches:\n            # Skip env.* variables (already handled)\n            if var_name.startswith(\"env.\"):\n                continue\n\n            # Map context variables\n            if var_name == \"tmux_pane\":\n                value = context.get(\"pane\")\n            else:\n                value = context.get(var_name)\n\n            if value is None:\n                # Required variable missing\n                logger.debug(\"Template variable ${%s} not found in context\", var_name)\n                return \"\"\n\n            # Replace ${var} with value\n            result = result.replace(f\"${{{var_name}}}\", str(value))\n\n        return result\n</code></pre>"},{"location":"reference/api/core/#axium.core.prefix.PrefixRegistry.register_rule","title":"<code>register_rule(command, wrapper, owner)</code>","text":"<p>Register a prefix rule programmatically (for Spokes/Gears).</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>Command to intercept (e.g., \"ansible-playbook\")</p> required <code>wrapper</code> <code>str</code> <p>Wrapper command (e.g., \"axium ansible-run\")</p> required <code>owner</code> <code>str</code> <p>Name of spoke/gear registering this rule</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if registered successfully, False if conflict detected</p> Example <pre><code>&gt;&gt;&gt; registry = PrefixRegistry()\n&gt;&gt;&gt; registry.register_rule(\"ansible-playbook\", \"axium ansible-run\", \"ansible\")\nTrue\n&gt;&gt;&gt; registry.register_rule(\"ansible-playbook\", \"other command\", \"terraform\")\nFalse  # Conflict!\n</code></pre> Note <p>Logs warning and returns False on conflict. Use get_rule_owner() to check current owner before registering.</p> Source code in <code>axium/core/prefix.py</code> <pre><code>def register_rule(self, command: str, wrapper: str, owner: str) -&gt; bool:\n    \"\"\"\n    Register a prefix rule programmatically (for Spokes/Gears).\n\n    Args:\n        command: Command to intercept (e.g., \"ansible-playbook\")\n        wrapper: Wrapper command (e.g., \"axium ansible-run\")\n        owner: Name of spoke/gear registering this rule\n\n    Returns:\n        True if registered successfully, False if conflict detected\n\n    Example:\n        ```python\n        &gt;&gt;&gt; registry = PrefixRegistry()\n        &gt;&gt;&gt; registry.register_rule(\"ansible-playbook\", \"axium ansible-run\", \"ansible\")\n        True\n        &gt;&gt;&gt; registry.register_rule(\"ansible-playbook\", \"other command\", \"terraform\")\n        False  # Conflict!\n        ```\n\n    Note:\n        Logs warning and returns False on conflict.\n        Use get_rule_owner() to check current owner before registering.\n    \"\"\"\n    # Check for conflict\n    if command in self.owners:\n        existing_owner = self.owners[command]\n        if existing_owner != owner:\n            logger.warning(\n                \"Prefix conflict: '%s' tried to register command '%s' but already owned by '%s'\",\n                owner,\n                command,\n                existing_owner,\n            )\n            return False\n        else:\n            # Same owner re-registering (e.g., during reload) - allow and update\n            logger.debug(\n                \"Updating prefix rule for command '%s' (owner: %s)\", command, owner\n            )\n            # Remove old rule\n            self.rules = [\n                r\n                for r in self.rules\n                if r.get(\"command\") != command or r.get(\"owner\") != owner\n            ]\n\n    # Register new rule\n    rule = {\n        \"command\": command,\n        \"prefix\": wrapper,  # Note: using 'prefix' key for consistency with yaml format\n        \"owner\": owner,\n    }\n    self.rules.append(rule)\n    self.owners[command] = owner\n    logger.info(\n        \"Registered prefix rule: %s \u2192 %s (owner: %s)\", command, wrapper, owner\n    )\n    return True\n</code></pre>"},{"location":"reference/api/core/#axium.core.prefix.PrefixRegistry.unregister_rules_for_owner","title":"<code>unregister_rules_for_owner(owner)</code>","text":"<p>Unregister all prefix rules for a specific owner (spoke/gear).</p> <p>Used when unloading a spoke/gear to clean up its registered rules.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>str</code> <p>Name of spoke/gear to remove rules for</p> required <p>Returns:</p> Type Description <code>int</code> <p>Number of rules removed</p> Example <pre><code>&gt;&gt;&gt; registry.unregister_rules_for_owner(\"ansible\")\n2  # Removed 2 rules\n</code></pre> Source code in <code>axium/core/prefix.py</code> <pre><code>def unregister_rules_for_owner(self, owner: str) -&gt; int:\n    \"\"\"\n    Unregister all prefix rules for a specific owner (spoke/gear).\n\n    Used when unloading a spoke/gear to clean up its registered rules.\n\n    Args:\n        owner: Name of spoke/gear to remove rules for\n\n    Returns:\n        Number of rules removed\n\n    Example:\n        ```python\n        &gt;&gt;&gt; registry.unregister_rules_for_owner(\"ansible\")\n        2  # Removed 2 rules\n        ```\n    \"\"\"\n    removed_commands = [\n        cmd for cmd, cmd_owner in self.owners.items() if cmd_owner == owner\n    ]\n    self.rules = [r for r in self.rules if r.get(\"owner\") != owner]\n\n    for cmd in removed_commands:\n        del self.owners[cmd]\n\n    if removed_commands:\n        logger.info(\n            \"Unregistered %d prefix rules for owner: %s\",\n            len(removed_commands),\n            owner,\n        )\n\n    return len(removed_commands)\n</code></pre>"},{"location":"reference/api/core/#axium.core.prefix.PrefixRegistry.get_rule_owner","title":"<code>get_rule_owner(command)</code>","text":"<p>Get the owner (spoke/gear name) of a prefix rule.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>Command to check</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>Owner name or None if no rule registered</p> Example <pre><code>&gt;&gt;&gt; registry.get_rule_owner(\"ansible-playbook\")\n'ansible'\n</code></pre> Source code in <code>axium/core/prefix.py</code> <pre><code>def get_rule_owner(self, command: str) -&gt; str | None:\n    \"\"\"\n    Get the owner (spoke/gear name) of a prefix rule.\n\n    Args:\n        command: Command to check\n\n    Returns:\n        Owner name or None if no rule registered\n\n    Example:\n        ```python\n        &gt;&gt;&gt; registry.get_rule_owner(\"ansible-playbook\")\n        'ansible'\n        ```\n    \"\"\"\n    return self.owners.get(command)\n</code></pre>"},{"location":"reference/api/core/#axium.core.prefix.PrefixRegistry.get_all_rules","title":"<code>get_all_rules()</code>","text":"<p>Get all registered prefix rules with metadata.</p> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of rule dicts with command, prefix/wrapper, and owner</p> Example <pre><code>&gt;&gt;&gt; rules = registry.get_all_rules()\n&gt;&gt;&gt; for rule in rules:\n...     print(f\"{rule['command']} owned by {rule['owner']}\")\n</code></pre> Source code in <code>axium/core/prefix.py</code> <pre><code>def get_all_rules(self) -&gt; list[dict[str, Any]]:\n    \"\"\"\n    Get all registered prefix rules with metadata.\n\n    Returns:\n        List of rule dicts with command, prefix/wrapper, and owner\n\n    Example:\n        ```python\n        &gt;&gt;&gt; rules = registry.get_all_rules()\n        &gt;&gt;&gt; for rule in rules:\n        ...     print(f\"{rule['command']} owned by {rule['owner']}\")\n        ```\n    \"\"\"\n    return self.rules.copy()\n</code></pre>"},{"location":"reference/api/core/#axium.core.prefix.PrefixRegistry.get_prefixed_commands","title":"<code>get_prefixed_commands()</code>","text":"<p>Get list of all commands that have prefix rules.</p> Source code in <code>axium/core/prefix.py</code> <pre><code>def get_prefixed_commands(self) -&gt; list[str]:\n    \"\"\"Get list of all commands that have prefix rules.\"\"\"\n    commands = set()\n    for rule in self.rules:\n        commands.add(rule[\"command\"])\n    return sorted(commands)\n</code></pre>"},{"location":"reference/api/core/#axium.core.prefix.PrefixRegistry.apply_prefixes","title":"<code>apply_prefixes(command, args, context)</code>","text":"<p>Apply prefix rules to a command.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>The command to prefix (e.g., \"aws\")</p> required <code>args</code> <code>list[str]</code> <p>Command arguments (e.g., [\"s3\", \"ls\"])</p> required <code>context</code> <code>dict[str, Any]</code> <p>Context dict with 'env', 'pane', etc.</p> required <p>Returns:</p> Name Type Description <code>list[str]</code> <p>Tuple of (command_array, env_vars)</p> <code>command_array</code> <code>dict[str, str]</code> <p>Full command to execute (e.g., [\"enva-root\", \"aws\", \"s3\", \"ls\"])</p> <code>env_vars</code> <code>tuple[list[str], dict[str, str]]</code> <p>Environment variables to set (currently unused, for future)</p> Source code in <code>axium/core/prefix.py</code> <pre><code>def apply_prefixes(\n    self, command: str, args: list[str], context: dict[str, Any]\n) -&gt; tuple[list[str], dict[str, str]]:\n    \"\"\"\n    Apply prefix rules to a command.\n\n    Args:\n        command: The command to prefix (e.g., \"aws\")\n        args: Command arguments (e.g., [\"s3\", \"ls\"])\n        context: Context dict with 'env', 'pane', etc.\n\n    Returns:\n        Tuple of (command_array, env_vars)\n        command_array: Full command to execute\n            (e.g., [\"enva-root\", \"aws\", \"s3\", \"ls\"])\n        env_vars: Environment variables to set\n            (currently unused, for future)\n    \"\"\"\n    # Find matching rules for this command\n    matching_rules = [r for r in self.rules if r[\"command\"] == command]\n\n    if not matching_rules:\n        # No rules, return unwrapped command\n        return ([command] + args, {})\n\n    # Apply first matching rule (TODO: support multiple rules/conditions)\n    rule = matching_rules[0]\n    prefix_template = rule[\"prefix\"]\n\n    # Expand template variables\n    expanded_prefix = self._expand_template(prefix_template, context)\n\n    if not expanded_prefix:\n        # Template expansion failed (e.g., missing variable)\n        logger.warning(\"Failed to expand prefix template: %s\", prefix_template)\n        return ([command] + args, {})\n\n    # Return prefixed command\n    final_command = [expanded_prefix, command] + args\n    logger.debug(\"Prefixed command: %s\", \" \".join(final_command))\n    return (final_command, {})\n</code></pre>"},{"location":"reference/api/core/#axium.core.prefix.expand_env_vars","title":"<code>expand_env_vars(template)</code>","text":"<p>Expand ${env.} template variables using active environment data. <p>This function resolves environment property references in templates by looking them up in the active environment from envs.yaml.</p> <p>Parameters:</p> Name Type Description Default <code>template</code> <code>str</code> <p>Template string with ${env.} patterns      (e.g., \"Using ${env.prefix} in ${env.region}\") required <p>Returns:</p> Type Description <code>str</code> <p>Expanded string with variables replaced, or original string if</p> <code>str</code> <p>no active environment or variables not found.</p> Example <pre><code>&gt;&gt;&gt; # Assuming active env is \"root\" with prefix=\"enva-root\"\n&gt;&gt;&gt; expand_env_vars(\"${env.prefix}\")\n'enva-root'\n&gt;&gt;&gt; expand_env_vars(\"Using ${env.prefix} in ${env.region}\")\n'Using enva-root in eu-west-1'\n&gt;&gt;&gt; expand_env_vars(\"No variables here\")\n'No variables here'\n</code></pre> Note <p>This function now wraps axium.core.utils.expand_template for consistency.</p> Source code in <code>axium/core/prefix.py</code> <pre><code>def expand_env_vars(template: str) -&gt; str:\n    \"\"\"\n    Expand ${env.&lt;key&gt;} template variables using active environment data.\n\n    This function resolves environment property references in templates by\n    looking them up in the active environment from envs.yaml.\n\n    Args:\n        template: Template string with ${env.&lt;key&gt;} patterns\n                 (e.g., \"Using ${env.prefix} in ${env.region}\")\n\n    Returns:\n        Expanded string with variables replaced, or original string if\n        no active environment or variables not found.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; # Assuming active env is \"root\" with prefix=\"enva-root\"\n        &gt;&gt;&gt; expand_env_vars(\"${env.prefix}\")\n        'enva-root'\n        &gt;&gt;&gt; expand_env_vars(\"Using ${env.prefix} in ${env.region}\")\n        'Using enva-root in eu-west-1'\n        &gt;&gt;&gt; expand_env_vars(\"No variables here\")\n        'No variables here'\n        ```\n\n    Note:\n        This function now wraps axium.core.utils.expand_template for consistency.\n    \"\"\"\n    from axium.core.utils import expand_template\n\n    return expand_template(\n        template,\n        env_dict=None,  # Will auto-load from active environment\n        expand_tilde=False,  # Only expand env vars\n        expand_env_vars=False,  # Don't expand $VAR\n        expand_env_keys=True,  # Only expand ${env.key}\n    )\n</code></pre>"},{"location":"reference/api/core/#axium.core.prefix.get_registry","title":"<code>get_registry()</code>","text":"<p>Get the global prefix registry (singleton).</p> Source code in <code>axium/core/prefix.py</code> <pre><code>def get_registry() -&gt; PrefixRegistry:\n    \"\"\"Get the global prefix registry (singleton).\"\"\"\n    global _registry\n    if _registry is None:\n        _registry = PrefixRegistry()\n    return _registry\n</code></pre>"},{"location":"reference/api/core/#axium.core.prefix.apply_prefixes","title":"<code>apply_prefixes(command, args, context)</code>","text":"<p>Apply prefix rules to a command.</p> Source code in <code>axium/core/prefix.py</code> <pre><code>def apply_prefixes(\n    command: str, args: list[str], context: dict[str, Any]\n) -&gt; tuple[list[str], dict[str, str]]:\n    \"\"\"Apply prefix rules to a command.\"\"\"\n    return get_registry().apply_prefixes(command, args, context)\n</code></pre>"},{"location":"reference/api/core/#axium.core.prefix.get_prefixed_commands","title":"<code>get_prefixed_commands()</code>","text":"<p>Get list of all commands with prefix rules.</p> Source code in <code>axium/core/prefix.py</code> <pre><code>def get_prefixed_commands() -&gt; list[str]:\n    \"\"\"Get list of all commands with prefix rules.\"\"\"\n    return get_registry().get_prefixed_commands()\n</code></pre>"},{"location":"reference/api/core/#axium.core.prefix.register_prefix_rule","title":"<code>register_prefix_rule(command, wrapper, owner)</code>","text":"<p>Register a prefix rule (for Spokes/Gears to call).</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>Command to intercept</p> required <code>wrapper</code> <code>str</code> <p>Wrapper command to execute instead</p> required <code>owner</code> <code>str</code> <p>Name of spoke/gear registering the rule</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if registered, False if conflict detected</p> Example <pre><code>&gt;&gt;&gt; from axium.core import prefix\n&gt;&gt;&gt; prefix.register_prefix_rule(\"terraform\", \"axium tf-run\", \"terraform-gear\")\nTrue\n</code></pre> Source code in <code>axium/core/prefix.py</code> <pre><code>def register_prefix_rule(command: str, wrapper: str, owner: str) -&gt; bool:\n    \"\"\"\n    Register a prefix rule (for Spokes/Gears to call).\n\n    Args:\n        command: Command to intercept\n        wrapper: Wrapper command to execute instead\n        owner: Name of spoke/gear registering the rule\n\n    Returns:\n        True if registered, False if conflict detected\n\n    Example:\n        ```python\n        &gt;&gt;&gt; from axium.core import prefix\n        &gt;&gt;&gt; prefix.register_prefix_rule(\"terraform\", \"axium tf-run\", \"terraform-gear\")\n        True\n        ```\n    \"\"\"\n    return get_registry().register_rule(command, wrapper, owner)\n</code></pre>"},{"location":"reference/api/core/#axium.core.prefix.unregister_rules_for_owner","title":"<code>unregister_rules_for_owner(owner)</code>","text":"<p>Unregister all prefix rules for an owner.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>str</code> <p>Name of spoke/gear</p> required <p>Returns:</p> Type Description <code>int</code> <p>Number of rules removed</p> Source code in <code>axium/core/prefix.py</code> <pre><code>def unregister_rules_for_owner(owner: str) -&gt; int:\n    \"\"\"\n    Unregister all prefix rules for an owner.\n\n    Args:\n        owner: Name of spoke/gear\n\n    Returns:\n        Number of rules removed\n    \"\"\"\n    return get_registry().unregister_rules_for_owner(owner)\n</code></pre>"},{"location":"reference/api/core/#axium.core.prefix.get_rule_owner","title":"<code>get_rule_owner(command)</code>","text":"<p>Get the owner of a prefix rule.</p> Source code in <code>axium/core/prefix.py</code> <pre><code>def get_rule_owner(command: str) -&gt; str | None:\n    \"\"\"Get the owner of a prefix rule.\"\"\"\n    return get_registry().get_rule_owner(command)\n</code></pre>"},{"location":"reference/api/core/#axium.core.prefix.get_all_rules","title":"<code>get_all_rules()</code>","text":"<p>Get all registered prefix rules.</p> Source code in <code>axium/core/prefix.py</code> <pre><code>def get_all_rules() -&gt; list[dict[str, Any]]:\n    \"\"\"Get all registered prefix rules.\"\"\"\n    return get_registry().get_all_rules()\n</code></pre>"},{"location":"reference/api/core/#axium.core.prefix.reload_config","title":"<code>reload_config()</code>","text":"<p>Reload prefixes.yaml configuration.</p> Source code in <code>axium/core/prefix.py</code> <pre><code>def reload_config() -&gt; None:\n    \"\"\"Reload prefixes.yaml configuration.\"\"\"\n    global _registry\n    _registry = PrefixRegistry()\n    logger.info(\"Reloaded prefix configuration\")\n</code></pre>"},{"location":"reference/api/core/#bootstrap","title":"bootstrap","text":"<p>Self-bootstrapping initialization system.</p>"},{"location":"reference/api/core/#axium.core.bootstrap","title":"<code>bootstrap</code>","text":"<p>Bootstrap module for Axium self-initialization.</p> <p>Ensures Axium config directory and default files exist on first run. Handles graceful initialization without overwriting existing user data.</p>"},{"location":"reference/api/core/#axium.core.bootstrap.update_init_scripts","title":"<code>update_init_scripts()</code>","text":"<p>Force update shell integration scripts (bash/init.sh, tmux/init.sh).</p> <p>This function overwrites existing init scripts with the latest versions from the package. It does NOT modify user configuration files.</p> <p>Use this after upgrading Axium to get the latest shell integrations.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If script update fails</p> Source code in <code>axium/core/bootstrap.py</code> <pre><code>def update_init_scripts() -&gt; None:\n    \"\"\"\n    Force update shell integration scripts (bash/init.sh, tmux/init.sh).\n\n    This function overwrites existing init scripts with the latest versions\n    from the package. It does NOT modify user configuration files.\n\n    Use this after upgrading Axium to get the latest shell integrations.\n\n    Raises:\n        Exception: If script update fails\n    \"\"\"\n    try:\n        # Ensure directories exist\n        BASH_DIR.mkdir(parents=True, exist_ok=True)\n        TMUX_DIR.mkdir(parents=True, exist_ok=True)\n\n        # Remove old scripts if they exist\n        if BASH_INIT_PATH.exists():\n            BASH_INIT_PATH.unlink()\n        if TMUX_INIT_PATH.exists():\n            TMUX_INIT_PATH.unlink()\n\n        # Create fresh scripts\n        _create_bash_init()\n        _create_tmux_init()\n\n        logger.info(\"Updated shell integration scripts\")\n    except Exception as e:\n        logger.error(\"Failed to update init scripts: %s\", e)\n        raise\n</code></pre>"},{"location":"reference/api/core/#axium.core.bootstrap.ensure_axium_config","title":"<code>ensure_axium_config()</code>","text":"<p>Ensure Axium config directory and files exist.</p> <p>Creates ~/.config/axium/ with default configuration files if missing. Never overwrites existing files.</p> Creates <ul> <li>~/.config/axium/ (directory)</li> <li>envs.yaml (with root/builder defaults)</li> <li>prefixes.yaml (with aws/terraform defaults)</li> <li>hud.yaml (HUD layout and style configuration)</li> <li>state.json (with active_env: root)</li> <li>state_cache.json (cached prefixed commands for fast shell startup)</li> <li>spokes/ (empty directory)</li> <li>bash/init.sh (bash/zsh shell integration script)</li> <li>tmux/init.sh (tmux integration script)</li> </ul> <p>Returns:</p> Type Description <code>bool</code> <p>True if initialization was performed (first run)</p> <code>bool</code> <p>False if config already existed</p> <p>Raises:</p> Type Description <code>SystemExit</code> <p>If config directory cannot be created (permission denied)</p> Source code in <code>axium/core/bootstrap.py</code> <pre><code>def ensure_axium_config() -&gt; bool:\n    \"\"\"\n    Ensure Axium config directory and files exist.\n\n    Creates ~/.config/axium/ with default configuration files if missing.\n    Never overwrites existing files.\n\n    Creates:\n        - ~/.config/axium/ (directory)\n        - envs.yaml (with root/builder defaults)\n        - prefixes.yaml (with aws/terraform defaults)\n        - hud.yaml (HUD layout and style configuration)\n        - state.json (with active_env: root)\n        - state_cache.json (cached prefixed commands for fast shell startup)\n        - spokes/ (empty directory)\n        - bash/init.sh (bash/zsh shell integration script)\n        - tmux/init.sh (tmux integration script)\n\n    Returns:\n        True if initialization was performed (first run)\n        False if config already existed\n\n    Raises:\n        SystemExit: If config directory cannot be created (permission denied)\n    \"\"\"\n    # Check if config directory exists and create if needed\n    try:\n        config_existed = CONF_DIR.exists()\n        CONF_DIR.mkdir(parents=True, exist_ok=True)\n    except PermissionError:\n        logger.error(\n            \"axium: cannot create config directory at %s (permission denied)\",\n            CONF_DIR,\n        )\n        sys.exit(1)\n    except Exception as e:\n        logger.error(\"axium: config directory creation failed: %s\", e)\n        sys.exit(1)\n\n    # Track if any initialization was needed\n    initialized = False\n\n    # Create default files if they don't exist\n    try:\n        if not ENVS_PATH.exists():\n            _create_default_envs()\n            initialized = True\n\n        if not PREFIXES_PATH.exists():\n            _create_default_prefixes()\n            initialized = True\n\n        if not STATE_PATH.exists():\n            _create_default_state()\n            initialized = True\n\n        if not HUD_PATH.exists():\n            _create_default_hud()\n            initialized = True\n\n        if not SPOKES_DIR.exists():\n            _ensure_spokes_dir()\n            initialized = True\n\n        if not BASH_INIT_PATH.exists():\n            _create_bash_init()\n            initialized = True\n\n        if not TMUX_INIT_PATH.exists():\n            _create_tmux_init()\n            initialized = True\n\n    except Exception as e:\n        logger.error(\"axium: config initialization failed: %s\", e)\n        sys.exit(1)\n\n    # Log message only if initialization was performed\n    if initialized or not config_existed:\n        logger.info(\"axium: initialized config at %s\", CONF_DIR)\n        return True\n\n    return False\n</code></pre>"},{"location":"reference/api/core/#ipc","title":"ipc","text":"<p>Inter-process communication utilities for daemon/CLI communication.</p>"},{"location":"reference/api/core/#axium.core.ipc","title":"<code>ipc</code>","text":"<p>Axium IPC - Inter-process communication utilities.</p> <p>Provides functions for CLI to communicate with the daemon via UNIX socket. Messages are JSON-encoded and sent over /tmp/axiumd.sock.</p> Protocol <ul> <li>Line-based JSON protocol (newline-delimited)</li> <li>Request format:     <pre><code>{\"cmd\": \"command_name\", \"arg\": \"value\", ...}\n</code></pre></li> <li>Response format:     <pre><code>{\"ok\": true, ...}\n// or\n{\"ok\": false, \"error\": \"...\"}\n</code></pre></li> <li>Connection closed after each request/response</li> </ul> Example <pre><code>&gt;&gt;&gt; send_request_sync({\"cmd\": \"ping\"})\n{'ok': True, 'pong': True}\n\n&gt;&gt;&gt; send_request_sync({\"cmd\": \"get_state\"})\n{'ok': True, 'state': {'active_env': 'prod', ...}}\n\n&gt;&gt;&gt; send_request_sync({\"cmd\": \"set_env\", \"value\": \"prod\"})\n{'ok': True}\n</code></pre>"},{"location":"reference/api/core/#axium.core.ipc.send_request_sync","title":"<code>send_request_sync(payload, timeout=2.0)</code>","text":"<p>Send IPC request to daemon (synchronous wrapper).</p> <p>This is the primary IPC function used by CLI commands. Wraps the async _send() implementation with asyncio.run() for synchronous use.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>dict</code> <p>Dict to send as JSON (e.g., {\"cmd\": \"get_state\"})</p> required <code>timeout</code> <code>float</code> <p>Maximum seconds to wait for response (default: 2.0)</p> <code>2.0</code> <p>Returns:</p> Type Description <code>dict</code> <p>Response dict from daemon</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If daemon socket doesn't exist</p> <code>ConnectionRefusedError</code> <p>If daemon not accepting connections</p> <code>JSONDecodeError</code> <p>If daemon response is malformed</p> <code>TimeoutError</code> <p>If daemon doesn't respond within timeout</p> <code>Exception</code> <p>Any other communication errors</p> Example <pre><code>&gt;&gt;&gt; send_request_sync({\"cmd\": \"ping\"})\n{'ok': True, 'pong': True}\n\n&gt;&gt;&gt; send_request_sync({\"cmd\": \"set_env\", \"value\": \"prod\"})\n{'ok': True}\n\n&gt;&gt;&gt; send_request_sync({\"cmd\": \"get_state\"})\n{'ok': True, 'state': {'active_env': 'prod', 'started': '...'}}\n\n&gt;&gt;&gt; send_request_sync({\"cmd\": \"slow_op\"}, timeout=10.0)\n{'ok': True}\n</code></pre> Common Commands <p>ping: Health check     send_request_sync({\"cmd\": \"ping\"})</p> <p>get_state: Get daemon state     send_request_sync({\"cmd\": \"get_state\"})</p> <p>set_env: Set active environment     send_request_sync({\"cmd\": \"set_env\", \"value\": \"prod\"})</p> <p>reload: Reload state from disk     send_request_sync({\"cmd\": \"reload\"})</p> <p>apply_prefixes: Apply prefix rules     send_request_sync({         \"cmd\": \"apply_prefixes\",         \"command\": \"aws\",         \"args\": [\"s3\", \"ls\"],         \"context\": {\"pane\": \"...\", \"env\": \"prod\"}     })</p> <p>stop: Gracefully stop daemon     send_request_sync({\"cmd\": \"stop\"})</p> Note <p>Default timeout is 2 seconds for quick failure when daemon is down. Each call opens and closes a new connection (no connection pooling).</p> Source code in <code>axium/core/ipc.py</code> <pre><code>def send_request_sync(payload: dict, timeout: float = 2.0) -&gt; dict:\n    \"\"\"\n    Send IPC request to daemon (synchronous wrapper).\n\n    This is the primary IPC function used by CLI commands. Wraps the\n    async _send() implementation with asyncio.run() for synchronous use.\n\n    Args:\n        payload: Dict to send as JSON (e.g., {\"cmd\": \"get_state\"})\n        timeout: Maximum seconds to wait for response (default: 2.0)\n\n    Returns:\n        Response dict from daemon\n\n    Raises:\n        FileNotFoundError: If daemon socket doesn't exist\n        ConnectionRefusedError: If daemon not accepting connections\n        json.JSONDecodeError: If daemon response is malformed\n        asyncio.TimeoutError: If daemon doesn't respond within timeout\n        Exception: Any other communication errors\n\n    Example:\n        ```python\n        &gt;&gt;&gt; send_request_sync({\"cmd\": \"ping\"})\n        {'ok': True, 'pong': True}\n\n        &gt;&gt;&gt; send_request_sync({\"cmd\": \"set_env\", \"value\": \"prod\"})\n        {'ok': True}\n\n        &gt;&gt;&gt; send_request_sync({\"cmd\": \"get_state\"})\n        {'ok': True, 'state': {'active_env': 'prod', 'started': '...'}}\n\n        &gt;&gt;&gt; send_request_sync({\"cmd\": \"slow_op\"}, timeout=10.0)\n        {'ok': True}\n        ```\n\n    Common Commands:\n        ping: Health check\n            send_request_sync({\"cmd\": \"ping\"})\n\n        get_state: Get daemon state\n            send_request_sync({\"cmd\": \"get_state\"})\n\n        set_env: Set active environment\n            send_request_sync({\"cmd\": \"set_env\", \"value\": \"prod\"})\n\n        reload: Reload state from disk\n            send_request_sync({\"cmd\": \"reload\"})\n\n        apply_prefixes: Apply prefix rules\n            send_request_sync({\n                \"cmd\": \"apply_prefixes\",\n                \"command\": \"aws\",\n                \"args\": [\"s3\", \"ls\"],\n                \"context\": {\"pane\": \"...\", \"env\": \"prod\"}\n            })\n\n        stop: Gracefully stop daemon\n            send_request_sync({\"cmd\": \"stop\"})\n\n    Note:\n        Default timeout is 2 seconds for quick failure when daemon is down.\n        Each call opens and closes a new connection (no connection pooling).\n    \"\"\"\n    return asyncio.run(asyncio.wait_for(_send(payload), timeout=timeout))\n</code></pre>"},{"location":"reference/api/daemon/","title":"Daemon API","text":"<p>Background daemon process and state management.</p>"},{"location":"reference/api/daemon/#daemon","title":"daemon","text":"<p>Async daemon implementation with IPC handler.</p>"},{"location":"reference/api/daemon/#axium.core.daemon","title":"<code>daemon</code>","text":"<p>Axium Daemon - Async background service.</p> <p>The daemon is the heart of Axium, running as a background process to: - Maintain session state (active environment, uptime, etc.) - Handle IPC requests from CLI via UNIX socket - Coordinate events across Spokes - Apply prefix rules to commands</p> <p>The daemon uses asyncio for concurrent request handling and communicates via JSON over a UNIX socket at /tmp/axiumd.sock.</p> <p>State is persisted to ~/.config/axium/state.json and includes: - active_env: Current environment name - panes: Per-pane environment mapping</p> <p>Runtime state (not persisted): - started: Daemon start timestamp (ISO 8601) - tmux_pane: TMUX_PANE value when daemon started - hud_cache: Pre-rendered HUD strings for panes</p> IPC Protocol <pre><code>Request:  {\"cmd\": \"command_name\", \"arg1\": \"value\", ...}\nResponse: {\"ok\": true, \"result\": ...} or {\"ok\": false, \"error\": \"...\"}\n</code></pre> Supported Commands <ul> <li>ping: Health check</li> <li>get_state: Get full daemon state</li> <li>set_env: Set active environment</li> <li>reload: Reload state from disk</li> <li>apply_prefixes: Apply prefix rules to a command</li> <li>list_prefixed_commands: List commands with prefix rules</li> <li>stop: Gracefully shut down daemon</li> </ul> Example <pre><code>$ axium daemon start\n$ axium daemon status\n$ axium daemon stop\n</code></pre>"},{"location":"reference/api/daemon/#axium.core.daemon.AxiumDaemon","title":"<code>AxiumDaemon</code>","text":"<p>Main daemon class managing state and IPC.</p> <p>The daemon runs an asyncio event loop with a UNIX socket server accepting JSON IPC requests from the CLI.</p> <p>Attributes:</p> Name Type Description <code>state</code> <p>Runtime state dict with keys: Persistent (saved to state.json):     - active_env: Current environment name (str | None)     - panes: Per-pane environment mapping (dict) Runtime-only:     - started: ISO 8601 timestamp of daemon start (str)     - tmux_pane: TMUX_PANE when daemon started (str | None)     - hud_cache: Pre-rendered HUD strings (dict)</p> <code>_start_time</code> <p>Unix timestamp of daemon start (float, for uptime)</p> <code>server</code> <p>asyncio.Server instance for UNIX socket</p> <code>_stop</code> <p>asyncio.Event for graceful shutdown</p> Example <pre><code>daemon = AxiumDaemon()\nawait daemon.run()\n</code></pre> Source code in <code>axium/core/daemon.py</code> <pre><code>class AxiumDaemon:\n    \"\"\"\n    Main daemon class managing state and IPC.\n\n    The daemon runs an asyncio event loop with a UNIX socket server\n    accepting JSON IPC requests from the CLI.\n\n    Attributes:\n        state: Runtime state dict with keys:\n            Persistent (saved to state.json):\n                - active_env: Current environment name (str | None)\n                - panes: Per-pane environment mapping (dict)\n            Runtime-only:\n                - started: ISO 8601 timestamp of daemon start (str)\n                - tmux_pane: TMUX_PANE when daemon started (str | None)\n                - hud_cache: Pre-rendered HUD strings (dict)\n        _start_time: Unix timestamp of daemon start (float, for uptime)\n        server: asyncio.Server instance for UNIX socket\n        _stop: asyncio.Event for graceful shutdown\n\n    Example:\n        ```python\n        daemon = AxiumDaemon()\n        await daemon.run()\n        ```\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize daemon with default state.\n\n        Loads persistent state from state.json if it exists, otherwise\n        initializes with defaults. Creates empty event registry.\n        \"\"\"\n        # Runtime-only state (not persisted)\n        self.state = {\n            \"active_env\": None,\n            \"panes\": {},  # Per-pane environment mapping: {\"%1\": \"root\", \"%2\": \"builder\"}\n            \"hud_cache\": {},  # Pre-rendered HUD strings: {\"%1\": \"[axium] pane:%1 ...\"}\n            \"tmux_pane\": os.getenv(\"TMUX_PANE\"),\n            \"started\": datetime.now(timezone.utc).isoformat().replace(\"+00:00\", \"Z\"),\n        }\n        self._start_time = time.time()  # Unix timestamp for fast uptime calculations\n        self.permissions = (\n            {}\n        )  # Effective permissions per spoke: {spoke_name: SpokePermissions}\n        self.notification_queue = (\n            []\n        )  # Queued notifications: [{\"title\": ..., \"body\": ..., \"spoke\": ...}]\n        self.hud_config = {}  # HUD layout configuration from hud.yaml\n        self.server = None\n        self._stop = asyncio.Event()\n\n        # Initialize EventBus for spoke coordination\n        from axium.core.spokes import get_event_bus\n\n        self.bus = get_event_bus()\n\n        # Set up completion cache event listeners\n        self.bus.on(\"spoke_loaded\", self._on_spoke_loaded)\n        self.bus.on(\"spoke_reloaded\", self._on_spoke_reloaded)\n        self.bus.on(\"spoke_unloaded\", self._on_spoke_unloaded)\n        self.bus.on(\"gear_loaded\", self._on_gear_loaded)\n        self.bus.on(\"gear_unloaded\", self._on_gear_unloaded)\n        self.bus.on(\"daemon_reload\", self._on_daemon_reload)\n\n        self._load_state()\n        self._load_hud_config()  # Load HUD layout from hud.yaml\n        self._write_state_cache()\n        self._refresh_all_hud_caches()  # Pre-render HUD for all panes\n\n        # Load gears for daemon IPC operations\n        # Note: Gears are also loaded in CLI for command registration\n        # This loads them in daemon context for IPC permission enforcement\n        self._load_gears_for_daemon()\n\n        # Generate initial completion cache\n        self._regenerate_completions(\"daemon_init\")\n\n    def _load_state(self) -&gt; None:\n        \"\"\"\n        Load persistent state from state.json.\n\n        Reads active_env and panes mapping from disk if state.json exists.\n        Other state (started, tmux_pane) is runtime-only and not loaded.\n\n        Side Effects:\n            Updates self.state[\"active_env\"] and self.state[\"panes\"] if file exists and is valid.\n\n        Note:\n            Logs warning if state.json is malformed but continues with defaults.\n        \"\"\"\n        if STATE_PATH.exists():\n            try:\n                data = json.loads(STATE_PATH.read_text())\n                self.state[\"active_env\"] = data.get(\"active_env\")\n                self.state[\"panes\"] = data.get(\"panes\", {})\n                logger.info(\"Loaded state from %s\", STATE_PATH)\n            except Exception as e:\n                logger.warning(\"Failed to load state: %s\", e)\n\n    def _load_hud_config(self) -&gt; None:\n        \"\"\"\n        Load HUD layout configuration from hud.yaml.\n\n        Reads HUD layout and style configuration from ~/.config/axium/hud.yaml.\n        Falls back to hardcoded defaults if file doesn't exist or is invalid.\n\n        Side Effects:\n            Updates self.hud_config with layout and style settings\n\n        Note:\n            - layout: List of segment names to display (e.g., [\"env\", \"uptime\"])\n            - style: Dict with color and padding settings\n            - Logs warning if hud.yaml is malformed but continues with defaults\n        \"\"\"\n        import yaml\n\n        hud_path = CONF_DIR / \"hud.yaml\"\n\n        # Default configuration\n        default_config = {\n            \"layout\": [\"env\", \"uptime\"],\n            \"style\": {\"color\": \"#00B7C7\", \"padding\": 1},\n        }\n\n        if not hud_path.exists():\n            self.hud_config = default_config\n            logger.debug(\"Using default HUD config (hud.yaml not found)\")\n            return\n\n        try:\n            data = yaml.safe_load(hud_path.read_text())\n            self.hud_config = data if data else default_config\n            logger.info(\"Loaded HUD config from %s\", hud_path)\n        except Exception as e:\n            logger.warning(\"Failed to load hud.yaml: %s (using defaults)\", e)\n            self.hud_config = default_config\n\n    def _load_gears_for_daemon(self) -&gt; None:\n        \"\"\"\n        Load gears for daemon IPC operations.\n\n        Loads gears to populate self.permissions dict for IPC permission enforcement.\n        Gears are also loaded in CLI context for command registration.\n\n        This is called during daemon initialization.\n        \"\"\"\n        from . import gears\n\n        discovered = gears.discover_gears()\n        if not discovered:\n            logger.debug(\"No gears found\")\n            return\n\n        # Gears need app and events, but in daemon context we don't have the CLI app\n        # We only need to load permissions for IPC operations\n        # Commands are registered when gears load in CLI context\n        for gear_name in discovered:\n            try:\n                # Load just the permissions without calling register()\n                gear_path = gears.GEARS_DIR / gear_name\n                gear_yaml = gear_path / \"gear.yaml\"\n\n                if not gear_yaml.exists():\n                    logger.warning(\"Gear %s missing gear.yaml\", gear_name)\n                    continue\n\n                # Load and store permissions\n                effective_perms = gears.get_effective_gear_permissions(\n                    gear_name, gear_yaml\n                )\n                self.permissions[gear_name] = effective_perms\n\n                logger.info(\n                    \"Loaded gear permissions: %s (exec=%s ipc=%d)\",\n                    gear_name,\n                    effective_perms.exec,\n                    len(effective_perms.ipc),\n                )\n\n            except Exception as e:\n                logger.error(\"Failed to load gear %s permissions: %s\", gear_name, e)\n\n    def _save_state(self) -&gt; None:\n        \"\"\"\n        Persist state to state.json.\n\n        Saves only persistent fields (active_env, panes) to disk.\n        Runtime fields (started, tmux_pane) are not saved.\n\n        Side Effects:\n            Writes to ~/.config/axium/state.json\n\n        Note:\n            Creates parent directory if it doesn't exist.\n            Logs error but doesn't raise if save fails.\n        \"\"\"\n        try:\n            CONF_DIR.mkdir(parents=True, exist_ok=True)\n            data = {\n                \"active_env\": self.state[\"active_env\"],\n                \"panes\": self.state.get(\"panes\", {}),\n            }\n            STATE_PATH.write_text(json.dumps(data, indent=2))\n            logger.debug(\"Saved state to %s\", STATE_PATH)\n        except Exception as e:\n            logger.error(\"Failed to save state: %s\", e)\n\n    def _write_state_cache(self) -&gt; None:\n        \"\"\"\n        Write shell-optimized state cache to state_cache.json.\n\n        Creates a JSON file with prefixed commands list for fast shell startup.\n        This file is read by bash/init.sh to generate wrapper functions without\n        requiring Python or daemon IPC during shell initialization.\n\n        Cache Format:\n            ```json\n            {\n                \"prefixed_commands\": [\"aws\", \"terraform\", \"ansible\"]\n            }\n            ```\n\n        Side Effects:\n            Writes to ~/.config/axium/state_cache.json\n\n        Note:\n            This should be called whenever prefix rules change:\n            - On daemon startup (__init__)\n            - When prefix.yaml is modified (reload command)\n            - When Spokes are loaded/unloaded\n\n            Errors are logged but not raised to avoid breaking daemon startup.\n        \"\"\"\n        try:\n            CONF_DIR.mkdir(parents=True, exist_ok=True)\n            commands = prefix.get_prefixed_commands()\n            cache_data = {\"prefixed_commands\": commands}\n            STATE_CACHE_PATH.write_text(json.dumps(cache_data, indent=2))\n            logger.debug(\n                \"Wrote state cache to %s with %d commands\",\n                STATE_CACHE_PATH,\n                len(commands),\n            )\n        except Exception as e:\n            logger.error(\"Failed to write state cache: %s\", e)\n\n    def _render_hud_for_pane(self, pane_id: str) -&gt; str:\n        \"\"\"\n        Pre-render HUD string for a specific pane.\n\n        Runs in daemon process, generating the complete HUD string without\n        requiring CLI-side computation. This enables instant HUD responses.\n\n        Uses the new HudRegistry system for modular segment rendering.\n\n        Args:\n            pane_id: tmux pane ID (e.g., \"%1\")\n\n        Returns:\n            Rendered HUD string like \"[axium] pane:%1  env:root  uptime:2h15m\"\n\n        Note:\n            This method is called by the daemon to pre-compute HUD strings.\n            Uses HudRegistry for consistent rendering with hud.main().\n        \"\"\"\n        try:\n            # Import hud module to ensure segments are registered\n            from axium.core.hud import get_registry\n\n            # Get pane environment\n            env = self.state[\"panes\"].get(pane_id) or \"-\"\n\n            # Get wrapper and theme config from hud.yaml\n            wrapper = self.hud_config.get(\"style\", {}).get(\"wrapper\", {})\n            theme = self.hud_config.get(\"style\", {}).get(\"theme\", {})\n\n            # Build context for segment rendering (same as hud.main())\n            context = {\n                \"state\": self.state,\n                \"pane_id\": pane_id,\n                \"env\": env,\n                \"started\": self.state.get(\"started\"),\n                \"wrapper\": wrapper,\n                \"theme\": theme,\n            }\n\n            # Render all segments via registry\n            # Don't call hud.main() as it does IPC calls which causes async issues\n            registry = get_registry()\n            segments = registry.render_all(context)\n\n            return \"[axium] \" + \"  \".join(segments)\n        except Exception as e:\n            import traceback\n\n            logger.error(\n                \"Error rendering HUD for pane %s: %s\\n%s\",\n                pane_id,\n                e,\n                traceback.format_exc(),\n            )\n            return \"[axium] inactive\"\n\n    def _update_hud_cache(self, pane_id: str) -&gt; None:\n        \"\"\"\n        Update cached HUD string for a specific pane.\n\n        Re-renders the HUD and stores it in the cache for instant retrieval.\n\n        Args:\n            pane_id: tmux pane ID (e.g., \"%1\")\n\n        Side Effects:\n            Updates self.state[\"hud_cache\"][pane_id]\n\n        Note:\n            Called automatically when pane environment changes or on reload.\n            Errors are logged but don't raise to avoid disrupting daemon.\n        \"\"\"\n        try:\n            self.state[\"hud_cache\"][pane_id] = self._render_hud_for_pane(pane_id)\n            logger.debug(\"Updated HUD cache for pane %s\", pane_id)\n        except Exception as e:\n            logger.error(\"Failed to render HUD for pane %s: %s\", pane_id, e)\n            # Don't add to cache if render fails - let caller handle fallback\n\n    def _refresh_all_hud_caches(self) -&gt; None:\n        \"\"\"\n        Refresh HUD cache for all known panes.\n\n        Iterates through all panes in state and re-renders their HUD strings.\n        Called on daemon startup and after reload operations.\n\n        Side Effects:\n            Updates self.state[\"hud_cache\"] for all panes\n\n        Note:\n            Safe to call even if panes dict is empty (no-op).\n        \"\"\"\n        for pane_id in self.state[\"panes\"].keys():\n            self._update_hud_cache(pane_id)\n        logger.debug(\"Refreshed HUD cache for %d panes\", len(self.state[\"panes\"]))\n\n    def _regenerate_completions(self, event_name: str) -&gt; None:\n        \"\"\"\n        Regenerate completion cache after command structure changes.\n\n        Called by event handlers when spokes/gears are loaded, reloaded,\n        or unloaded, or when daemon config is reloaded.\n\n        Args:\n            event_name: Name of the event that triggered regeneration\n\n        Side Effects:\n            Writes to ~/.config/axium/completions.json\n\n        Note:\n            Errors are logged but not raised to avoid disrupting\n            the main event flow.\n        \"\"\"\n        try:\n            from axium.core.completions import generate_completion_cache\n\n            success = generate_completion_cache()\n            if success:\n                logger.debug(\"Regenerated completions after %s\", event_name)\n            else:\n                logger.warning(\"Failed to regenerate completions after %s\", event_name)\n        except Exception as e:\n            logger.error(\"Error regenerating completions after %s: %s\", event_name, e)\n\n    def _on_spoke_loaded(self, spoke_name: str) -&gt; None:\n        \"\"\"Event handler: spoke_loaded.\"\"\"\n        self._regenerate_completions(f\"spoke_loaded:{spoke_name}\")\n        # Refresh HUD caches since spoke may have registered new segments\n        self._refresh_all_hud_caches()\n\n    def _on_spoke_reloaded(self, spoke_name: str) -&gt; None:\n        \"\"\"Event handler: spoke_reloaded.\"\"\"\n        self._regenerate_completions(f\"spoke_reloaded:{spoke_name}\")\n        # Refresh HUD caches since spoke may have updated segments\n        self._refresh_all_hud_caches()\n\n    def _on_spoke_unloaded(self, spoke_name: str) -&gt; None:\n        \"\"\"Event handler: spoke_unloaded.\"\"\"\n        self._regenerate_completions(f\"spoke_unloaded:{spoke_name}\")\n        # Refresh HUD caches since spoke segments are removed\n        self._refresh_all_hud_caches()\n\n    def _on_gear_loaded(self, gear_name: str) -&gt; None:\n        \"\"\"Event handler: gear_loaded.\"\"\"\n        self._regenerate_completions(f\"gear_loaded:{gear_name}\")\n        # Refresh HUD caches since gear may have registered new segments\n        self._refresh_all_hud_caches()\n\n    def _on_gear_unloaded(self, gear_name: str) -&gt; None:\n        \"\"\"Event handler: gear_unloaded.\"\"\"\n        self._regenerate_completions(f\"gear_unloaded:{gear_name}\")\n        # Refresh HUD caches since gear segments are removed\n        self._refresh_all_hud_caches()\n\n    def _on_daemon_reload(self) -&gt; None:\n        \"\"\"Event handler: daemon_reload.\"\"\"\n        self._regenerate_completions(\"daemon_reload\")\n\n    def _handle_set_pane_env(self, msg: dict) -&gt; dict:\n        \"\"\"\n        Handle set_pane_env IPC command.\n\n        Sets environment for specific tmux pane and emits env_change event.\n\n        Args:\n            msg: IPC message with 'pane' and 'value' fields\n\n        Returns:\n            Response dict with 'ok' status\n        \"\"\"\n        pane_id = msg.get(\"pane\")\n        new_env = msg.get(\"env\")\n\n        if not pane_id:\n            return {\"ok\": False, \"error\": \"pane ID required\"}\n\n        # Validate environment name before setting\n        from . import env as env_module\n\n        is_valid, error = env_module.validate_env_name(new_env)\n        if not is_valid:\n            return {\"ok\": False, \"error\": error}\n\n        old_env = self.state[\"panes\"].get(pane_id)\n        self.state[\"panes\"][pane_id] = new_env\n        self._save_state()\n\n        # Invalidate all config caches (env-aware configs need refresh)\n        from . import config\n\n        config.invalidate_cache()\n        logger.debug(\"Invalidated all config caches due to pane env change\")\n\n        # Update HUD cache for this pane\n        self._update_hud_cache(pane_id)\n\n        logger.info(\"Pane %s environment set to: %s\", pane_id, new_env)\n\n        # Emit env_change event with pane context\n        from . import spokes\n\n        spokes.get_event_bus().emit(\"env_change\", new_env, old_env, pane=pane_id)\n\n        return {\"ok\": True}\n\n    def _handle_get_pane_env(self, msg: dict) -&gt; dict:\n        \"\"\"\n        Handle get_pane_env IPC command.\n\n        Gets environment for specific tmux pane.\n\n        Args:\n            msg: IPC message with 'pane' field\n\n        Returns:\n            Response dict with 'ok' status and 'env' value\n        \"\"\"\n        pane_id = msg.get(\"pane\")\n\n        if not pane_id:\n            return {\"ok\": False, \"error\": \"pane ID required\"}\n\n        env_name = self.state[\"panes\"].get(pane_id)\n        return {\"ok\": True, \"env\": env_name}\n\n    def _handle_clear_pane_env(self, msg: dict) -&gt; dict:\n        \"\"\"\n        Handle clear_pane_env IPC command.\n\n        Clears environment mapping for specific pane and emits env_change event.\n\n        Args:\n            msg: IPC message with 'pane' field\n\n        Returns:\n            Response dict with 'ok' status\n        \"\"\"\n        pane_id = msg.get(\"pane\")\n\n        if not pane_id:\n            return {\"ok\": False, \"error\": \"pane ID required\"}\n\n        old_env = self.state[\"panes\"].get(pane_id)\n\n        if pane_id in self.state[\"panes\"]:\n            del self.state[\"panes\"][pane_id]\n            self._save_state()\n            logger.info(\"Cleared pane %s environment\", pane_id)\n\n            # Emit post-action event\n            self.bus.emit(\"env_change\", new_env=None, old_env=old_env, pane=pane_id)\n\n        return {\"ok\": True}\n\n    def _handle_notify(self, msg: dict) -&gt; dict:\n        \"\"\"\n        Handle notify IPC command.\n\n        Checks notify permission for spoke, then queues notification.\n\n        Args:\n            msg: IPC message with 'spoke', 'title', 'body', 'level' fields\n\n        Returns:\n            Response dict with 'ok' status\n        \"\"\"\n        from . import permissions\n\n        spoke_name = msg.get(\"spoke\")\n        title = msg.get(\"title\", \"\")\n        body = msg.get(\"body\", \"\")\n        level = msg.get(\"level\", \"info\")\n\n        if not spoke_name:\n            return {\"ok\": False, \"error\": \"spoke name required\"}\n\n        # Check permission\n        spoke_perms = self.permissions.get(spoke_name)\n        if not spoke_perms:\n            permissions.log_security(spoke_name, \"notify\", False, title, False)\n            return {\"ok\": False, \"error\": \"spoke not loaded\"}\n\n        allowed = permissions.check_permission(\n            spoke_name, \"notify\", spoke_perms, detail=title\n        )\n\n        if not allowed:\n            return {\"ok\": False, \"error\": \"permission denied: notify\"}\n\n        # Queue notification\n        notification = {\n            \"spoke\": spoke_name,\n            \"title\": title,\n            \"body\": body,\n            \"level\": level,\n            \"timestamp\": datetime.now(timezone.utc).isoformat().replace(\"+00:00\", \"Z\"),\n        }\n        self.notification_queue.append(notification)\n\n        logger.info(\n            \"Notification queued: spoke=%s title='%s'\",\n            spoke_name,\n            title[:50],\n        )\n\n        return {\"ok\": True}\n\n    def _handle_daemon_exec(self, msg: dict) -&gt; dict:\n        \"\"\"\n        Handle daemon_exec IPC command.\n\n        Checks exec permission for spoke, then runs command in background subprocess.\n\n        Args:\n            msg: IPC message with 'spoke', 'command', 'mode' fields\n\n        Returns:\n            Response dict with 'ok' status and 'pid' (if successful)\n        \"\"\"\n        import subprocess\n\n        from . import permissions\n\n        spoke_name = msg.get(\"spoke\")\n        cmd = msg.get(\"command\", \"\")\n        mode = msg.get(\"mode\", \"background\")\n\n        if not spoke_name:\n            return {\"ok\": False, \"error\": \"spoke name required\"}\n\n        if not cmd:\n            return {\"ok\": False, \"error\": \"command required\"}\n\n        # Phase 1: only background mode supported\n        if mode != \"background\":\n            return {\n                \"ok\": False,\n                \"error\": f\"unsupported mode: {mode} (only 'background' supported)\",\n            }\n\n        # Check permission\n        spoke_perms = self.permissions.get(spoke_name)\n        if not spoke_perms:\n            permissions.log_security(spoke_name, \"daemon_exec\", False, cmd, False)\n            return {\"ok\": False, \"error\": \"spoke not loaded\"}\n\n        allowed = permissions.check_permission(\n            spoke_name, \"exec\", spoke_perms, detail=cmd\n        )\n\n        if not allowed:\n            return {\"ok\": False, \"error\": \"permission denied: exec\"}\n\n        # Run command in background (no TTY, non-interactive)\n        try:\n            proc = subprocess.Popen(\n                cmd,\n                shell=True,\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE,\n                stdin=subprocess.DEVNULL,\n                start_new_session=True,  # Detach from daemon\n            )\n\n            logger.info(\n                \"Background command started: spoke=%s pid=%d cmd='%s'\",\n                spoke_name,\n                proc.pid,\n                cmd[:100],\n            )\n\n            return {\"ok\": True, \"pid\": proc.pid}\n\n        except Exception as e:\n            logger.error(\n                \"Failed to execute command: spoke=%s cmd='%s' error=%s\",\n                spoke_name,\n                cmd[:100],\n                e,\n            )\n            return {\"ok\": False, \"error\": str(e)}\n\n    def _handle_notify_drain(self, msg: dict) -&gt; dict:\n        \"\"\"\n        Handle notify_drain IPC command.\n\n        Returns and clears the notification queue.\n\n        Args:\n            msg: IPC message (no parameters needed)\n\n        Returns:\n            Response dict with 'ok' status and 'notifications' list\n        \"\"\"\n        notifications = self.notification_queue.copy()\n        self.notification_queue.clear()\n\n        logger.debug(\"Drained %d notifications\", len(notifications))\n\n        return {\"ok\": True, \"notifications\": notifications}\n\n    def _handle_get_permissions(self, msg: dict) -&gt; dict:\n        \"\"\"\n        Handle get_permissions IPC command.\n\n        Returns effective permissions for a spoke.\n\n        Args:\n            msg: IPC message with 'spoke' field\n\n        Returns:\n            Response dict with 'ok' status and 'permissions' dict\n        \"\"\"\n        spoke_name = msg.get(\"spoke\")\n\n        if not spoke_name:\n            return {\"ok\": False, \"error\": \"spoke name required\"}\n\n        spoke_perms = self.permissions.get(spoke_name)\n\n        if not spoke_perms:\n            return {\"ok\": False, \"error\": \"spoke not loaded\"}\n\n        # Convert to dict with source info\n        perms_dict = spoke_perms.to_dict()\n        sources = {field: spoke_perms.get_source(field) for field in perms_dict.keys()}\n\n        return {\n            \"ok\": True,\n            \"permissions\": perms_dict,\n            \"sources\": sources,\n        }\n\n    def _handle_load_spoke_permissions(self, msg: dict) -&gt; dict:\n        \"\"\"\n        Handle load_spoke_permissions IPC command.\n\n        Loads permissions for a spoke from its spoke.yaml and merges with user overrides.\n\n        Args:\n            msg: IPC message with 'spoke', 'spoke_yaml_path' fields\n\n        Returns:\n            Response dict with 'ok' status\n        \"\"\"\n        from pathlib import Path\n\n        from . import permissions\n\n        spoke_name = msg.get(\"spoke\")\n        spoke_yaml_path_str = msg.get(\"spoke_yaml_path\")\n\n        if not spoke_name:\n            return {\"ok\": False, \"error\": \"spoke name required\"}\n\n        if not spoke_yaml_path_str:\n            return {\"ok\": False, \"error\": \"spoke_yaml_path required\"}\n\n        try:\n            spoke_yaml_path = Path(spoke_yaml_path_str)\n            effective_perms = permissions.get_effective_permissions(\n                spoke_name, spoke_yaml_path\n            )\n            self.permissions[spoke_name] = effective_perms\n\n            logger.info(\n                \"Loaded permissions: spoke=%s exec=%s notify=%s fs_read=%d\",\n                spoke_name,\n                effective_perms.exec,\n                effective_perms.notify,\n                len(effective_perms.fs_read),\n            )\n\n            return {\"ok\": True}\n\n        except Exception as e:\n            logger.error(\"Failed to load permissions for spoke %s: %s\", spoke_name, e)\n            return {\"ok\": False, \"error\": str(e)}\n\n    def _handle_get_config(self, msg: dict) -&gt; dict:\n        \"\"\"\n        Handle get_config IPC command.\n\n        Loads config for a spoke and optionally returns a specific value by key path.\n        Uses the centralized config system with caching.\n\n        Args:\n            msg: IPC message with:\n                - 'spoke': Spoke name (required)\n                - 'key': Optional dot-notation key path (e.g., \"check.path\")\n                - 'default_filename': Optional config filename (defaults to &lt;spoke&gt;.yaml)\n\n        Returns:\n            Response dict with:\n                - 'ok': True if successful\n                - 'config': Full config dict OR specific value if key provided\n                - 'source': 'cache' or 'loaded'\n                - 'error': Error message if failed\n\n        Example:\n            &gt;&gt;&gt; # Full config\n            &gt;&gt;&gt; _handle_get_config({\"cmd\": \"get_config\", \"spoke\": \"creds\"})\n            {\"ok\": True, \"config\": {...}, \"source\": \"cache\"}\n\n            &gt;&gt;&gt; # Specific key\n            &gt;&gt;&gt; _handle_get_config({\"cmd\": \"get_config\", \"spoke\": \"creds\", \"key\": \"check.path\"})\n            {\"ok\": True, \"config\": \"~/.aws/credentials\", \"source\": \"cache\"}\n        \"\"\"\n        from . import config\n\n        spoke_name = msg.get(\"spoke\")\n        key_path = msg.get(\"key\")\n        default_filename = msg.get(\"default_filename\", f\"{spoke_name}.yaml\")\n\n        if not spoke_name:\n            return {\"ok\": False, \"error\": \"spoke name required\"}\n\n        try:\n            # Check if config is cached\n            cache_keys = [k for k in config._config_cache.keys() if k[0] == spoke_name]\n            was_cached = len(cache_keys) &gt; 0\n\n            # Load config (will use cache if available)\n            spoke_config = config.load_spoke_config(\n                spoke_name, default_filename, env_aware=True\n            )\n\n            logger.debug(\n                \"Config request: spoke=%s key=%s cached=%s\",\n                spoke_name,\n                key_path or \"(full)\",\n                was_cached,\n            )\n\n            # If key path provided, extract specific value\n            if key_path:\n                value = config.get_config_value_by_path(\n                    spoke_config, key_path, default=None\n                )\n\n                if value is None:\n                    logger.debug(\n                        \"Config key not found: spoke=%s key=%s\", spoke_name, key_path\n                    )\n                    return {\n                        \"ok\": False,\n                        \"error\": f\"key '{key_path}' not found in config\",\n                    }\n\n                return {\n                    \"ok\": True,\n                    \"config\": value,\n                    \"source\": \"cache\" if was_cached else \"loaded\",\n                }\n\n            # Return full config\n            return {\n                \"ok\": True,\n                \"config\": spoke_config,\n                \"source\": \"cache\" if was_cached else \"loaded\",\n            }\n\n        except FileNotFoundError as e:\n            logger.debug(\"Config file not found: spoke=%s error=%s\", spoke_name, e)\n            return {\"ok\": False, \"error\": f\"config file not found: {e}\"}\n\n        except Exception as e:\n            logger.error(\"Failed to load config for spoke %s: %s\", spoke_name, e)\n            return {\"ok\": False, \"error\": f\"config error: {str(e)}\"}\n\n    def _handle_tmux_split_run(self, msg: dict) -&gt; dict:\n        \"\"\"\n        Handle tmux_split_run IPC command.\n\n        Creates a tmux split pane and runs a command inside it.\n        Requires 'tmux_split_run' in spoke/gear's IPC permissions.\n\n        Args:\n            msg: IPC message with 'spoke', 'command', 'height' fields\n\n        Returns:\n            Response dict with 'ok' status and 'pane_id' if successful\n        \"\"\"\n        import subprocess\n\n        from . import permissions\n\n        spoke_name = msg.get(\"spoke\")\n        command = msg.get(\"command\", \"\")\n        height = msg.get(\"height\", 20)\n\n        if not spoke_name or not command:\n            return {\"ok\": False, \"error\": \"spoke and command required\"}\n\n        if not (1 &lt;= height &lt;= 99):\n            return {\"ok\": False, \"error\": \"height must be 1-99\"}\n\n        # Permission check\n        spoke_perms = self.permissions.get(spoke_name)\n        if not spoke_perms:\n            permissions.log_security(\n                spoke_name, \"ipc:tmux_split_run\", False, command, False\n            )\n            return {\"ok\": False, \"error\": \"spoke not loaded\"}\n\n        if not permissions.check_ipc_permission(\n            spoke_name, \"tmux_split_run\", spoke_perms, command\n        ):\n            return {\"ok\": False, \"error\": \"permission denied: tmux_split_run\"}\n\n        # Execute tmux split\n        try:\n            result = subprocess.run(\n                [\n                    \"tmux\",\n                    \"split-window\",\n                    \"-v\",\n                    \"-l\",\n                    f\"{height}%\",\n                    \"-P\",\n                    \"-F\",\n                    \"#{pane_id}\",\n                    command,\n                ],\n                capture_output=True,\n                text=True,\n                timeout=5,\n                check=True,\n            )\n            pane_id = result.stdout.strip()\n            logger.info(\n                \"Tmux split created: spoke=%s pane=%s cmd='%s'\",\n                spoke_name,\n                pane_id,\n                command[:100],\n            )\n            return {\"ok\": True, \"pane_id\": pane_id}\n\n        except subprocess.TimeoutExpired:\n            logger.error(\"Tmux split timeout: spoke=%s\", spoke_name)\n            return {\"ok\": False, \"error\": \"tmux command timeout\"}\n        except subprocess.CalledProcessError as e:\n            logger.error(\n                \"Tmux split failed: spoke=%s stderr='%s'\", spoke_name, e.stderr\n            )\n            return {\"ok\": False, \"error\": f\"tmux error: {e.stderr}\"}\n        except Exception as e:\n            logger.error(\"Tmux split exception: spoke=%s error=%s\", spoke_name, e)\n            return {\"ok\": False, \"error\": str(e)}\n\n    def _handle_tmux_send_keys(self, msg: dict) -&gt; dict:\n        \"\"\"Handle tmux_send_keys IPC command.\"\"\"\n        import subprocess\n\n        from . import permissions\n\n        spoke_name = msg.get(\"spoke\")\n        pane_id = msg.get(\"pane_id\", \"\")\n        keys = msg.get(\"keys\", \"\")\n\n        if not all([spoke_name, pane_id, keys]):\n            return {\"ok\": False, \"error\": \"spoke, pane_id, and keys required\"}\n\n        # Permission check\n        spoke_perms = self.permissions.get(spoke_name)\n        if not spoke_perms:\n            return {\"ok\": False, \"error\": \"spoke not loaded\"}\n\n        if not permissions.check_ipc_permission(\n            spoke_name, \"tmux_send_keys\", spoke_perms\n        ):\n            return {\"ok\": False, \"error\": \"permission denied: tmux_send_keys\"}\n\n        try:\n            subprocess.run(\n                [\"tmux\", \"send-keys\", \"-t\", pane_id, keys],\n                check=True,\n                timeout=2,\n            )\n            logger.debug(\"Sent keys to pane: spoke=%s pane=%s\", spoke_name, pane_id)\n            return {\"ok\": True}\n        except Exception as e:\n            logger.error(\"tmux_send_keys failed: %s\", e)\n            return {\"ok\": False, \"error\": str(e)}\n\n    def _handle_tmux_capture_pane(self, msg: dict) -&gt; dict:\n        \"\"\"Handle tmux_capture_pane IPC command.\"\"\"\n        import subprocess\n\n        from . import permissions\n\n        spoke_name = msg.get(\"spoke\")\n        pane_id = msg.get(\"pane_id\", \"\")\n\n        if not spoke_name or not pane_id:\n            return {\"ok\": False, \"error\": \"spoke and pane_id required\"}\n\n        # Permission check\n        spoke_perms = self.permissions.get(spoke_name)\n        if not spoke_perms:\n            return {\"ok\": False, \"error\": \"spoke not loaded\"}\n\n        if not permissions.check_ipc_permission(\n            spoke_name, \"tmux_capture_pane\", spoke_perms\n        ):\n            return {\"ok\": False, \"error\": \"permission denied: tmux_capture_pane\"}\n\n        try:\n            result = subprocess.run(\n                [\"tmux\", \"capture-pane\", \"-t\", pane_id, \"-p\"],\n                capture_output=True,\n                text=True,\n                check=True,\n                timeout=2,\n            )\n            logger.debug(\n                \"Captured pane: spoke=%s pane=%s size=%d\",\n                spoke_name,\n                pane_id,\n                len(result.stdout),\n            )\n            return {\"ok\": True, \"content\": result.stdout}\n        except Exception as e:\n            logger.error(\"tmux_capture_pane failed: %s\", e)\n            return {\"ok\": False, \"error\": str(e)}\n\n    def _handle_read_file(self, msg: dict) -&gt; dict:\n        \"\"\"\n        Handle read_file IPC command.\n\n        Reads file with permission checking against fs_read patterns.\n        \"\"\"\n        from pathlib import Path\n\n        from . import permissions\n\n        spoke_name = msg.get(\"spoke\")\n        path_str = msg.get(\"path\", \"\")\n\n        if not spoke_name or not path_str:\n            return {\"ok\": False, \"error\": \"spoke and path required\"}\n\n        # Permission check\n        spoke_perms = self.permissions.get(spoke_name)\n        if not spoke_perms:\n            return {\"ok\": False, \"error\": \"spoke not loaded\"}\n\n        if not permissions.check_permission(\n            spoke_name, f\"fs_read:{path_str}\", spoke_perms\n        ):\n            return {\"ok\": False, \"error\": \"permission denied: fs_read\"}\n\n        # Read file\n        try:\n            path = Path(path_str).expanduser().resolve()\n            if not path.exists():\n                return {\"ok\": False, \"error\": \"file not found\"}\n\n            # Size check (max 10MB)\n            if path.stat().st_size &gt; 10 * 1024 * 1024:\n                return {\"ok\": False, \"error\": \"file too large (max 10MB)\"}\n\n            content = path.read_text()\n            logger.debug(\n                \"File read: spoke=%s path=%s size=%d\", spoke_name, path, len(content)\n            )\n            return {\"ok\": True, \"content\": content}\n\n        except Exception as e:\n            logger.error(\n                \"File read failed: spoke=%s path=%s error=%s\", spoke_name, path_str, e\n            )\n            return {\"ok\": False, \"error\": str(e)}\n\n    def _handle_write_file(self, msg: dict) -&gt; dict:\n        \"\"\"\n        Handle write_file IPC command.\n\n        Writes file with permission checking against fs_write patterns.\n        \"\"\"\n        from pathlib import Path\n\n        from . import permissions\n\n        spoke_name = msg.get(\"spoke\")\n        path_str = msg.get(\"path\", \"\")\n        content = msg.get(\"content\", \"\")\n\n        if not spoke_name or not path_str:\n            return {\"ok\": False, \"error\": \"spoke and path required\"}\n\n        # Permission check\n        spoke_perms = self.permissions.get(spoke_name)\n        if not spoke_perms:\n            return {\"ok\": False, \"error\": \"spoke not loaded\"}\n\n        if not permissions.check_permission(\n            spoke_name, f\"fs_write:{path_str}\", spoke_perms\n        ):\n            return {\"ok\": False, \"error\": \"permission denied: fs_write\"}\n\n        # Write file\n        try:\n            path = Path(path_str).expanduser().resolve()\n            path.parent.mkdir(parents=True, exist_ok=True)\n            path.write_text(content)\n            logger.info(\n                \"File written: spoke=%s path=%s size=%d\", spoke_name, path, len(content)\n            )\n            return {\"ok\": True}\n\n        except Exception as e:\n            logger.error(\n                \"File write failed: spoke=%s path=%s error=%s\", spoke_name, path_str, e\n            )\n            return {\"ok\": False, \"error\": str(e)}\n\n    def _handle_write_log(self, msg: dict) -&gt; dict:\n        \"\"\"Handle write_log IPC command.\"\"\"\n        from datetime import datetime, timezone\n        from pathlib import Path\n\n        spoke_name = msg.get(\"spoke\")\n        message = msg.get(\"message\", \"\")\n        level = msg.get(\"level\", \"info\").upper()\n\n        if not spoke_name or not message:\n            return {\"ok\": False, \"error\": \"spoke and message required\"}\n\n        try:\n            log_dir = Path.home() / \".config\" / \"axium\" / \"logs\"\n            log_dir.mkdir(parents=True, exist_ok=True)\n\n            log_file = log_dir / f\"{spoke_name}.log\"\n            timestamp = datetime.now(timezone.utc).strftime(\"%Y-%m-%d %H:%M:%S UTC\")\n            log_line = f\"[{timestamp}] [{level}] {message}\\n\"\n\n            with log_file.open(\"a\") as f:\n                f.write(log_line)\n\n            logger.debug(\"Log written: spoke=%s level=%s\", spoke_name, level)\n            return {\"ok\": True}\n\n        except Exception as e:\n            logger.error(\"write_log failed: spoke=%s error=%s\", spoke_name, e)\n            return {\"ok\": False, \"error\": str(e)}\n\n    def _handle_register_prefix(self, msg: dict) -&gt; dict:\n        \"\"\"\n        Handle register_prefix IPC command.\n\n        Registers prefix rule with conflict detection.\n        \"\"\"\n        from . import prefix\n\n        spoke_name = msg.get(\"spoke\")\n        command = msg.get(\"command\")\n        wrapper = msg.get(\"wrapper\")\n\n        if not all([spoke_name, command, wrapper]):\n            return {\"ok\": False, \"error\": \"spoke, command, and wrapper required\"}\n\n        # Check for existing owner\n        existing_owner = prefix.get_rule_owner(command)\n        if existing_owner and existing_owner != spoke_name:\n            logger.warning(\n                \"Prefix conflict: %s tried to register '%s' but owned by %s\",\n                spoke_name,\n                command,\n                existing_owner,\n            )\n            return {\n                \"ok\": False,\n                \"error\": f\"command already registered by {existing_owner}\",\n                \"conflict\": True,\n            }\n\n        # Register\n        try:\n            success = prefix.register_prefix_rule(command, wrapper, spoke_name)\n            if success:\n                # Regenerate state cache\n                self._write_state_cache()\n                logger.info(\n                    \"Prefix registered: spoke=%s command=%s wrapper=%s\",\n                    spoke_name,\n                    command,\n                    wrapper,\n                )\n                return {\"ok\": True}\n            else:\n                return {\"ok\": False, \"error\": \"registration failed\"}\n\n        except Exception as e:\n            logger.error(\"Prefix registration failed: spoke=%s error=%s\", spoke_name, e)\n            return {\"ok\": False, \"error\": str(e)}\n\n    def _handle_get_hud_segments(self, msg: dict) -&gt; dict:\n        \"\"\"\n        Handle get_hud_segments IPC command.\n\n        Returns list of all registered HUD segments with their metadata.\n\n        Returns:\n            {\"ok\": True, \"segments\": [{\"name\": \"...\", \"priority\": 10, \"spoke\": \"...\"}]}\n        \"\"\"\n        try:\n            from .hud import get_registry\n\n            registry = get_registry()\n            segments = []\n\n            for segment in registry.segments:\n                segments.append(\n                    {\n                        \"name\": segment.name,\n                        \"priority\": segment.priority,\n                        \"spoke\": getattr(segment, \"spoke\", None) or \"core\",\n                    }\n                )\n\n            # Sort by priority\n            segments.sort(key=lambda x: x[\"priority\"])\n\n            return {\"ok\": True, \"segments\": segments}\n\n        except Exception as e:\n            logger.error(\"get_hud_segments failed: error=%s\", e)\n            return {\"ok\": False, \"error\": str(e)}\n\n    async def handle_client(\n        self, reader: asyncio.StreamReader, writer: asyncio.StreamWriter\n    ) -&gt; None:\n        \"\"\"\n        Handle an IPC request from a client.\n\n        Reads JSON request from socket, processes command, sends JSON response.\n        Each command is handled synchronously but multiple clients can connect\n        concurrently.\n\n        Args:\n            reader: asyncio StreamReader for reading request\n            writer: asyncio StreamWriter for sending response\n\n        IPC Request Format:\n            ```json\n            {\"cmd\": \"command_name\", \"arg1\": \"value\", ...}\n            ```\n\n        IPC Response Format:\n            ```json\n            {\"ok\": true, \"result\": ...}\n            // or\n            {\"ok\": false, \"error\": \"message\"}\n            ```\n\n        Supported Commands:\n            ```json\n            ping: {\"cmd\": \"ping\"} \u2192 {\"ok\": true, \"pong\": true}\n\n            get_state: {\"cmd\": \"get_state\"} \u2192 {\"ok\": true, \"state\": {...}}\n\n            set_env: {\"cmd\": \"set_env\", \"value\": \"prod\"}\n                   \u2192 {\"ok\": true}\n                   Side effect: Emits env_change event to Spokes\n\n            set_pane_env: {\"cmd\": \"set_pane_env\", \"pane\": \"%1\", \"value\": \"prod\"}\n                        \u2192 {\"ok\": true}\n                        Side effect: Emits env_change event with pane context\n\n            get_hud: {\"cmd\": \"get_hud\", \"pane\": \"%1\"}\n                   \u2192 {\"ok\": true, \"hud\": \"[axium] pane:%1  env:prod  uptime:2h15m\"}\n                   Fast path: Returns pre-rendered HUD string from cache\n\n            get_pane_env: {\"cmd\": \"get_pane_env\", \"pane\": \"%1\"}\n                        \u2192 {\"ok\": true, \"env\": \"prod\"}\n\n            clear_pane_env: {\"cmd\": \"clear_pane_env\", \"pane\": \"%1\"}\n                          \u2192 {\"ok\": true}\n\n            reload: {\"cmd\": \"reload\"} \u2192 {\"ok\": true, \"reloaded\": true}\n                   Side effect: Reloads state from disk\n\n            apply_prefixes: {\"cmd\": \"apply_prefixes\", \"command\": \"aws\",\n                            \"args\": [\"s3\", \"ls\"], \"context\": {...}}\n                          \u2192 {\"ok\": true, \"command\": [...], \"env_vars\": {...}}\n\n            list_prefixed_commands: {\"cmd\": \"list_prefixed_commands\"}\n                                  \u2192 {\"ok\": true, \"commands\": [\"aws\", \"terraform\", ...]}\n\n            stop: {\"cmd\": \"stop\"} \u2192 {\"ok\": true, \"stopping\": True}\n                 Side effect: Triggers graceful shutdown\n            ```\n\n        Note:\n            Errors are caught and returned as {\"ok\": false, \"error\": \"message\"}\n            Connection is closed after each request (no persistent connections)\n        \"\"\"\n        try:\n            raw = await reader.readline()\n            if not raw:\n                writer.close()\n                return\n            msg = json.loads(raw.decode())\n            cmd = msg.get(\"cmd\")\n            logger.debug(\"Received IPC command: %s\", cmd)\n\n            if cmd == \"ping\":\n                resp = {\"ok\": True, \"pong\": True}\n            elif cmd == \"get_state\":\n                resp = {\"ok\": True, \"state\": self.state}\n            elif cmd == \"set_env\":\n                new_env = msg.get(\"value\")\n\n                # Validate environment name before setting\n                from . import env as env_module\n\n                is_valid, error = env_module.validate_env_name(new_env)\n                if not is_valid:\n                    resp = {\"ok\": False, \"error\": error}\n                else:\n                    old_env = self.state.get(\"active_env\")\n                    self.state[\"active_env\"] = new_env\n                    self._save_state()\n                    logger.info(\"Environment set to: %s\", new_env)\n\n                    # Invalidate all config caches (env-aware configs need refresh)\n                    from . import config\n\n                    config.invalidate_cache()\n                    logger.debug(\"Invalidated all config caches due to env change\")\n\n                    # Emit env_change event\n                    from . import spokes\n\n                    spokes.get_event_bus().emit(\"env_change\", new_env, old_env)\n\n                    resp = {\"ok\": True}\n            elif cmd == \"get_hud\":\n                # Render HUD fresh each time (includes dynamic uptime)\n                pane_id = msg.get(\"pane\")\n                if not pane_id:\n                    resp = {\"ok\": False, \"error\": \"pane ID required\"}\n                else:\n                    try:\n                        # Always render fresh to get current uptime\n                        logger.debug(\"Rendering HUD for pane %s\", pane_id)\n                        hud_str = self._render_hud_for_pane(pane_id)\n                        logger.debug(\"HUD rendered: %s\", hud_str)\n                        resp = {\"ok\": True, \"hud\": hud_str}\n                    except Exception as e:\n                        import traceback\n\n                        logger.error(\n                            \"Error rendering HUD for pane %s: %s\\n%s\",\n                            pane_id,\n                            e,\n                            traceback.format_exc(),\n                        )\n                        resp = {\"ok\": True, \"hud\": \"[axium] inactive\"}\n            elif cmd == \"set_pane_env\":\n                resp = self._handle_set_pane_env(msg)\n            elif cmd == \"get_pane_env\":\n                resp = self._handle_get_pane_env(msg)\n            elif cmd == \"clear_pane_env\":\n                resp = self._handle_clear_pane_env(msg)\n            elif cmd == \"reload\":\n                logger.info(\"Reload command received\")\n                # Reload state from disk\n                self._load_state()\n                # Reload HUD configuration\n                self._load_hud_config()\n                # Reload prefix configuration\n                prefix.reload_config()\n                # Reload all spoke configurations\n                from . import config\n\n                config.reload_all_configs()\n                # Regenerate state cache in case prefix rules changed\n                self._write_state_cache()\n                # Refresh HUD cache for all panes\n                self._refresh_all_hud_caches()\n                # Emit post-reload events\n                self.bus.emit(\"hud_refresh\")\n                self.bus.emit(\"daemon_reload\")\n                self.bus.emit(\"config_reloaded\")\n                resp = {\"ok\": True, \"reloaded\": True}\n            elif cmd == \"apply_prefixes\":\n                # Apply prefix rules to a command\n                command = msg.get(\"command\")\n                args = msg.get(\"args\", [])\n                context = msg.get(\"context\", {})\n\n                try:\n                    final_cmd, env_vars = prefix.apply_prefixes(command, args, context)\n                    resp = {\n                        \"ok\": True,\n                        \"command\": final_cmd,\n                        \"env_vars\": env_vars,\n                    }\n                except Exception as e:\n                    logger.error(\"Failed to apply prefixes: %s\", e)\n                    resp = {\"ok\": False, \"error\": str(e)}\n            elif cmd == \"list_prefixed_commands\":\n                # List all commands that have prefix rules\n                try:\n                    commands = prefix.get_prefixed_commands()\n                    resp = {\"ok\": True, \"commands\": commands}\n                except Exception as e:\n                    logger.error(\"Failed to list prefixed commands: %s\", e)\n                    resp = {\"ok\": False, \"error\": str(e)}\n            elif cmd == \"notify\":\n                resp = self._handle_notify(msg)\n            elif cmd == \"daemon_exec\":\n                resp = self._handle_daemon_exec(msg)\n            elif cmd == \"notify_drain\":\n                resp = self._handle_notify_drain(msg)\n            elif cmd == \"get_permissions\":\n                resp = self._handle_get_permissions(msg)\n            elif cmd == \"load_spoke_permissions\":\n                resp = self._handle_load_spoke_permissions(msg)\n            elif cmd == \"get_config\":\n                resp = self._handle_get_config(msg)\n            elif cmd == \"tmux_split_run\":\n                resp = self._handle_tmux_split_run(msg)\n            elif cmd == \"tmux_send_keys\":\n                resp = self._handle_tmux_send_keys(msg)\n            elif cmd == \"tmux_capture_pane\":\n                resp = self._handle_tmux_capture_pane(msg)\n            elif cmd == \"read_file\":\n                resp = self._handle_read_file(msg)\n            elif cmd == \"write_file\":\n                resp = self._handle_write_file(msg)\n            elif cmd == \"write_log\":\n                resp = self._handle_write_log(msg)\n            elif cmd == \"register_prefix\":\n                resp = self._handle_register_prefix(msg)\n            elif cmd == \"get_hud_segments\":\n                resp = self._handle_get_hud_segments(msg)\n            elif cmd == \"daemon_status\":\n                # Return daemon status information\n                uptime_seconds = int(time.time() - self._start_time)\n                # Format uptime as \"Xh Ym Zs\"\n                hours = uptime_seconds // 3600\n                minutes = (uptime_seconds % 3600) // 60\n                seconds = uptime_seconds % 60\n\n                parts = []\n                if hours &gt; 0:\n                    parts.append(f\"{hours}h\")\n                if minutes &gt; 0 or hours &gt; 0:  # Show minutes if we have hours\n                    parts.append(f\"{minutes}m\")\n                parts.append(f\"{seconds}s\")\n                uptime_str = \" \".join(parts)\n\n                resp = {\n                    \"ok\": True,\n                    \"status\": {\n                        \"running\": True,\n                        \"uptime\": uptime_str,\n                        \"active_env\": self.state.get(\"active_env\"),\n                        \"panes\": len(self.state.get(\"panes\", {})),\n                    },\n                }\n            elif cmd == \"reload_spoke\":\n                # Reload a specific spoke - daemon performs the action\n                spoke_name = msg.get(\"spoke\")\n                if not spoke_name:\n                    resp = {\"ok\": False, \"error\": \"spoke name required\"}\n                else:\n                    try:\n                        # PERFORM THE ACTION (don't just emit event)\n                        from axium.core.spokes import reload_spokes\n\n                        reloaded = reload_spokes(spoke_name)\n\n                        if reloaded:\n                            # THEN emit post-action notification\n                            self.bus.emit(\"spoke_reloaded\", spoke_name=spoke_name)\n                            resp = {\"ok\": True, \"spoke\": spoke_name}\n                        else:\n                            resp = {\n                                \"ok\": False,\n                                \"error\": f\"failed to reload spoke: {spoke_name}\",\n                            }\n                    except Exception as e:\n                        logger.error(\"Spoke reload failed: %s\", e)\n                        resp = {\"ok\": False, \"error\": str(e)}\n            elif cmd == \"reload_spokes\":\n                # Reload all spokes - daemon performs the action\n                try:\n                    from axium.core.spokes import reload_spokes\n\n                    reloaded_list = reload_spokes()  # Reload all\n\n                    # Emit post-action event for EACH reloaded spoke\n                    for spoke_name in reloaded_list:\n                        self.bus.emit(\"spoke_reloaded\", spoke_name=spoke_name)\n\n                    resp = {\"ok\": True, \"spokes\": reloaded_list}\n                except Exception as e:\n                    logger.error(\"Spokes reload failed: %s\", e)\n                    resp = {\"ok\": False, \"error\": str(e), \"spokes\": []}\n            elif cmd == \"stop\":\n                logger.info(\"Stop command received\")\n                resp = {\"ok\": True, \"stopping\": True}\n                writer.write((json.dumps(resp) + \"\\n\").encode())\n                await writer.drain()\n                writer.close()\n                await asyncio.sleep(0.05)\n                self._stop.set()\n                return\n            else:\n                logger.warning(\"Unknown command received: %s\", cmd)\n                resp = {\"ok\": False, \"error\": \"unknown command\"}\n            writer.write((json.dumps(resp) + \"\\n\").encode())\n            await writer.drain()\n            writer.close()\n        except Exception as e:\n            logger.error(\"Error handling IPC request: %s\", e, exc_info=True)\n            try:\n                writer.write(\n                    (json.dumps({\"ok\": False, \"error\": str(e)}) + \"\\n\").encode()\n                )\n                await writer.drain()\n                writer.close()\n            except Exception:\n                pass\n\n    async def _periodic_segment_update(self) -&gt; None:\n        \"\"\"\n        Periodically update cached HUD segments.\n\n        Runs every 5 minutes to refresh expensive segments like credential checks.\n        This ensures segments stay up-to-date even without explicit events.\n        \"\"\"\n        while not self._stop.is_set():\n            try:\n                await asyncio.sleep(300)  # 5 minutes\n                if self._stop.is_set():\n                    break\n\n                # Update all cached segments\n                from .hud import get_registry\n\n                registry = get_registry()\n                env_name = self.state.get(\"env\", \"-\")\n                context = {\"env\": env_name, \"state\": self.state}\n                registry.update_cached_segments(context)\n                logger.debug(\"Periodic cached segment update complete\")\n\n            except Exception as e:\n                logger.error(\"Error in periodic segment update: %s\", e)\n\n    async def run(self) -&gt; None:\n        \"\"\"\n        Run the daemon event loop.\n\n        Starts UNIX socket server and waits for shutdown signal.\n        Cleans up socket file on exit.\n\n        The server accepts connections on /tmp/axiumd.sock and handles\n        each client in a separate task via handle_client().\n\n        Blocks until _stop event is set (via stop command or signal).\n\n        Side Effects:\n            - Creates UNIX socket at /tmp/axiumd.sock\n            - Removes existing socket if present\n            - Cleans up socket on exit\n            - Starts periodic cached segment updates every 5 minutes\n\n        Note:\n            This should be run via asyncio.run() in the main process.\n        \"\"\"\n        if SOCKET_PATH.exists():\n            try:\n                SOCKET_PATH.unlink()\n                logger.debug(\"Removed existing socket at %s\", SOCKET_PATH)\n            except FileNotFoundError:\n                pass\n        logger.info(\"Starting Unix socket server at %s\", SOCKET_PATH)\n        self.server = await asyncio.start_unix_server(\n            self.handle_client, path=str(SOCKET_PATH)\n        )\n\n        # Start periodic segment update task\n        update_task = asyncio.create_task(self._periodic_segment_update())\n\n        try:\n            async with self.server:\n                logger.info(\"Daemon ready, waiting for connections\")\n                await self._stop.wait()\n        finally:\n            # Cancel periodic task\n            update_task.cancel()\n            try:\n                await update_task\n            except asyncio.CancelledError:\n                pass\n\n        logger.info(\"Cleaning up socket\")\n        try:\n            SOCKET_PATH.unlink()\n        except FileNotFoundError:\n            pass\n</code></pre>"},{"location":"reference/api/daemon/#axium.core.daemon.AxiumDaemon.__init__","title":"<code>__init__()</code>","text":"<p>Initialize daemon with default state.</p> <p>Loads persistent state from state.json if it exists, otherwise initializes with defaults. Creates empty event registry.</p> Source code in <code>axium/core/daemon.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initialize daemon with default state.\n\n    Loads persistent state from state.json if it exists, otherwise\n    initializes with defaults. Creates empty event registry.\n    \"\"\"\n    # Runtime-only state (not persisted)\n    self.state = {\n        \"active_env\": None,\n        \"panes\": {},  # Per-pane environment mapping: {\"%1\": \"root\", \"%2\": \"builder\"}\n        \"hud_cache\": {},  # Pre-rendered HUD strings: {\"%1\": \"[axium] pane:%1 ...\"}\n        \"tmux_pane\": os.getenv(\"TMUX_PANE\"),\n        \"started\": datetime.now(timezone.utc).isoformat().replace(\"+00:00\", \"Z\"),\n    }\n    self._start_time = time.time()  # Unix timestamp for fast uptime calculations\n    self.permissions = (\n        {}\n    )  # Effective permissions per spoke: {spoke_name: SpokePermissions}\n    self.notification_queue = (\n        []\n    )  # Queued notifications: [{\"title\": ..., \"body\": ..., \"spoke\": ...}]\n    self.hud_config = {}  # HUD layout configuration from hud.yaml\n    self.server = None\n    self._stop = asyncio.Event()\n\n    # Initialize EventBus for spoke coordination\n    from axium.core.spokes import get_event_bus\n\n    self.bus = get_event_bus()\n\n    # Set up completion cache event listeners\n    self.bus.on(\"spoke_loaded\", self._on_spoke_loaded)\n    self.bus.on(\"spoke_reloaded\", self._on_spoke_reloaded)\n    self.bus.on(\"spoke_unloaded\", self._on_spoke_unloaded)\n    self.bus.on(\"gear_loaded\", self._on_gear_loaded)\n    self.bus.on(\"gear_unloaded\", self._on_gear_unloaded)\n    self.bus.on(\"daemon_reload\", self._on_daemon_reload)\n\n    self._load_state()\n    self._load_hud_config()  # Load HUD layout from hud.yaml\n    self._write_state_cache()\n    self._refresh_all_hud_caches()  # Pre-render HUD for all panes\n\n    # Load gears for daemon IPC operations\n    # Note: Gears are also loaded in CLI for command registration\n    # This loads them in daemon context for IPC permission enforcement\n    self._load_gears_for_daemon()\n\n    # Generate initial completion cache\n    self._regenerate_completions(\"daemon_init\")\n</code></pre>"},{"location":"reference/api/daemon/#axium.core.daemon.AxiumDaemon.handle_client","title":"<code>handle_client(reader, writer)</code>  <code>async</code>","text":"<p>Handle an IPC request from a client.</p> <p>Reads JSON request from socket, processes command, sends JSON response. Each command is handled synchronously but multiple clients can connect concurrently.</p> <p>Parameters:</p> Name Type Description Default <code>reader</code> <code>StreamReader</code> <p>asyncio StreamReader for reading request</p> required <code>writer</code> <code>StreamWriter</code> <p>asyncio StreamWriter for sending response</p> required IPC Request Format <pre><code>{\"cmd\": \"command_name\", \"arg1\": \"value\", ...}\n</code></pre> IPC Response Format <pre><code>{\"ok\": true, \"result\": ...}\n// or\n{\"ok\": false, \"error\": \"message\"}\n</code></pre> Supported Commands <pre><code>ping: {\"cmd\": \"ping\"} \u2192 {\"ok\": true, \"pong\": true}\n\nget_state: {\"cmd\": \"get_state\"} \u2192 {\"ok\": true, \"state\": {...}}\n\nset_env: {\"cmd\": \"set_env\", \"value\": \"prod\"}\n       \u2192 {\"ok\": true}\n       Side effect: Emits env_change event to Spokes\n\nset_pane_env: {\"cmd\": \"set_pane_env\", \"pane\": \"%1\", \"value\": \"prod\"}\n            \u2192 {\"ok\": true}\n            Side effect: Emits env_change event with pane context\n\nget_hud: {\"cmd\": \"get_hud\", \"pane\": \"%1\"}\n       \u2192 {\"ok\": true, \"hud\": \"[axium] pane:%1  env:prod  uptime:2h15m\"}\n       Fast path: Returns pre-rendered HUD string from cache\n\nget_pane_env: {\"cmd\": \"get_pane_env\", \"pane\": \"%1\"}\n            \u2192 {\"ok\": true, \"env\": \"prod\"}\n\nclear_pane_env: {\"cmd\": \"clear_pane_env\", \"pane\": \"%1\"}\n              \u2192 {\"ok\": true}\n\nreload: {\"cmd\": \"reload\"} \u2192 {\"ok\": true, \"reloaded\": true}\n       Side effect: Reloads state from disk\n\napply_prefixes: {\"cmd\": \"apply_prefixes\", \"command\": \"aws\",\n                \"args\": [\"s3\", \"ls\"], \"context\": {...}}\n              \u2192 {\"ok\": true, \"command\": [...], \"env_vars\": {...}}\n\nlist_prefixed_commands: {\"cmd\": \"list_prefixed_commands\"}\n                      \u2192 {\"ok\": true, \"commands\": [\"aws\", \"terraform\", ...]}\n\nstop: {\"cmd\": \"stop\"} \u2192 {\"ok\": true, \"stopping\": True}\n     Side effect: Triggers graceful shutdown\n</code></pre> Note <p>Errors are caught and returned as {\"ok\": false, \"error\": \"message\"} Connection is closed after each request (no persistent connections)</p> Source code in <code>axium/core/daemon.py</code> <pre><code>async def handle_client(\n    self, reader: asyncio.StreamReader, writer: asyncio.StreamWriter\n) -&gt; None:\n    \"\"\"\n    Handle an IPC request from a client.\n\n    Reads JSON request from socket, processes command, sends JSON response.\n    Each command is handled synchronously but multiple clients can connect\n    concurrently.\n\n    Args:\n        reader: asyncio StreamReader for reading request\n        writer: asyncio StreamWriter for sending response\n\n    IPC Request Format:\n        ```json\n        {\"cmd\": \"command_name\", \"arg1\": \"value\", ...}\n        ```\n\n    IPC Response Format:\n        ```json\n        {\"ok\": true, \"result\": ...}\n        // or\n        {\"ok\": false, \"error\": \"message\"}\n        ```\n\n    Supported Commands:\n        ```json\n        ping: {\"cmd\": \"ping\"} \u2192 {\"ok\": true, \"pong\": true}\n\n        get_state: {\"cmd\": \"get_state\"} \u2192 {\"ok\": true, \"state\": {...}}\n\n        set_env: {\"cmd\": \"set_env\", \"value\": \"prod\"}\n               \u2192 {\"ok\": true}\n               Side effect: Emits env_change event to Spokes\n\n        set_pane_env: {\"cmd\": \"set_pane_env\", \"pane\": \"%1\", \"value\": \"prod\"}\n                    \u2192 {\"ok\": true}\n                    Side effect: Emits env_change event with pane context\n\n        get_hud: {\"cmd\": \"get_hud\", \"pane\": \"%1\"}\n               \u2192 {\"ok\": true, \"hud\": \"[axium] pane:%1  env:prod  uptime:2h15m\"}\n               Fast path: Returns pre-rendered HUD string from cache\n\n        get_pane_env: {\"cmd\": \"get_pane_env\", \"pane\": \"%1\"}\n                    \u2192 {\"ok\": true, \"env\": \"prod\"}\n\n        clear_pane_env: {\"cmd\": \"clear_pane_env\", \"pane\": \"%1\"}\n                      \u2192 {\"ok\": true}\n\n        reload: {\"cmd\": \"reload\"} \u2192 {\"ok\": true, \"reloaded\": true}\n               Side effect: Reloads state from disk\n\n        apply_prefixes: {\"cmd\": \"apply_prefixes\", \"command\": \"aws\",\n                        \"args\": [\"s3\", \"ls\"], \"context\": {...}}\n                      \u2192 {\"ok\": true, \"command\": [...], \"env_vars\": {...}}\n\n        list_prefixed_commands: {\"cmd\": \"list_prefixed_commands\"}\n                              \u2192 {\"ok\": true, \"commands\": [\"aws\", \"terraform\", ...]}\n\n        stop: {\"cmd\": \"stop\"} \u2192 {\"ok\": true, \"stopping\": True}\n             Side effect: Triggers graceful shutdown\n        ```\n\n    Note:\n        Errors are caught and returned as {\"ok\": false, \"error\": \"message\"}\n        Connection is closed after each request (no persistent connections)\n    \"\"\"\n    try:\n        raw = await reader.readline()\n        if not raw:\n            writer.close()\n            return\n        msg = json.loads(raw.decode())\n        cmd = msg.get(\"cmd\")\n        logger.debug(\"Received IPC command: %s\", cmd)\n\n        if cmd == \"ping\":\n            resp = {\"ok\": True, \"pong\": True}\n        elif cmd == \"get_state\":\n            resp = {\"ok\": True, \"state\": self.state}\n        elif cmd == \"set_env\":\n            new_env = msg.get(\"value\")\n\n            # Validate environment name before setting\n            from . import env as env_module\n\n            is_valid, error = env_module.validate_env_name(new_env)\n            if not is_valid:\n                resp = {\"ok\": False, \"error\": error}\n            else:\n                old_env = self.state.get(\"active_env\")\n                self.state[\"active_env\"] = new_env\n                self._save_state()\n                logger.info(\"Environment set to: %s\", new_env)\n\n                # Invalidate all config caches (env-aware configs need refresh)\n                from . import config\n\n                config.invalidate_cache()\n                logger.debug(\"Invalidated all config caches due to env change\")\n\n                # Emit env_change event\n                from . import spokes\n\n                spokes.get_event_bus().emit(\"env_change\", new_env, old_env)\n\n                resp = {\"ok\": True}\n        elif cmd == \"get_hud\":\n            # Render HUD fresh each time (includes dynamic uptime)\n            pane_id = msg.get(\"pane\")\n            if not pane_id:\n                resp = {\"ok\": False, \"error\": \"pane ID required\"}\n            else:\n                try:\n                    # Always render fresh to get current uptime\n                    logger.debug(\"Rendering HUD for pane %s\", pane_id)\n                    hud_str = self._render_hud_for_pane(pane_id)\n                    logger.debug(\"HUD rendered: %s\", hud_str)\n                    resp = {\"ok\": True, \"hud\": hud_str}\n                except Exception as e:\n                    import traceback\n\n                    logger.error(\n                        \"Error rendering HUD for pane %s: %s\\n%s\",\n                        pane_id,\n                        e,\n                        traceback.format_exc(),\n                    )\n                    resp = {\"ok\": True, \"hud\": \"[axium] inactive\"}\n        elif cmd == \"set_pane_env\":\n            resp = self._handle_set_pane_env(msg)\n        elif cmd == \"get_pane_env\":\n            resp = self._handle_get_pane_env(msg)\n        elif cmd == \"clear_pane_env\":\n            resp = self._handle_clear_pane_env(msg)\n        elif cmd == \"reload\":\n            logger.info(\"Reload command received\")\n            # Reload state from disk\n            self._load_state()\n            # Reload HUD configuration\n            self._load_hud_config()\n            # Reload prefix configuration\n            prefix.reload_config()\n            # Reload all spoke configurations\n            from . import config\n\n            config.reload_all_configs()\n            # Regenerate state cache in case prefix rules changed\n            self._write_state_cache()\n            # Refresh HUD cache for all panes\n            self._refresh_all_hud_caches()\n            # Emit post-reload events\n            self.bus.emit(\"hud_refresh\")\n            self.bus.emit(\"daemon_reload\")\n            self.bus.emit(\"config_reloaded\")\n            resp = {\"ok\": True, \"reloaded\": True}\n        elif cmd == \"apply_prefixes\":\n            # Apply prefix rules to a command\n            command = msg.get(\"command\")\n            args = msg.get(\"args\", [])\n            context = msg.get(\"context\", {})\n\n            try:\n                final_cmd, env_vars = prefix.apply_prefixes(command, args, context)\n                resp = {\n                    \"ok\": True,\n                    \"command\": final_cmd,\n                    \"env_vars\": env_vars,\n                }\n            except Exception as e:\n                logger.error(\"Failed to apply prefixes: %s\", e)\n                resp = {\"ok\": False, \"error\": str(e)}\n        elif cmd == \"list_prefixed_commands\":\n            # List all commands that have prefix rules\n            try:\n                commands = prefix.get_prefixed_commands()\n                resp = {\"ok\": True, \"commands\": commands}\n            except Exception as e:\n                logger.error(\"Failed to list prefixed commands: %s\", e)\n                resp = {\"ok\": False, \"error\": str(e)}\n        elif cmd == \"notify\":\n            resp = self._handle_notify(msg)\n        elif cmd == \"daemon_exec\":\n            resp = self._handle_daemon_exec(msg)\n        elif cmd == \"notify_drain\":\n            resp = self._handle_notify_drain(msg)\n        elif cmd == \"get_permissions\":\n            resp = self._handle_get_permissions(msg)\n        elif cmd == \"load_spoke_permissions\":\n            resp = self._handle_load_spoke_permissions(msg)\n        elif cmd == \"get_config\":\n            resp = self._handle_get_config(msg)\n        elif cmd == \"tmux_split_run\":\n            resp = self._handle_tmux_split_run(msg)\n        elif cmd == \"tmux_send_keys\":\n            resp = self._handle_tmux_send_keys(msg)\n        elif cmd == \"tmux_capture_pane\":\n            resp = self._handle_tmux_capture_pane(msg)\n        elif cmd == \"read_file\":\n            resp = self._handle_read_file(msg)\n        elif cmd == \"write_file\":\n            resp = self._handle_write_file(msg)\n        elif cmd == \"write_log\":\n            resp = self._handle_write_log(msg)\n        elif cmd == \"register_prefix\":\n            resp = self._handle_register_prefix(msg)\n        elif cmd == \"get_hud_segments\":\n            resp = self._handle_get_hud_segments(msg)\n        elif cmd == \"daemon_status\":\n            # Return daemon status information\n            uptime_seconds = int(time.time() - self._start_time)\n            # Format uptime as \"Xh Ym Zs\"\n            hours = uptime_seconds // 3600\n            minutes = (uptime_seconds % 3600) // 60\n            seconds = uptime_seconds % 60\n\n            parts = []\n            if hours &gt; 0:\n                parts.append(f\"{hours}h\")\n            if minutes &gt; 0 or hours &gt; 0:  # Show minutes if we have hours\n                parts.append(f\"{minutes}m\")\n            parts.append(f\"{seconds}s\")\n            uptime_str = \" \".join(parts)\n\n            resp = {\n                \"ok\": True,\n                \"status\": {\n                    \"running\": True,\n                    \"uptime\": uptime_str,\n                    \"active_env\": self.state.get(\"active_env\"),\n                    \"panes\": len(self.state.get(\"panes\", {})),\n                },\n            }\n        elif cmd == \"reload_spoke\":\n            # Reload a specific spoke - daemon performs the action\n            spoke_name = msg.get(\"spoke\")\n            if not spoke_name:\n                resp = {\"ok\": False, \"error\": \"spoke name required\"}\n            else:\n                try:\n                    # PERFORM THE ACTION (don't just emit event)\n                    from axium.core.spokes import reload_spokes\n\n                    reloaded = reload_spokes(spoke_name)\n\n                    if reloaded:\n                        # THEN emit post-action notification\n                        self.bus.emit(\"spoke_reloaded\", spoke_name=spoke_name)\n                        resp = {\"ok\": True, \"spoke\": spoke_name}\n                    else:\n                        resp = {\n                            \"ok\": False,\n                            \"error\": f\"failed to reload spoke: {spoke_name}\",\n                        }\n                except Exception as e:\n                    logger.error(\"Spoke reload failed: %s\", e)\n                    resp = {\"ok\": False, \"error\": str(e)}\n        elif cmd == \"reload_spokes\":\n            # Reload all spokes - daemon performs the action\n            try:\n                from axium.core.spokes import reload_spokes\n\n                reloaded_list = reload_spokes()  # Reload all\n\n                # Emit post-action event for EACH reloaded spoke\n                for spoke_name in reloaded_list:\n                    self.bus.emit(\"spoke_reloaded\", spoke_name=spoke_name)\n\n                resp = {\"ok\": True, \"spokes\": reloaded_list}\n            except Exception as e:\n                logger.error(\"Spokes reload failed: %s\", e)\n                resp = {\"ok\": False, \"error\": str(e), \"spokes\": []}\n        elif cmd == \"stop\":\n            logger.info(\"Stop command received\")\n            resp = {\"ok\": True, \"stopping\": True}\n            writer.write((json.dumps(resp) + \"\\n\").encode())\n            await writer.drain()\n            writer.close()\n            await asyncio.sleep(0.05)\n            self._stop.set()\n            return\n        else:\n            logger.warning(\"Unknown command received: %s\", cmd)\n            resp = {\"ok\": False, \"error\": \"unknown command\"}\n        writer.write((json.dumps(resp) + \"\\n\").encode())\n        await writer.drain()\n        writer.close()\n    except Exception as e:\n        logger.error(\"Error handling IPC request: %s\", e, exc_info=True)\n        try:\n            writer.write(\n                (json.dumps({\"ok\": False, \"error\": str(e)}) + \"\\n\").encode()\n            )\n            await writer.drain()\n            writer.close()\n        except Exception:\n            pass\n</code></pre>"},{"location":"reference/api/daemon/#axium.core.daemon.AxiumDaemon.run","title":"<code>run()</code>  <code>async</code>","text":"<p>Run the daemon event loop.</p> <p>Starts UNIX socket server and waits for shutdown signal. Cleans up socket file on exit.</p> <p>The server accepts connections on /tmp/axiumd.sock and handles each client in a separate task via handle_client().</p> <p>Blocks until _stop event is set (via stop command or signal).</p> Side Effects <ul> <li>Creates UNIX socket at /tmp/axiumd.sock</li> <li>Removes existing socket if present</li> <li>Cleans up socket on exit</li> <li>Starts periodic cached segment updates every 5 minutes</li> </ul> Note <p>This should be run via asyncio.run() in the main process.</p> Source code in <code>axium/core/daemon.py</code> <pre><code>async def run(self) -&gt; None:\n    \"\"\"\n    Run the daemon event loop.\n\n    Starts UNIX socket server and waits for shutdown signal.\n    Cleans up socket file on exit.\n\n    The server accepts connections on /tmp/axiumd.sock and handles\n    each client in a separate task via handle_client().\n\n    Blocks until _stop event is set (via stop command or signal).\n\n    Side Effects:\n        - Creates UNIX socket at /tmp/axiumd.sock\n        - Removes existing socket if present\n        - Cleans up socket on exit\n        - Starts periodic cached segment updates every 5 minutes\n\n    Note:\n        This should be run via asyncio.run() in the main process.\n    \"\"\"\n    if SOCKET_PATH.exists():\n        try:\n            SOCKET_PATH.unlink()\n            logger.debug(\"Removed existing socket at %s\", SOCKET_PATH)\n        except FileNotFoundError:\n            pass\n    logger.info(\"Starting Unix socket server at %s\", SOCKET_PATH)\n    self.server = await asyncio.start_unix_server(\n        self.handle_client, path=str(SOCKET_PATH)\n    )\n\n    # Start periodic segment update task\n    update_task = asyncio.create_task(self._periodic_segment_update())\n\n    try:\n        async with self.server:\n            logger.info(\"Daemon ready, waiting for connections\")\n            await self._stop.wait()\n    finally:\n        # Cancel periodic task\n        update_task.cancel()\n        try:\n            await update_task\n        except asyncio.CancelledError:\n            pass\n\n    logger.info(\"Cleaning up socket\")\n    try:\n        SOCKET_PATH.unlink()\n    except FileNotFoundError:\n        pass\n</code></pre>"},{"location":"reference/api/daemon/#axium.core.daemon.kill_daemon_pid","title":"<code>kill_daemon_pid()</code>","text":"<p>Kill daemon process by PID from file.</p> <p>Reads PID from axiumd.pid and sends SIGTERM. If process doesn't exist, removes stale PID file.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if process was killed or didn't exist, False on error</p> Side Effects <ul> <li>Sends SIGTERM to daemon process</li> <li>Removes axiumd.pid file</li> </ul> Source code in <code>axium/core/daemon.py</code> <pre><code>def kill_daemon_pid() -&gt; bool:\n    \"\"\"\n    Kill daemon process by PID from file.\n\n    Reads PID from axiumd.pid and sends SIGTERM. If process doesn't exist,\n    removes stale PID file.\n\n    Returns:\n        True if process was killed or didn't exist, False on error\n\n    Side Effects:\n        - Sends SIGTERM to daemon process\n        - Removes axiumd.pid file\n    \"\"\"\n    pid = _read_pid()\n    if not pid:\n        return True\n\n    try:\n        os.kill(pid, signal.SIGTERM)\n        logger.debug(\"Sent SIGTERM to daemon PID %d\", pid)\n        # Wait briefly for process to exit\n        for _ in range(10):\n            try:\n                os.kill(pid, 0)  # Check if process exists\n                time.sleep(0.1)\n            except ProcessLookupError:\n                break\n        PID_PATH.unlink(missing_ok=True)\n        return True\n    except ProcessLookupError:\n        # Process doesn't exist, clean up PID file\n        PID_PATH.unlink(missing_ok=True)\n        return True\n    except Exception as e:\n        logger.debug(\"Failed to kill daemon PID %d: %s\", pid, e)\n        return False\n</code></pre>"},{"location":"reference/api/daemon/#axium.core.daemon.cleanup_zombie_daemons","title":"<code>cleanup_zombie_daemons()</code>","text":"<p>Clean up zombie axium daemon processes.</p> <p>Finds all running \"axium daemon start\" processes and kills them, except for the current process and the legitimate daemon from PID file.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of processes killed</p> Note <p>Uses pgrep to find and terminate zombie daemon processes. Protects the legitimate daemon PID from the PID file. Skips cleanup if PYTEST_CURRENT_TEST environment variable is set.</p> Source code in <code>axium/core/daemon.py</code> <pre><code>def cleanup_zombie_daemons() -&gt; int:\n    \"\"\"\n    Clean up zombie axium daemon processes.\n\n    Finds all running \"axium daemon start\" processes and kills them,\n    except for the current process and the legitimate daemon from PID file.\n\n    Returns:\n        Number of processes killed\n\n    Note:\n        Uses pgrep to find and terminate zombie daemon processes.\n        Protects the legitimate daemon PID from the PID file.\n        Skips cleanup if PYTEST_CURRENT_TEST environment variable is set.\n    \"\"\"\n    import subprocess\n\n    # Skip cleanup in test environment to avoid interfering with mocks\n    if os.getenv(\"PYTEST_CURRENT_TEST\"):\n        return 0\n\n    killed = 0\n\n    try:\n        # Get current process PID to avoid killing ourselves\n        current_pid = os.getpid()\n\n        # Read legitimate daemon PID from file - must protect this!\n        daemon_pid = _read_pid()\n\n        # Find all axium daemon processes\n        result = subprocess.run(\n            [\"pgrep\", \"-f\", \"axium daemon start\"], capture_output=True, text=True\n        )\n\n        if result.returncode == 0:\n            pids = [int(p) for p in result.stdout.strip().split(\"\\n\") if p]\n            for pid in pids:\n                # Skip current process\n                if pid == current_pid:\n                    continue\n\n                # Skip the legitimate daemon from PID file\n                # This is the key fix - don't kill the running daemon!\n                if daemon_pid and pid == daemon_pid:\n                    logger.debug(\n                        \"Skipping legitimate daemon PID %d (from PID file)\", pid\n                    )\n                    continue\n\n                # This is an orphaned/zombie process - kill it\n                try:\n                    os.kill(pid, signal.SIGTERM)\n                    killed += 1\n                    logger.debug(\"Killed zombie daemon process PID %d\", pid)\n                except (ProcessLookupError, PermissionError):\n                    pass\n\n    except Exception as e:\n        logger.debug(\"Failed to cleanup zombie daemons: %s\", e)\n\n    return killed\n</code></pre>"},{"location":"reference/api/daemon/#axium.core.daemon.start","title":"<code>start(debug=False)</code>","text":"<p>Start the Axium daemon process.</p> <p>In normal mode (debug=False), performs double fork to daemonize: 1. Fork once to detach from parent 2. Create new session (setsid) 3. Fork again to prevent zombie process 4. Parent exits, child continues as daemon</p> <p>In debug mode (debug=True), runs in foreground with console logging.</p> <p>Parameters:</p> Name Type Description Default <code>debug</code> <code>bool</code> <p>If True, run in foreground with logs to stdout.    If False, daemonize and log to ~/.config/axium/axiumd.log.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if daemon started successfully (parent process in daemon mode).</p> <code>bool</code> <p>In debug mode, never returns (runs until stopped).</p> Side Effects <ul> <li>Calls bootstrap.ensure_axium_config() to create config directory</li> <li>Writes PID to ~/.config/axium/axiumd.pid</li> <li>Creates UNIX socket at /tmp/axiumd.sock</li> <li>Sets up signal handlers (SIGTERM, SIGINT)</li> <li>Runs until stop command or signal received</li> </ul> Example <pre><code># Background daemon\nif start(debug=False):\n    print(\"Daemon started successfully\")\n\n# Foreground (for development)\nstart(debug=True)  # Never returns\n</code></pre> Note <p>Parent process returns True immediately in daemon mode. Child process runs until stopped (never returns).</p> Source code in <code>axium/core/daemon.py</code> <pre><code>def start(debug: bool = False) -&gt; bool:\n    \"\"\"\n    Start the Axium daemon process.\n\n    In normal mode (debug=False), performs double fork to daemonize:\n    1. Fork once to detach from parent\n    2. Create new session (setsid)\n    3. Fork again to prevent zombie process\n    4. Parent exits, child continues as daemon\n\n    In debug mode (debug=True), runs in foreground with console logging.\n\n    Args:\n        debug: If True, run in foreground with logs to stdout.\n               If False, daemonize and log to ~/.config/axium/axiumd.log.\n\n    Returns:\n        True if daemon started successfully (parent process in daemon mode).\n        In debug mode, never returns (runs until stopped).\n\n    Side Effects:\n        - Calls bootstrap.ensure_axium_config() to create config directory\n        - Writes PID to ~/.config/axium/axiumd.pid\n        - Creates UNIX socket at /tmp/axiumd.sock\n        - Sets up signal handlers (SIGTERM, SIGINT)\n        - Runs until stop command or signal received\n\n    Example:\n        ```python\n        # Background daemon\n        if start(debug=False):\n            print(\"Daemon started successfully\")\n\n        # Foreground (for development)\n        start(debug=True)  # Never returns\n        ```\n\n    Note:\n        Parent process returns True immediately in daemon mode.\n        Child process runs until stopped (never returns).\n    \"\"\"\n    # Clean up any zombie daemon processes first\n    killed = cleanup_zombie_daemons()\n    if killed &gt; 0:\n        logger.debug(\"Cleaned up %d zombie daemon process(es)\", killed)\n\n    # Ensure config directory and files exist\n    from . import bootstrap\n\n    bootstrap.ensure_axium_config()\n\n    if not debug:\n        pid = os.fork()\n        if pid &gt; 0:\n            _write_pid(pid)\n            return True\n        os.setsid()\n        pid2 = os.fork()\n        if pid2 &gt; 0:\n            os._exit(0)\n\n        # Redirect stdin, stdout, stderr to /dev/null in daemon mode\n        devnull = os.open(os.devnull, os.O_RDWR)\n        os.dup2(devnull, sys.stdin.fileno())\n        os.dup2(devnull, sys.stdout.fileno())\n        os.dup2(devnull, sys.stderr.fileno())\n        if devnull &gt; 2:\n            os.close(devnull)\n\n    _setup_logging(debug)\n    logger.info(\"Axium daemon starting (debug=%s)\", debug)\n\n    loop = asyncio.new_event_loop()\n    asyncio.set_event_loop(loop)\n    daemon = AxiumDaemon()\n\n    def handle_sig(_sig, _frm):\n        logger.info(\"Received signal %s, shutting down\", _sig)\n        daemon._stop.set()\n\n    signal.signal(signal.SIGTERM, handle_sig)\n    signal.signal(signal.SIGINT, handle_sig)\n\n    try:\n        logger.info(\"Starting daemon event loop\")\n        loop.run_until_complete(daemon.run())\n    finally:\n        logger.info(\"Daemon stopped\")\n        loop.close()\n        if debug and PID_PATH.exists():\n            try:\n                PID_PATH.unlink()\n            except Exception:\n                pass\n</code></pre>"},{"location":"reference/api/daemon/#axium.core.daemon.stop","title":"<code>stop()</code>","text":"<p>Stop the Axium daemon.</p> <p>Attempts to stop daemon via IPC stop command. If that fails, reads PID from axiumd.pid and sends SIGTERM. Also cleans up any zombie daemon processes.</p> <p>Returns:</p> Type Description <code>dict</code> <p>dict with structure: {\"ok\": true, \"stopping\": true} - IPC stop successful {\"ok\": true, \"signal\": \"SIGTERM\"} - Sent SIGTERM to PID {\"ok\": false, \"error\": \"...\"} - Failed to stop</p> Example <pre><code>&gt;&gt;&gt; stop()\n{'ok': True, 'stopping': True}\n</code></pre> Note <p>Does not wait for daemon to fully exit, just sends stop signal. Check daemon status after calling to verify shutdown. Cleans up zombie processes as a side effect.</p> Source code in <code>axium/core/daemon.py</code> <pre><code>def stop() -&gt; dict:\n    \"\"\"\n    Stop the Axium daemon.\n\n    Attempts to stop daemon via IPC stop command. If that fails,\n    reads PID from axiumd.pid and sends SIGTERM. Also cleans up\n    any zombie daemon processes.\n\n    Returns:\n        dict with structure:\n            {\"ok\": true, \"stopping\": true} - IPC stop successful\n            {\"ok\": true, \"signal\": \"SIGTERM\"} - Sent SIGTERM to PID\n            {\"ok\": false, \"error\": \"...\"} - Failed to stop\n\n    Example:\n        ```python\n        &gt;&gt;&gt; stop()\n        {'ok': True, 'stopping': True}\n        ```\n\n    Note:\n        Does not wait for daemon to fully exit, just sends stop signal.\n        Check daemon status after calling to verify shutdown.\n        Cleans up zombie processes as a side effect.\n    \"\"\"\n    try:\n        from .ipc import send_request_sync\n\n        result = send_request_sync({\"cmd\": \"stop\"})\n        # Clean up zombies after successful stop\n        cleanup_zombie_daemons()\n        return result\n    except Exception as e:\n        pid = _read_pid()\n        if pid:\n            try:\n                os.kill(pid, signal.SIGTERM)\n                # Clean up zombies after signal\n                cleanup_zombie_daemons()\n                return {\"ok\": True, \"signal\": \"SIGTERM\"}\n            except Exception as ex:\n                return {\"ok\": False, \"error\": str(ex)}\n        # Clean up zombies even if stop failed\n        killed = cleanup_zombie_daemons()\n        if killed &gt; 0:\n            return {\"ok\": True, \"cleaned_zombies\": killed}\n        return {\"ok\": False, \"error\": f\"no pid ({e})\"}\n</code></pre>"},{"location":"reference/api/daemon/#axium.core.daemon.status","title":"<code>status()</code>","text":"<p>Get daemon status information.</p> <p>Returns:</p> Type Description <code>dict</code> <p>dict with structure: {     \"pid\": 12345 or None,     \"socket\": \"/tmp/axiumd.sock\",     \"socket_exists\": True or False }</p> Example <pre><code>&gt;&gt;&gt; status()\n{'pid': 12345, 'socket': '/tmp/axiumd.sock', 'socket_exists': True}\n</code></pre> Note <p>This only checks PID file and socket file existence. Use send_request_sync({\"cmd\": \"ping\"}) to verify daemon is responsive.</p> Source code in <code>axium/core/daemon.py</code> <pre><code>def status() -&gt; dict:\n    \"\"\"\n    Get daemon status information.\n\n    Returns:\n        dict with structure:\n            {\n                \"pid\": 12345 or None,\n                \"socket\": \"/tmp/axiumd.sock\",\n                \"socket_exists\": True or False\n            }\n\n    Example:\n        ```python\n        &gt;&gt;&gt; status()\n        {'pid': 12345, 'socket': '/tmp/axiumd.sock', 'socket_exists': True}\n        ```\n\n    Note:\n        This only checks PID file and socket file existence.\n        Use send_request_sync({\"cmd\": \"ping\"}) to verify daemon is responsive.\n    \"\"\"\n    pid = _read_pid()\n    return {\n        \"pid\": pid,\n        \"socket\": str(SOCKET_PATH),\n        \"socket_exists\": SOCKET_PATH.exists(),\n    }\n</code></pre>"},{"location":"reference/api/daemon/#axium.core.daemon.ensure_daemon_running","title":"<code>ensure_daemon_running()</code>","text":"<p>Ensure daemon is running, starting it automatically if needed.</p> <p>Checks if daemon is responsive via ping with retry logic. If not responsive or not running, verifies daemon is actually stopped before starting a new one.</p> <p>This is called by the CLI on every command invocation to ensure the daemon is always available for IPC operations, event handling, and completion cache management.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if daemon is running (or successfully started), False on error</p> Example <pre><code>&gt;&gt;&gt; ensure_daemon_running()\nTrue  # Daemon is now guaranteed to be running\n</code></pre> Note <p>Uses 2-second timeout with 2 retry attempts for ping check to handle cases where daemon is busy loading spokes/gears. If ping fails after retries, checks PID file and process status before starting. This prevents accidental restarts when daemon is running but slow. If daemon start fails, logs warning but returns False (non-fatal).</p> Source code in <code>axium/core/daemon.py</code> <pre><code>def ensure_daemon_running() -&gt; bool:\n    \"\"\"\n    Ensure daemon is running, starting it automatically if needed.\n\n    Checks if daemon is responsive via ping with retry logic. If not responsive\n    or not running, verifies daemon is actually stopped before starting a new one.\n\n    This is called by the CLI on every command invocation to ensure the daemon\n    is always available for IPC operations, event handling, and completion cache\n    management.\n\n    Returns:\n        True if daemon is running (or successfully started), False on error\n\n    Example:\n        ```python\n        &gt;&gt;&gt; ensure_daemon_running()\n        True  # Daemon is now guaranteed to be running\n        ```\n\n    Note:\n        Uses 2-second timeout with 2 retry attempts for ping check to handle\n        cases where daemon is busy loading spokes/gears.\n        If ping fails after retries, checks PID file and process status before starting.\n        This prevents accidental restarts when daemon is running but slow.\n        If daemon start fails, logs warning but returns False (non-fatal).\n    \"\"\"\n    try:\n        from axium.core.ipc import send_request_sync\n\n        # Try ping with longer timeout and retries\n        # Daemon might be busy loading spokes/gears or handling requests\n        for attempt in range(2):\n            try:\n                resp = send_request_sync({\"cmd\": \"ping\"}, timeout=2.0)\n                if resp and resp.get(\"ok\"):\n                    logger.debug(\n                        \"Daemon is responsive (pid: %s, attempt: %d)\",\n                        _read_pid(),\n                        attempt + 1,\n                    )\n                    return True\n            except Exception as e:\n                if attempt == 0:\n                    # First attempt failed, try once more after brief pause\n                    logger.debug(\n                        \"Ping attempt %d failed: %s, retrying...\", attempt + 1, e\n                    )\n                    import time\n\n                    time.sleep(0.3)  # Brief pause before retry\n                    continue\n                # Second attempt also failed\n                logger.debug(\"Daemon not responsive after %d attempts\", attempt + 1)\n\n        # Ping failed after retries - verify daemon is actually stopped before starting\n        pid = _read_pid()\n        if pid:\n            # PID file exists - check if process is alive\n            try:\n                os.kill(pid, 0)  # Signal 0 checks process existence without killing\n                logger.debug(\n                    \"Daemon process exists (pid: %s) but not responsive after retries - letting it continue\",\n                    pid,\n                )\n                # Process exists but isn't responding to pings even after retries\n                # This can happen during heavy initialization (loading many spokes/gears)\n                # Don't start a new daemon - return True to allow operation to continue\n                return True\n            except ProcessLookupError:\n                # Process doesn't exist - safe to start new daemon\n                logger.debug(\n                    \"PID file exists but process is dead (pid: %s) - starting new daemon\",\n                    pid,\n                )\n                pass\n            except PermissionError:\n                # Can't check process (shouldn't happen for our own process)\n                logger.warning(\n                    \"Cannot check daemon process (pid: %s) - permission denied\", pid\n                )\n                return False\n\n        # Daemon is definitively not running, start it\n        logger.debug(\"Starting daemon automatically\")\n        success = start(debug=False)\n\n        if success:\n            # Give daemon a moment to initialize socket\n            import time\n\n            time.sleep(0.2)  # 200ms for socket creation and initialization\n            logger.info(\"Auto-started Axium daemon\")\n            return True\n        else:\n            logger.warning(\"Failed to auto-start daemon\")\n            return False\n\n    except Exception as e:\n        logger.error(\"Error ensuring daemon is running: %s\", e)\n        return False\n</code></pre>"},{"location":"reference/api/registry/","title":"Registry API Reference","text":""},{"location":"reference/api/registry/#axium.core.registry","title":"<code>registry</code>","text":"<p>Axium Command Registry - Dynamic command discovery and metadata storage.</p> <p>Provides a central registry for all Typer commands (core and Spoke-registered) to enable dynamic command discovery in the palette and other tooling.</p> <p>The registry is populated by introspecting the Typer app structure after commands are registered, capturing command names, help text, and source information.</p> Example <pre><code>&gt;&gt;&gt; from axium.core import registry\n&gt;&gt;&gt; registry.introspect_typer_app(app, source=\"core\")\n&gt;&gt;&gt; commands = registry.get_all_commands()\n&gt;&gt;&gt; print(commands[0])\n{'name': 'env set', 'help': 'Set active environment', 'source': 'core'}\n</code></pre>"},{"location":"reference/api/registry/#axium.core.registry.CommandMetadata","title":"<code>CommandMetadata</code>  <code>dataclass</code>","text":"<p>Metadata for a registered command.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Full command path (e.g., \"env set\", \"daemon start\", \"aws whoami\")</p> <code>help</code> <code>str</code> <p>Short help text from docstring first line (legacy)</p> <code>summary</code> <code>str</code> <p>One-line summary (80 chars max) for display</p> <code>description</code> <code>str</code> <p>Full docstring description</p> <code>source</code> <code>str</code> <p>Command source - \"core\" for core commands, or spoke name</p> <code>category</code> <code>str</code> <p>Auto-computed category (\"core\", \"spoke:creds\", \"gear:aws\")</p> <code>group</code> <code>str | None</code> <p>Parent command group name (e.g., \"env\", \"daemon\"), None for root</p> <code>callback</code> <code>Callable | None</code> <p>Reference to the command function (for future use)</p> Example <pre><code>&gt;&gt;&gt; cmd = CommandMetadata(\n...     name=\"env set\",\n...     help=\"Set active environment\",\n...     summary=\"Set the active environment\",\n...     description=\"Set the active environment context for all commands...\",\n...     source=\"core\",\n...     category=\"core\",\n...     group=\"env\",\n...     callback=env_set_func\n... )\n</code></pre> Source code in <code>axium/core/registry.py</code> <pre><code>@dataclass\nclass CommandMetadata:\n    \"\"\"\n    Metadata for a registered command.\n\n    Attributes:\n        name: Full command path (e.g., \"env set\", \"daemon start\", \"aws whoami\")\n        help: Short help text from docstring first line (legacy)\n        summary: One-line summary (80 chars max) for display\n        description: Full docstring description\n        source: Command source - \"core\" for core commands, or spoke name\n        category: Auto-computed category (\"core\", \"spoke:creds\", \"gear:aws\")\n        group: Parent command group name (e.g., \"env\", \"daemon\"), None for root\n        callback: Reference to the command function (for future use)\n\n    Example:\n        ```python\n        &gt;&gt;&gt; cmd = CommandMetadata(\n        ...     name=\"env set\",\n        ...     help=\"Set active environment\",\n        ...     summary=\"Set the active environment\",\n        ...     description=\"Set the active environment context for all commands...\",\n        ...     source=\"core\",\n        ...     category=\"core\",\n        ...     group=\"env\",\n        ...     callback=env_set_func\n        ... )\n        ```\n    \"\"\"\n\n    name: str\n    help: str\n    summary: str\n    description: str\n    source: str\n    category: str\n    group: str | None = None\n    callback: Callable | None = None\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Convert to dictionary for JSON serialization.\"\"\"\n        data = asdict(self)\n        # Exclude callback from dict (not serializable)\n        data.pop(\"callback\", None)\n        return data\n</code></pre>"},{"location":"reference/api/registry/#axium.core.registry.CommandMetadata.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert to dictionary for JSON serialization.</p> Source code in <code>axium/core/registry.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Convert to dictionary for JSON serialization.\"\"\"\n    data = asdict(self)\n    # Exclude callback from dict (not serializable)\n    data.pop(\"callback\", None)\n    return data\n</code></pre>"},{"location":"reference/api/registry/#axium.core.registry.register_command","title":"<code>register_command(name, help, source, summary='', description='', group=None, callback=None)</code>","text":"<p>Register a command in the global registry.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Full command path (e.g., \"env set\")</p> required <code>help</code> <code>str</code> <p>Help text from docstring (legacy)</p> required <code>source</code> <code>str</code> <p>\"core\" or spoke name</p> required <code>summary</code> <code>str</code> <p>One-line summary (auto-set from help if not provided)</p> <code>''</code> <code>description</code> <code>str</code> <p>Full description (auto-set from help if not provided)</p> <code>''</code> <code>group</code> <code>str | None</code> <p>Parent group name if applicable</p> <code>None</code> <code>callback</code> <code>Callable | None</code> <p>Command function reference</p> <code>None</code> Example <pre><code>&gt;&gt;&gt; register_command(\n...     name=\"env set\",\n...     help=\"Set active environment\",\n...     summary=\"Set the active environment\",\n...     description=\"Set the active environment context...\",\n...     source=\"core\",\n...     group=\"env\"\n... )\n</code></pre> Note <ul> <li>Category is auto-computed from source</li> <li>Summary defaults to help text (80 char limit)</li> <li>Description defaults to help text</li> <li>If a command with the same name already exists, it will be overwritten</li> </ul> Source code in <code>axium/core/registry.py</code> <pre><code>def register_command(\n    name: str,\n    help: str,\n    source: str,\n    summary: str = \"\",\n    description: str = \"\",\n    group: str | None = None,\n    callback: Callable | None = None,\n) -&gt; None:\n    \"\"\"\n    Register a command in the global registry.\n\n    Args:\n        name: Full command path (e.g., \"env set\")\n        help: Help text from docstring (legacy)\n        source: \"core\" or spoke name\n        summary: One-line summary (auto-set from help if not provided)\n        description: Full description (auto-set from help if not provided)\n        group: Parent group name if applicable\n        callback: Command function reference\n\n    Example:\n        ```python\n        &gt;&gt;&gt; register_command(\n        ...     name=\"env set\",\n        ...     help=\"Set active environment\",\n        ...     summary=\"Set the active environment\",\n        ...     description=\"Set the active environment context...\",\n        ...     source=\"core\",\n        ...     group=\"env\"\n        ... )\n        ```\n\n    Note:\n        - Category is auto-computed from source\n        - Summary defaults to help text (80 char limit)\n        - Description defaults to help text\n        - If a command with the same name already exists, it will be overwritten\n    \"\"\"\n    if name in COMMAND_REGISTRY:\n        existing = COMMAND_REGISTRY[name]\n        logger.warning(\n            \"Command '%s' already registered (source: %s), overwriting with source: %s\",\n            name,\n            existing.source,\n            source,\n        )\n\n    # Auto-compute category from source\n    if source == \"core\":\n        category = \"core\"\n    elif source.startswith(\"gear:\"):\n        category = source  # Already has gear: prefix\n    else:\n        category = f\"spoke:{source}\"\n\n    # Default summary and description to help text if not provided\n    if not summary:\n        summary = help.strip()[:80]  # Limit to 80 chars\n    if not description:\n        description = help.strip()\n\n    COMMAND_REGISTRY[name] = CommandMetadata(\n        name=name,\n        help=help.strip(),\n        summary=summary.strip(),\n        description=description.strip(),\n        source=source,\n        category=category,\n        group=group,\n        callback=callback,\n    )\n    logger.debug(\"Registered command: %s [%s/%s]\", name, source, category)\n</code></pre>"},{"location":"reference/api/registry/#axium.core.registry.get_all_commands","title":"<code>get_all_commands(sort_by='alpha')</code>","text":"<p>Get all registered commands with full metadata.</p> <p>Parameters:</p> Name Type Description Default <code>sort_by</code> <code>str</code> <p>Sort method - \"alpha\" (alphabetical), \"grouped\" (source grouped),     or \"usage\" (future: by usage frequency)</p> <code>'alpha'</code> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of command dictionaries with name, help, summary, description,</p> <code>list[dict[str, Any]]</code> <p>source, category, and group fields</p> Example <pre><code>&gt;&gt;&gt; commands = get_all_commands()\n&gt;&gt;&gt; print(commands[0])\n{'name': 'daemon start', 'help': 'Start daemon', 'summary': 'Start daemon',\n 'description': 'Start the Axium daemon...', 'source': 'core',\n 'category': 'core', 'group': 'daemon'}\n\n&gt;&gt;&gt; commands = get_all_commands(sort_by=\"grouped\")\n# Returns core commands first, then spokes alphabetically\n</code></pre> Note <p>The callback field is excluded from returned dictionaries to keep output clean for display purposes.</p> Source code in <code>axium/core/registry.py</code> <pre><code>def get_all_commands(sort_by: str = \"alpha\") -&gt; list[dict[str, Any]]:\n    \"\"\"\n    Get all registered commands with full metadata.\n\n    Args:\n        sort_by: Sort method - \"alpha\" (alphabetical), \"grouped\" (source grouped),\n                or \"usage\" (future: by usage frequency)\n\n    Returns:\n        List of command dictionaries with name, help, summary, description,\n        source, category, and group fields\n\n    Example:\n        ```python\n        &gt;&gt;&gt; commands = get_all_commands()\n        &gt;&gt;&gt; print(commands[0])\n        {'name': 'daemon start', 'help': 'Start daemon', 'summary': 'Start daemon',\n         'description': 'Start the Axium daemon...', 'source': 'core',\n         'category': 'core', 'group': 'daemon'}\n\n        &gt;&gt;&gt; commands = get_all_commands(sort_by=\"grouped\")\n        # Returns core commands first, then spokes alphabetically\n        ```\n\n    Note:\n        The callback field is excluded from returned dictionaries to keep\n        output clean for display purposes.\n    \"\"\"\n    commands = [cmd.to_dict() for cmd in COMMAND_REGISTRY.values()]\n\n    if sort_by == \"alpha\":\n        commands.sort(key=lambda c: c[\"name\"])\n    elif sort_by == \"grouped\":\n        # Sort by: core first, then by source name, then by command name\n        commands.sort(key=lambda c: (c[\"source\"] != \"core\", c[\"source\"], c[\"name\"]))\n    elif sort_by == \"usage\":\n        # TODO: Implement usage-based sorting with history\n        logger.warning(\"Usage-based sorting not yet implemented, using alpha\")\n        commands.sort(key=lambda c: c[\"name\"])\n\n    return commands\n</code></pre>"},{"location":"reference/api/registry/#axium.core.registry.get_commands_by_source","title":"<code>get_commands_by_source(source)</code>","text":"<p>Get commands filtered by source.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source filter - \"core\" or spoke name</p> required <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of command dictionaries matching the source</p> Example <pre><code>&gt;&gt;&gt; core_commands = get_commands_by_source(\"core\")\n&gt;&gt;&gt; aws_commands = get_commands_by_source(\"aws\")\n</code></pre> Source code in <code>axium/core/registry.py</code> <pre><code>def get_commands_by_source(source: str) -&gt; list[dict[str, Any]]:\n    \"\"\"\n    Get commands filtered by source.\n\n    Args:\n        source: Source filter - \"core\" or spoke name\n\n    Returns:\n        List of command dictionaries matching the source\n\n    Example:\n        ```python\n        &gt;&gt;&gt; core_commands = get_commands_by_source(\"core\")\n        &gt;&gt;&gt; aws_commands = get_commands_by_source(\"aws\")\n        ```\n    \"\"\"\n    return [cmd.to_dict() for cmd in COMMAND_REGISTRY.values() if cmd.source == source]\n</code></pre>"},{"location":"reference/api/registry/#axium.core.registry.clear_registry","title":"<code>clear_registry()</code>","text":"<p>Clear all registered commands.</p> <p>Used for testing and when reloading spokes with --reload flag.</p> Example <pre><code>&gt;&gt;&gt; clear_registry()\n&gt;&gt;&gt; len(get_all_commands())\n0\n</code></pre> Source code in <code>axium/core/registry.py</code> <pre><code>def clear_registry() -&gt; None:\n    \"\"\"\n    Clear all registered commands.\n\n    Used for testing and when reloading spokes with --reload flag.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; clear_registry()\n        &gt;&gt;&gt; len(get_all_commands())\n        0\n        ```\n    \"\"\"\n    COMMAND_REGISTRY.clear()\n    logger.debug(\"Registry cleared\")\n</code></pre>"},{"location":"reference/api/registry/#axium.core.registry.introspect_typer_app","title":"<code>introspect_typer_app(app, source='core', prefix='')</code>","text":"<p>Walk Typer app structure and register all commands.</p> <p>Recursively discovers commands by examining app.registered_commands and app.registered_groups. Captures command metadata including names, help text, and source tags.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>Any</code> <p>Typer application instance to introspect</p> required <code>source</code> <code>str</code> <p>Source tag for commands (\"core\" or spoke name)</p> <code>'core'</code> <code>prefix</code> <code>str</code> <p>Command prefix for nested groups (used internally for recursion)</p> <code>''</code> Example <pre><code>&gt;&gt;&gt; from typer import Typer\n&gt;&gt;&gt; app = Typer()\n&gt;&gt;&gt; @app.command()\n... def test():\n...     '''Test command'''\n...     pass\n&gt;&gt;&gt; introspect_typer_app(app, source=\"core\")\n&gt;&gt;&gt; commands = get_all_commands()\n&gt;&gt;&gt; print(commands[0]['name'])\ntest\n</code></pre> Note <ul> <li>Handles both root commands and nested subgroups</li> <li>Extracts help text from command docstrings if not explicitly set</li> <li>Called after load_spokes() to capture all registered commands</li> <li>Safe to call multiple times (will overwrite existing entries)</li> </ul> Source code in <code>axium/core/registry.py</code> <pre><code>def introspect_typer_app(app: Any, source: str = \"core\", prefix: str = \"\") -&gt; None:\n    \"\"\"\n    Walk Typer app structure and register all commands.\n\n    Recursively discovers commands by examining app.registered_commands\n    and app.registered_groups. Captures command metadata including names,\n    help text, and source tags.\n\n    Args:\n        app: Typer application instance to introspect\n        source: Source tag for commands (\"core\" or spoke name)\n        prefix: Command prefix for nested groups (used internally for recursion)\n\n    Example:\n        ```python\n        &gt;&gt;&gt; from typer import Typer\n        &gt;&gt;&gt; app = Typer()\n        &gt;&gt;&gt; @app.command()\n        ... def test():\n        ...     '''Test command'''\n        ...     pass\n        &gt;&gt;&gt; introspect_typer_app(app, source=\"core\")\n        &gt;&gt;&gt; commands = get_all_commands()\n        &gt;&gt;&gt; print(commands[0]['name'])\n        test\n        ```\n\n    Note:\n        - Handles both root commands and nested subgroups\n        - Extracts help text from command docstrings if not explicitly set\n        - Called after load_spokes() to capture all registered commands\n        - Safe to call multiple times (will overwrite existing entries)\n    \"\"\"\n    # Register direct commands at this level\n    for cmd_info in app.registered_commands:\n        # Use explicit name or fall back to function name\n        cmd_name = cmd_info.name or cmd_info.callback.__name__\n        full_name = f\"{prefix}{cmd_name}\".strip()\n\n        # Extract help text and full docstring\n        help_text = cmd_info.help\n        summary = \"\"\n        description = \"\"\n\n        if cmd_info.callback.__doc__:\n            # Extract full docstring\n            doc_lines = [\n                line.strip()\n                for line in cmd_info.callback.__doc__.split(\"\\n\")\n                if line.strip()\n            ]\n            if doc_lines:\n                # First line becomes summary (80 char limit)\n                summary = doc_lines[0][:80]\n                # Full docstring becomes description\n                description = \" \".join(doc_lines)\n\n        # Use help text if no docstring summary\n        if not help_text and summary:\n            help_text = summary\n        elif not summary and help_text:\n            summary = help_text[:80]\n\n        # Default both to help text if still empty\n        if not summary:\n            summary = help_text or \"\"\n        if not description:\n            description = help_text or \"\"\n\n        # Determine group name\n        group_name = None\n        if prefix:\n            # Extract group from prefix (e.g., \"daemon \" -&gt; \"daemon\")\n            group_name = prefix.strip().split()[-1] if prefix.strip() else None\n\n        register_command(\n            name=full_name,\n            help=help_text or \"\",\n            summary=summary,\n            description=description,\n            source=source,\n            group=group_name,\n            callback=cmd_info.callback,\n        )\n\n    # Recursively process command groups (subcommands)\n    for group_info in app.registered_groups:\n        group_prefix = f\"{prefix}{group_info.name} \"\n        introspect_typer_app(\n            app=group_info.typer_instance,\n            source=source,\n            prefix=group_prefix,\n        )\n\n    logger.debug(\n        \"Introspected Typer app [%s]: %d commands registered\",\n        source,\n        len(COMMAND_REGISTRY),\n    )\n</code></pre>"},{"location":"reference/api/spokes/","title":"Spokes API","text":"<p>Plugin system and event bus.</p>"},{"location":"reference/api/spokes/#spokes","title":"spokes","text":"<p>Spoke discovery, loading, and event bus implementation.</p>"},{"location":"reference/api/spokes/#axium.core.spokes","title":"<code>spokes</code>","text":"<p>Axium Spokes - Plugin system and event bus.</p> <p>Spokes are the plugin architecture for Axium, allowing modular extensions without modifying core code. Each Spoke lives in ~/.config/axium/spokes// with a spoke.yaml manifest and Python module. <p>The EventBus provides event-driven coordination, allowing Spokes to: - React to environment changes (env_change event) - Know when other Spokes load (spoke_loaded event) - Add custom CLI commands via Typer - Register prefix rules dynamically</p> Spoke Structure <p>~/.config/axium/spokes/aws/     spoke.yaml       - Manifest with name and entrypoint     main.py          - Implementation with register(app, events) function</p> <p>Manifest Format (spoke.yaml):     name: aws     entrypoint: aws.main:register</p> Standard Events <ul> <li>env_change(new_env: str, old_env: str) - Environment switched</li> <li>spoke_loaded(spoke_name: str) - Spoke finished loading</li> </ul> Example Spoke <p>def register(app, events):     @app.command(\"aws-whoami\")     def aws_whoami():         import boto3         print(boto3.client(\"sts\").get_caller_identity())</p> <pre><code>def on_env_change(new_env, old_env):\n    print(f\"Env changed: {old_env} \u2192 {new_env}\")\n\nevents.on(\"env_change\", on_env_change)\n</code></pre>"},{"location":"reference/api/spokes/#axium.core.spokes.SpokeMetadata","title":"<code>SpokeMetadata</code>  <code>dataclass</code>","text":"<p>Metadata for an installed Spoke.</p> <p>Tracks installation details, version, source, and current status for lifecycle management and display purposes.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Spoke name (matches directory name)</p> <code>version</code> <code>str</code> <p>Semantic version string (e.g., \"0.1.0\")</p> <code>description</code> <code>str</code> <p>Short description of Spoke functionality</p> <code>entrypoint</code> <code>str</code> <p>Module:function for register() (e.g., \"aws.main:register\")</p> <code>source</code> <code>str</code> <p>Installation source - \"local:/path\", \"git:url\", \"registry:name\"</p> <code>install_mode</code> <code>str</code> <p>\"copy\" or \"symlink\" (symlink for editable installs)</p> <code>installed_at</code> <code>str</code> <p>ISO 8601 timestamp of installation</p> <code>last_loaded</code> <code>str | None</code> <p>ISO 8601 timestamp of last successful load (None if never loaded)</p> <code>status</code> <code>str</code> <p>Current status - \"active\", \"error\", or \"not-loaded\"</p> Example <pre><code>&gt;&gt;&gt; metadata = SpokeMetadata(\n...     name=\"aws\",\n...     version=\"0.1.0\",\n...     description=\"AWS helpers\",\n...     entrypoint=\"aws.main:register\",\n...     source=\"local:/Users/jon/spoke-aws\",\n...     install_mode=\"symlink\",\n...     installed_at=\"2025-10-07T15:30:00Z\",\n...     last_loaded=\"2025-10-07T15:31:00Z\",\n...     status=\"active\"\n... )\n</code></pre> Source code in <code>axium/core/spokes.py</code> <pre><code>@dataclass\nclass SpokeMetadata:\n    \"\"\"\n    Metadata for an installed Spoke.\n\n    Tracks installation details, version, source, and current status\n    for lifecycle management and display purposes.\n\n    Attributes:\n        name: Spoke name (matches directory name)\n        version: Semantic version string (e.g., \"0.1.0\")\n        description: Short description of Spoke functionality\n        entrypoint: Module:function for register() (e.g., \"aws.main:register\")\n        source: Installation source - \"local:/path\", \"git:url\", \"registry:name\"\n        install_mode: \"copy\" or \"symlink\" (symlink for editable installs)\n        installed_at: ISO 8601 timestamp of installation\n        last_loaded: ISO 8601 timestamp of last successful load (None if never loaded)\n        status: Current status - \"active\", \"error\", or \"not-loaded\"\n\n    Example:\n        ```python\n        &gt;&gt;&gt; metadata = SpokeMetadata(\n        ...     name=\"aws\",\n        ...     version=\"0.1.0\",\n        ...     description=\"AWS helpers\",\n        ...     entrypoint=\"aws.main:register\",\n        ...     source=\"local:/Users/jon/spoke-aws\",\n        ...     install_mode=\"symlink\",\n        ...     installed_at=\"2025-10-07T15:30:00Z\",\n        ...     last_loaded=\"2025-10-07T15:31:00Z\",\n        ...     status=\"active\"\n        ... )\n        ```\n    \"\"\"\n\n    name: str\n    version: str\n    description: str\n    entrypoint: str\n    source: str\n    install_mode: str\n    installed_at: str\n    last_loaded: str | None = None\n    status: str = \"not-loaded\"\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Convert metadata to dictionary for JSON serialization.\n\n        Returns:\n            Dict with all metadata fields\n\n        Example:\n            ```python\n            &gt;&gt;&gt; metadata.to_dict()\n            {'name': 'aws', 'version': '0.1.0', ...}\n            ```\n        \"\"\"\n        return asdict(self)\n</code></pre>"},{"location":"reference/api/spokes/#axium.core.spokes.SpokeMetadata.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert metadata to dictionary for JSON serialization.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dict with all metadata fields</p> Example <pre><code>&gt;&gt;&gt; metadata.to_dict()\n{'name': 'aws', 'version': '0.1.0', ...}\n</code></pre> Source code in <code>axium/core/spokes.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Convert metadata to dictionary for JSON serialization.\n\n    Returns:\n        Dict with all metadata fields\n\n    Example:\n        ```python\n        &gt;&gt;&gt; metadata.to_dict()\n        {'name': 'aws', 'version': '0.1.0', ...}\n        ```\n    \"\"\"\n    return asdict(self)\n</code></pre>"},{"location":"reference/api/spokes/#axium.core.spokes.EventBus","title":"<code>EventBus</code>","text":"<p>Event bus for Spoke coordination.</p> <p>Provides publish-subscribe pattern for loosely-coupled communication between Axium core and Spokes. Events are synchronous and handlers are called in registration order.</p> Standard Events <p>env_change(new_env, old_env, pane=None): Emitted when environment switches spoke_loaded(spoke_name): Emitted when a Spoke finishes initial load spoke_reloaded(spoke_name): Emitted after a Spoke is reloaded (post-action) spoke_unloaded(spoke_name): Emitted after a Spoke is unloaded (post-action) gear_loaded(gear_name): Emitted when a Gear finishes loading gear_unloaded(gear_name): Emitted after a Gear is unloaded daemon_reload: Emitted after daemon configuration is reloaded config_reloaded: Emitted after all spoke configs are cleared and reloaded hud_segment_updated(spoke, value): Emitted when a HUD segment changes hud_refresh: Emitted when HUD should be regenerated</p> <p>Attributes:</p> Name Type Description <code>_listeners</code> <code>dict[str, list[Callable]]</code> <p>Dict mapping event names to lists of callback functions</p> Example <pre><code>&gt;&gt;&gt; bus = EventBus()\n&gt;&gt;&gt; def handler(new, old):\n...     print(f\"Changed: {old} \u2192 {new}\")\n&gt;&gt;&gt; bus.on(\"env_change\", handler)\n&gt;&gt;&gt; bus.emit(\"env_change\", \"prod\", \"dev\")\nChanged: dev \u2192 prod\n</code></pre> Source code in <code>axium/core/spokes.py</code> <pre><code>class EventBus:\n    \"\"\"\n    Event bus for Spoke coordination.\n\n    Provides publish-subscribe pattern for loosely-coupled communication\n    between Axium core and Spokes. Events are synchronous and handlers\n    are called in registration order.\n\n    Standard Events:\n        env_change(new_env, old_env, pane=None): Emitted when environment switches\n        spoke_loaded(spoke_name): Emitted when a Spoke finishes initial load\n        spoke_reloaded(spoke_name): Emitted after a Spoke is reloaded (post-action)\n        spoke_unloaded(spoke_name): Emitted after a Spoke is unloaded (post-action)\n        gear_loaded(gear_name): Emitted when a Gear finishes loading\n        gear_unloaded(gear_name): Emitted after a Gear is unloaded\n        daemon_reload: Emitted after daemon configuration is reloaded\n        config_reloaded: Emitted after all spoke configs are cleared and reloaded\n        hud_segment_updated(spoke, value): Emitted when a HUD segment changes\n        hud_refresh: Emitted when HUD should be regenerated\n\n    Attributes:\n        _listeners: Dict mapping event names to lists of callback functions\n\n    Example:\n        ```python\n        &gt;&gt;&gt; bus = EventBus()\n        &gt;&gt;&gt; def handler(new, old):\n        ...     print(f\"Changed: {old} \u2192 {new}\")\n        &gt;&gt;&gt; bus.on(\"env_change\", handler)\n        &gt;&gt;&gt; bus.emit(\"env_change\", \"prod\", \"dev\")\n        Changed: dev \u2192 prod\n        ```\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize empty event bus.\n\n        Creates an empty listener registry. Listeners are added via on().\n        \"\"\"\n        self._listeners: dict[str, list[Callable]] = {}\n\n    def on(self, event_name: str, callback: Callable) -&gt; None:\n        \"\"\"\n        Subscribe to an event.\n\n        Registers a callback to be invoked when the event is emitted.\n        Multiple callbacks can be registered for the same event.\n\n        Args:\n            event_name: Name of event to listen for (e.g., \"env_change\")\n            callback: Function to call when event is emitted\n\n        Example:\n            ```python\n            &gt;&gt;&gt; def on_env_change(new_env, old_env):\n            ...     print(f\"Environment: {new_env}\")\n            &gt;&gt;&gt; events.on(\"env_change\", on_env_change)\n            ```\n\n        Note:\n            Callbacks are invoked synchronously in registration order.\n            Exceptions in callbacks are logged but don't stop event propagation.\n        \"\"\"\n        if event_name not in self._listeners:\n            self._listeners[event_name] = []\n        self._listeners[event_name].append(callback)\n        logger.debug(\"Registered listener for event: %s\", event_name)\n\n    def emit(self, event_name: str, *args, **kwargs) -&gt; None:\n        \"\"\"\n        Emit an event to all subscribers.\n\n        Calls all registered callbacks for this event with provided arguments.\n        If a callback raises an exception, it's logged and remaining callbacks\n        continue to execute.\n\n        Args:\n            event_name: Name of event to emit\n            *args: Positional arguments to pass to callbacks\n            **kwargs: Keyword arguments to pass to callbacks\n\n        Example:\n            ```python\n            &gt;&gt;&gt; events.emit(\"env_change\", \"prod\", \"dev\")\n            &gt;&gt;&gt; events.emit(\"custom_event\", key=\"value\")\n            ```\n\n        Note:\n            Events are synchronous - emit() blocks until all callbacks complete.\n            Unknown events (no listeners) are silently ignored.\n        \"\"\"\n        listeners = self._listeners.get(event_name, [])\n        logger.debug(\"Emitting event: %s to %d listeners\", event_name, len(listeners))\n        for callback in listeners:\n            try:\n                callback(*args, **kwargs)\n            except Exception as e:\n                logger.error(\"Event listener failed for %s: %s\", event_name, e)\n</code></pre>"},{"location":"reference/api/spokes/#axium.core.spokes.EventBus.__init__","title":"<code>__init__()</code>","text":"<p>Initialize empty event bus.</p> <p>Creates an empty listener registry. Listeners are added via on().</p> Source code in <code>axium/core/spokes.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initialize empty event bus.\n\n    Creates an empty listener registry. Listeners are added via on().\n    \"\"\"\n    self._listeners: dict[str, list[Callable]] = {}\n</code></pre>"},{"location":"reference/api/spokes/#axium.core.spokes.EventBus.on","title":"<code>on(event_name, callback)</code>","text":"<p>Subscribe to an event.</p> <p>Registers a callback to be invoked when the event is emitted. Multiple callbacks can be registered for the same event.</p> <p>Parameters:</p> Name Type Description Default <code>event_name</code> <code>str</code> <p>Name of event to listen for (e.g., \"env_change\")</p> required <code>callback</code> <code>Callable</code> <p>Function to call when event is emitted</p> required Example <pre><code>&gt;&gt;&gt; def on_env_change(new_env, old_env):\n...     print(f\"Environment: {new_env}\")\n&gt;&gt;&gt; events.on(\"env_change\", on_env_change)\n</code></pre> Note <p>Callbacks are invoked synchronously in registration order. Exceptions in callbacks are logged but don't stop event propagation.</p> Source code in <code>axium/core/spokes.py</code> <pre><code>def on(self, event_name: str, callback: Callable) -&gt; None:\n    \"\"\"\n    Subscribe to an event.\n\n    Registers a callback to be invoked when the event is emitted.\n    Multiple callbacks can be registered for the same event.\n\n    Args:\n        event_name: Name of event to listen for (e.g., \"env_change\")\n        callback: Function to call when event is emitted\n\n    Example:\n        ```python\n        &gt;&gt;&gt; def on_env_change(new_env, old_env):\n        ...     print(f\"Environment: {new_env}\")\n        &gt;&gt;&gt; events.on(\"env_change\", on_env_change)\n        ```\n\n    Note:\n        Callbacks are invoked synchronously in registration order.\n        Exceptions in callbacks are logged but don't stop event propagation.\n    \"\"\"\n    if event_name not in self._listeners:\n        self._listeners[event_name] = []\n    self._listeners[event_name].append(callback)\n    logger.debug(\"Registered listener for event: %s\", event_name)\n</code></pre>"},{"location":"reference/api/spokes/#axium.core.spokes.EventBus.emit","title":"<code>emit(event_name, *args, **kwargs)</code>","text":"<p>Emit an event to all subscribers.</p> <p>Calls all registered callbacks for this event with provided arguments. If a callback raises an exception, it's logged and remaining callbacks continue to execute.</p> <p>Parameters:</p> Name Type Description Default <code>event_name</code> <code>str</code> <p>Name of event to emit</p> required <code>*args</code> <p>Positional arguments to pass to callbacks</p> <code>()</code> <code>**kwargs</code> <p>Keyword arguments to pass to callbacks</p> <code>{}</code> Example <pre><code>&gt;&gt;&gt; events.emit(\"env_change\", \"prod\", \"dev\")\n&gt;&gt;&gt; events.emit(\"custom_event\", key=\"value\")\n</code></pre> Note <p>Events are synchronous - emit() blocks until all callbacks complete. Unknown events (no listeners) are silently ignored.</p> Source code in <code>axium/core/spokes.py</code> <pre><code>def emit(self, event_name: str, *args, **kwargs) -&gt; None:\n    \"\"\"\n    Emit an event to all subscribers.\n\n    Calls all registered callbacks for this event with provided arguments.\n    If a callback raises an exception, it's logged and remaining callbacks\n    continue to execute.\n\n    Args:\n        event_name: Name of event to emit\n        *args: Positional arguments to pass to callbacks\n        **kwargs: Keyword arguments to pass to callbacks\n\n    Example:\n        ```python\n        &gt;&gt;&gt; events.emit(\"env_change\", \"prod\", \"dev\")\n        &gt;&gt;&gt; events.emit(\"custom_event\", key=\"value\")\n        ```\n\n    Note:\n        Events are synchronous - emit() blocks until all callbacks complete.\n        Unknown events (no listeners) are silently ignored.\n    \"\"\"\n    listeners = self._listeners.get(event_name, [])\n    logger.debug(\"Emitting event: %s to %d listeners\", event_name, len(listeners))\n    for callback in listeners:\n        try:\n            callback(*args, **kwargs)\n        except Exception as e:\n            logger.error(\"Event listener failed for %s: %s\", event_name, e)\n</code></pre>"},{"location":"reference/api/spokes/#axium.core.spokes.get_event_bus","title":"<code>get_event_bus()</code>","text":"<p>Get the global event bus singleton.</p> <p>Returns the shared EventBus instance used by core and all Spokes. This ensures all parts of Axium communicate via the same event bus.</p> <p>Returns:</p> Type Description <code>EventBus</code> <p>Global EventBus instance</p> Example <pre><code>&gt;&gt;&gt; from axium.core import spokes\n&gt;&gt;&gt; events = spokes.get_event_bus()\n&gt;&gt;&gt; events.on(\"env_change\", my_handler)\n</code></pre> Note <p>The singleton is created on first module import. All Spokes receive the same instance via register(app, events).</p> Source code in <code>axium/core/spokes.py</code> <pre><code>def get_event_bus() -&gt; EventBus:\n    \"\"\"\n    Get the global event bus singleton.\n\n    Returns the shared EventBus instance used by core and all Spokes.\n    This ensures all parts of Axium communicate via the same event bus.\n\n    Returns:\n        Global EventBus instance\n\n    Example:\n        ```python\n        &gt;&gt;&gt; from axium.core import spokes\n        &gt;&gt;&gt; events = spokes.get_event_bus()\n        &gt;&gt;&gt; events.on(\"env_change\", my_handler)\n        ```\n\n    Note:\n        The singleton is created on first module import.\n        All Spokes receive the same instance via register(app, events).\n    \"\"\"\n    return _event_bus\n</code></pre>"},{"location":"reference/api/spokes/#axium.core.spokes.get_spoke_metadata","title":"<code>get_spoke_metadata()</code>","text":"<p>Get metadata for all installed Spokes.</p> <p>Loads metadata from JSON file and enriches with current status from the command registry.</p> <p>Returns:</p> Type Description <code>list[SpokeMetadata]</code> <p>List of SpokeMetadata objects, sorted by name</p> Example <pre><code>&gt;&gt;&gt; spokes = get_spoke_metadata()\n&gt;&gt;&gt; for spoke in spokes:\n...     print(f\"{spoke.name}: {spoke.status}\")\naws: active\nk8s: active\n</code></pre> Note <p>Status is enriched with current load state from registry. Spokes in metadata but not in registry show as \"not-loaded\".</p> Source code in <code>axium/core/spokes.py</code> <pre><code>def get_spoke_metadata() -&gt; list[SpokeMetadata]:\n    \"\"\"\n    Get metadata for all installed Spokes.\n\n    Loads metadata from JSON file and enriches with current status\n    from the command registry.\n\n    Returns:\n        List of SpokeMetadata objects, sorted by name\n\n    Example:\n        ```python\n        &gt;&gt;&gt; spokes = get_spoke_metadata()\n        &gt;&gt;&gt; for spoke in spokes:\n        ...     print(f\"{spoke.name}: {spoke.status}\")\n        aws: active\n        k8s: active\n        ```\n\n    Note:\n        Status is enriched with current load state from registry.\n        Spokes in metadata but not in registry show as \"not-loaded\".\n    \"\"\"\n    data = _load_metadata_file()\n    spokes_data = data.get(\"spokes\", {})\n\n    # Convert dict entries to SpokeMetadata objects\n    metadata_list = []\n    for spoke_name, spoke_dict in spokes_data.items():\n        try:\n            metadata = SpokeMetadata(**spoke_dict)\n            metadata_list.append(metadata)\n        except Exception as e:\n            logger.error(\"Invalid metadata for Spoke %s: %s\", spoke_name, e)\n\n    # Sort by name\n    metadata_list.sort(key=lambda s: s.name)\n\n    return metadata_list\n</code></pre>"},{"location":"reference/api/spokes/#axium.core.spokes.create_spoke","title":"<code>create_spoke(name, description=None, version='0.1.0', interactive=True)</code>","text":"<p>Create a new Spoke from template.</p> <p>Scaffolds a new Spoke directory with spoke.yaml manifest and main.py implementation template. Prompts for details interactively if enabled.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Spoke name (used for directory and defaults)</p> required <code>description</code> <code>str | None</code> <p>Short description (prompted if None and interactive=True)</p> <code>None</code> <code>version</code> <code>str</code> <p>Semantic version string (default: \"0.1.0\")</p> <code>'0.1.0'</code> <code>interactive</code> <code>bool</code> <p>Prompt for missing values if True</p> <code>True</code> <p>Returns:</p> Type Description <code>Path</code> <p>Path to created Spoke directory</p> Example <pre><code>$ axium spoke new aws\nCreating Spoke: aws\nDescription: AWS helpers for Axium\nVersion [0.1.0]:\n\u2713 Directory: ~/.config/axium/spokes/aws/\n\u2713 Generated spoke.yaml\n\u2713 Generated main.py\n</code></pre> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If Spoke directory already exists</p> <code>ValueError</code> <p>If name is invalid (empty, contains invalid characters)</p> Note <ul> <li>Creates directory structure in ~/.config/axium/spokes// <li>Generates spoke.yaml with metadata</li> <li>Creates main.py with register() function and example command</li> <li>Adds entry to .spoke_metadata.json</li> Source code in <code>axium/core/spokes.py</code> <pre><code>def create_spoke(\n    name: str,\n    description: str | None = None,\n    version: str = \"0.1.0\",\n    interactive: bool = True,\n) -&gt; Path:\n    \"\"\"\n    Create a new Spoke from template.\n\n    Scaffolds a new Spoke directory with spoke.yaml manifest and\n    main.py implementation template. Prompts for details interactively\n    if enabled.\n\n    Args:\n        name: Spoke name (used for directory and defaults)\n        description: Short description (prompted if None and interactive=True)\n        version: Semantic version string (default: \"0.1.0\")\n        interactive: Prompt for missing values if True\n\n    Returns:\n        Path to created Spoke directory\n\n    Example:\n        ```bash\n        $ axium spoke new aws\n        Creating Spoke: aws\n        Description: AWS helpers for Axium\n        Version [0.1.0]:\n        \u2713 Directory: ~/.config/axium/spokes/aws/\n        \u2713 Generated spoke.yaml\n        \u2713 Generated main.py\n        ```\n\n    Raises:\n        FileExistsError: If Spoke directory already exists\n        ValueError: If name is invalid (empty, contains invalid characters)\n\n    Note:\n        - Creates directory structure in ~/.config/axium/spokes/&lt;name&gt;/\n        - Generates spoke.yaml with metadata\n        - Creates main.py with register() function and example command\n        - Adds entry to .spoke_metadata.json\n    \"\"\"\n    # Validate name\n    if not name or not name.replace(\"-\", \"\").replace(\"_\", \"\").isalnum():\n        raise ValueError(f\"Invalid Spoke name: {name}\")\n\n    spoke_dir = SPOKES_DIR / name\n\n    # Check if already exists\n    if spoke_dir.exists():\n        raise FileExistsError(f\"Spoke directory already exists: {spoke_dir}\")\n\n    # Interactive prompts\n    if interactive:\n        import typer\n\n        if description is None:\n            description = typer.prompt(\n                f\"Description for '{name}'\", default=f\"{name} Spoke for Axium\"\n            )\n\n        version_input = typer.prompt(\"Version\", default=version)\n        if version_input:\n            version = version_input\n\n    # Use defaults if still None\n    if description is None:\n        description = f\"{name} Spoke for Axium\"\n\n    # Get author from git config or use placeholder\n    author = \"Your Name\"\n    try:\n        import subprocess\n\n        result = subprocess.run(\n            [\"git\", \"config\", \"user.name\"], capture_output=True, text=True, timeout=2\n        )\n        if result.returncode == 0:\n            author = result.stdout.strip()\n    except Exception:\n        pass\n\n    # Create directory\n    spoke_dir.mkdir(parents=True, exist_ok=True)\n    logger.info(\"Created Spoke directory: %s\", spoke_dir)\n\n    # Write spoke.yaml\n    spoke_yaml = spoke_dir / \"spoke.yaml\"\n    spoke_yaml.write_text(\n        SPOKE_YAML_TEMPLATE.format(\n            name=name, version=version, description=description, author=author\n        )\n    )\n    logger.debug(\"Generated spoke.yaml\")\n\n    # Write main.py\n    main_py = spoke_dir / \"main.py\"\n    main_py.write_text(\n        SPOKE_MAIN_PY_TEMPLATE.format(name=name, description=description)\n    )\n    logger.debug(\"Generated main.py\")\n\n    # Add to metadata\n    metadata_data = _load_metadata_file()\n    metadata_data[\"spokes\"][name] = SpokeMetadata(\n        name=name,\n        version=version,\n        description=description,\n        entrypoint=f\"{name}.main:register\",\n        source=f\"local:{spoke_dir}\",\n        install_mode=\"created\",\n        installed_at=datetime.now(timezone.utc).isoformat().replace(\"+00:00\", \"Z\"),\n        status=\"not-loaded\",\n    ).to_dict()\n    _save_metadata_file(metadata_data)\n\n    print(f\"\u2713 Spoke '{name}' created at {spoke_dir}\")\n    print(f\"\\nNext steps:\")\n    print(f\"  1. Edit {spoke_dir}/main.py\")\n    print(f\"  2. Run: axium spoke reload\")\n    print(f\"  3. Test: axium {name}-example\")\n\n    return spoke_dir\n</code></pre>"},{"location":"reference/api/spokes/#axium.core.spokes.validate_spoke","title":"<code>validate_spoke(spoke_dir)</code>","text":"<p>Validate Spoke directory structure and manifest.</p> <p>Checks that spoke_dir contains a valid spoke.yaml with required fields and that the entrypoint module exists.</p> <p>Parameters:</p> Name Type Description Default <code>spoke_dir</code> <code>Path</code> <p>Path to Spoke directory to validate</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dict with parsed spoke.yaml data if valid</p> Example <pre><code>&gt;&gt;&gt; data = validate_spoke(Path(\"~/.config/axium/spokes/aws\"))\n&gt;&gt;&gt; data[\"name\"]\n'aws'\n</code></pre> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If spoke.yaml missing</p> <code>ValueError</code> <p>If spoke.yaml invalid or missing required fields</p> Note <p>Required fields in spoke.yaml: name, version, description, entrypoint Entrypoint format: \"spoke.module:function\" (e.g., \"aws.main:register\")</p> Source code in <code>axium/core/spokes.py</code> <pre><code>def validate_spoke(spoke_dir: Path) -&gt; dict[str, Any]:\n    \"\"\"\n    Validate Spoke directory structure and manifest.\n\n    Checks that spoke_dir contains a valid spoke.yaml with required fields\n    and that the entrypoint module exists.\n\n    Args:\n        spoke_dir: Path to Spoke directory to validate\n\n    Returns:\n        Dict with parsed spoke.yaml data if valid\n\n    Example:\n        ```python\n        &gt;&gt;&gt; data = validate_spoke(Path(\"~/.config/axium/spokes/aws\"))\n        &gt;&gt;&gt; data[\"name\"]\n        'aws'\n        ```\n\n    Raises:\n        FileNotFoundError: If spoke.yaml missing\n        ValueError: If spoke.yaml invalid or missing required fields\n\n    Note:\n        Required fields in spoke.yaml: name, version, description, entrypoint\n        Entrypoint format: \"spoke.module:function\" (e.g., \"aws.main:register\")\n    \"\"\"\n    manifest_path = spoke_dir / \"spoke.yaml\"\n\n    if not manifest_path.exists():\n        raise FileNotFoundError(f\"spoke.yaml not found in {spoke_dir}\")\n\n    try:\n        data = yaml.safe_load(manifest_path.read_text())\n    except Exception as e:\n        raise ValueError(f\"Invalid YAML in spoke.yaml: {e}\")\n\n    # Check required fields\n    required_fields = [\"name\", \"version\", \"description\", \"entrypoint\"]\n    missing = [f for f in required_fields if f not in data]\n    if missing:\n        raise ValueError(f\"spoke.yaml missing required fields: {', '.join(missing)}\")\n\n    # Validate entrypoint format\n    entrypoint = data.get(\"entrypoint\", \"\")\n    if \":\" not in entrypoint:\n        raise ValueError(\n            f\"Invalid entrypoint format '{entrypoint}' - must be 'module:function'\"\n        )\n\n    module_part, func_part = entrypoint.split(\":\", 1)\n    if not module_part or not func_part:\n        raise ValueError(f\"Invalid entrypoint format '{entrypoint}'\")\n\n    # Check if entrypoint file exists (if it's a .py file reference)\n    if module_part.endswith(\".py\"):\n        entrypoint_file = spoke_dir / module_part\n        if not entrypoint_file.exists():\n            raise FileNotFoundError(f\"Entrypoint file not found: {entrypoint_file}\")\n\n    return data\n</code></pre>"},{"location":"reference/api/spokes/#axium.core.spokes.install_spoke","title":"<code>install_spoke(source, editable=False, name=None)</code>","text":"<p>Install a Spoke from source.</p> <p>Supports installation from local directories. Git and registry sources are planned for future implementation.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Installation source - local path, git URL, or registry name</p> required <code>editable</code> <code>bool</code> <p>If True, symlink instead of copy (for development)</p> <code>False</code> <code>name</code> <code>str | None</code> <p>Override Spoke name from manifest (optional)</p> <code>None</code> <p>Returns:</p> Type Description <code>SpokeMetadata</code> <p>SpokeMetadata object for installed Spoke</p> Example <pre><code># Install from local directory\n$ axium spoke install ~/my-spokes/aws\n\n# Install in editable mode (symlink)\n$ axium spoke install ~/dev/my-spoke --editable\n</code></pre> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If source doesn't exist or invalid</p> <code>ValueError</code> <p>If spoke.yaml invalid</p> <code>FileExistsError</code> <p>If Spoke already installed</p> Note <ul> <li>Validates spoke.yaml before installation</li> <li>Adds entry to .spoke_metadata.json</li> <li>Does not auto-reload (caller should call reload_spokes())</li> </ul> Source code in <code>axium/core/spokes.py</code> <pre><code>def install_spoke(\n    source: str, editable: bool = False, name: str | None = None\n) -&gt; SpokeMetadata:\n    \"\"\"\n    Install a Spoke from source.\n\n    Supports installation from local directories. Git and registry sources\n    are planned for future implementation.\n\n    Args:\n        source: Installation source - local path, git URL, or registry name\n        editable: If True, symlink instead of copy (for development)\n        name: Override Spoke name from manifest (optional)\n\n    Returns:\n        SpokeMetadata object for installed Spoke\n\n    Example:\n        ```bash\n        # Install from local directory\n        $ axium spoke install ~/my-spokes/aws\n\n        # Install in editable mode (symlink)\n        $ axium spoke install ~/dev/my-spoke --editable\n        ```\n\n    Raises:\n        FileNotFoundError: If source doesn't exist or invalid\n        ValueError: If spoke.yaml invalid\n        FileExistsError: If Spoke already installed\n\n    Note:\n        - Validates spoke.yaml before installation\n        - Adds entry to .spoke_metadata.json\n        - Does not auto-reload (caller should call reload_spokes())\n    \"\"\"\n    # Parse source type\n    source_path = Path(source).expanduser().resolve()\n\n    # TODO: Support git:// and registry:// sources in future\n    if not source_path.exists():\n        raise FileNotFoundError(f\"Source path not found: {source}\")\n\n    if not source_path.is_dir():\n        raise ValueError(f\"Source must be a directory: {source}\")\n\n    # Validate Spoke structure\n    manifest_data = validate_spoke(source_path)\n\n    # Use provided name or manifest name\n    spoke_name = name or manifest_data[\"name\"]\n\n    # Install (copy or symlink)\n    dest_path, install_mode = _install_local(source_path, spoke_name, editable)\n\n    # Create metadata entry\n    metadata = SpokeMetadata(\n        name=spoke_name,\n        version=manifest_data[\"version\"],\n        description=manifest_data[\"description\"],\n        entrypoint=manifest_data[\"entrypoint\"],\n        source=f\"local:{source_path}\",\n        install_mode=install_mode,\n        installed_at=datetime.now(timezone.utc).isoformat().replace(\"+00:00\", \"Z\"),\n        status=\"not-loaded\",\n    )\n\n    # Save to metadata file\n    metadata_data = _load_metadata_file()\n    metadata_data[\"spokes\"][spoke_name] = metadata.to_dict()\n    _save_metadata_file(metadata_data)\n\n    logger.info(\"Installed Spoke: %s (%s mode)\", spoke_name, install_mode)\n    print(f\"\u2713 Spoke '{spoke_name}' installed at {dest_path}\")\n\n    return metadata\n</code></pre>"},{"location":"reference/api/spokes/#axium.core.spokes.reload_spokes","title":"<code>reload_spokes(spoke_name=None)</code>","text":"<p>Reload spoke(s) dynamically without restarting daemon.</p> <p>Unloads specified spoke(s) by clearing their commands from the registry, reloads their Python modules, and re-calls register() to re-register commands and event handlers.</p> <p>Parameters:</p> Name Type Description Default <code>spoke_name</code> <code>str | None</code> <p>Specific spoke to reload, or None to reload all</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of spoke names that were successfully reloaded</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If specified spoke_name is not installed</p> Example <pre><code>&gt;&gt;&gt; reload_spokes(\"aws\")  # Reload just aws spoke\n['aws']\n&gt;&gt;&gt; reload_spokes()  # Reload all spokes\n['aws', 'creds', 'k8s']\n</code></pre> Note <ul> <li>Updates last_loaded timestamp in metadata</li> <li>Sets status to \"active\" on success, \"error\" on failure</li> <li>Emits spoke_reloaded event for each successful reload</li> <li>Useful for development without daemon restarts</li> </ul> Source code in <code>axium/core/spokes.py</code> <pre><code>def reload_spokes(spoke_name: str | None = None) -&gt; list[str]:\n    \"\"\"\n    Reload spoke(s) dynamically without restarting daemon.\n\n    Unloads specified spoke(s) by clearing their commands from the registry,\n    reloads their Python modules, and re-calls register() to re-register\n    commands and event handlers.\n\n    Args:\n        spoke_name: Specific spoke to reload, or None to reload all\n\n    Returns:\n        List of spoke names that were successfully reloaded\n\n    Raises:\n        ValueError: If specified spoke_name is not installed\n\n    Example:\n        ```python\n        &gt;&gt;&gt; reload_spokes(\"aws\")  # Reload just aws spoke\n        ['aws']\n        &gt;&gt;&gt; reload_spokes()  # Reload all spokes\n        ['aws', 'creds', 'k8s']\n        ```\n\n    Note:\n        - Updates last_loaded timestamp in metadata\n        - Sets status to \"active\" on success, \"error\" on failure\n        - Emits spoke_reloaded event for each successful reload\n        - Useful for development without daemon restarts\n    \"\"\"\n    import importlib.util\n    import sys\n\n    metadata_data = _load_metadata_file()\n    spokes_to_reload = {}\n\n    if spoke_name:\n        # Reload specific spoke\n        if spoke_name not in metadata_data[\"spokes\"]:\n            raise ValueError(f\"Spoke '{spoke_name}' is not installed\")\n        spokes_to_reload[spoke_name] = metadata_data[\"spokes\"][spoke_name]\n    else:\n        # Reload all spokes\n        spokes_to_reload = metadata_data[\"spokes\"]\n\n    if not spokes_to_reload:\n        logger.info(\"No spokes to reload\")\n        return []\n\n    # Import parent_app for re-registration\n    # Note: In practice, this would be passed as a parameter or accessed from global state\n    # For now, we'll defer this to the CLI layer which has access to the app\n    from axium.core.cli import app as parent_app\n\n    reloaded_names = []\n\n    for name, spoke_meta in spokes_to_reload.items():\n        spoke_dir = SPOKES_DIR / name\n\n        if not spoke_dir.exists():\n            logger.warning(\"Spoke directory not found: %s\", spoke_dir)\n            metadata_data[\"spokes\"][name][\"status\"] = \"error\"\n            continue\n\n        try:\n            # Step 1: Unload commands from registry\n            _unload_spoke(name)\n\n            # Step 2: Parse manifest\n            spoke_yaml = spoke_dir / \"spoke.yaml\"\n            manifest_data = yaml.safe_load(spoke_yaml.read_text())\n\n            # Step 3: Add spoke dir to sys.path if not already there\n            spoke_dir_str = str(spoke_dir)\n            if spoke_dir_str not in sys.path:\n                sys.path.insert(0, spoke_dir_str)\n\n            # Step 4: Reload module\n            _reload_spoke_module(spoke_dir, manifest_data)\n\n            # Step 5: Snapshot Typer app commands BEFORE calling register\n            from axium.core import registry\n\n            # Get set of command names currently in the Typer app\n            typer_commands_before = {\n                cmd.name or cmd.callback.__name__\n                for cmd in parent_app.registered_commands\n            }\n\n            # Step 6: Re-import and call register()\n            entrypoint = manifest_data[\"entrypoint\"]\n            module_name, func_name = entrypoint.split(\":\")\n\n            module = sys.modules[module_name]\n            register_func = getattr(module, func_name)\n            register_func(parent_app, get_event_bus())\n\n            # Step 7: Find NEW commands added by this spoke\n            typer_commands_after = {\n                cmd.name or cmd.callback.__name__\n                for cmd in parent_app.registered_commands\n            }\n            new_commands = typer_commands_after - typer_commands_before\n\n            # Step 8: Only register the NEW commands in the registry with spoke source\n            for cmd in parent_app.registered_commands:\n                cmd_name = cmd.name or cmd.callback.__name__\n                if cmd_name in new_commands:\n                    help_text = cmd.help\n                    if not help_text and cmd.callback.__doc__:\n                        doc_lines = [\n                            line.strip()\n                            for line in cmd.callback.__doc__.split(\"\\n\")\n                            if line.strip()\n                        ]\n                        help_text = doc_lines[0] if doc_lines else \"\"\n\n                    registry.register_command(\n                        name=cmd_name,\n                        help=help_text or \"\",\n                        source=name,\n                        group=None,\n                        callback=cmd.callback,\n                    )\n\n            # Step 9: Invalidate config cache\n            from axium.core import config\n\n            config.invalidate_cache(name)\n            logger.debug(\"Invalidated config cache for spoke: %s\", name)\n\n            # Step 10: Load permissions into daemon\n            try:\n                from axium.core.ipc import send_request_sync\n\n                resp = send_request_sync(\n                    {\n                        \"cmd\": \"load_spoke_permissions\",\n                        \"spoke\": name,\n                        \"spoke_yaml_path\": str(spoke_yaml),\n                    }\n                )\n                if resp.get(\"ok\"):\n                    logger.debug(\"Reloaded permissions for spoke: %s\", name)\n            except Exception as e:\n                logger.debug(\"Could not reload permissions for spoke %s: %s\", name, e)\n\n            # Step 11: Update metadata\n            now = datetime.now(timezone.utc).isoformat().replace(\"+00:00\", \"Z\")\n            metadata_data[\"spokes\"][name][\"last_loaded\"] = now\n            metadata_data[\"spokes\"][name][\"status\"] = \"active\"\n\n            # Step 12: Emit event\n            get_event_bus().emit(\"spoke_reloaded\", name)\n\n            logger.info(\"Reloaded Spoke: %s\", name)\n            reloaded_names.append(name)\n\n        except Exception as e:\n            logger.error(\"Failed to reload Spoke '%s': %s\", name, e)\n            metadata_data[\"spokes\"][name][\"status\"] = \"error\"\n\n    # Save updated metadata\n    _save_metadata_file(metadata_data)\n\n    logger.info(\n        \"Reloaded %d spoke(s): %s\", len(reloaded_names), \", \".join(reloaded_names)\n    )\n    return reloaded_names\n</code></pre>"},{"location":"reference/api/spokes/#axium.core.spokes.load_spokes","title":"<code>load_spokes(parent_app)</code>","text":"<p>Discover and load all Spokes from ~/.config/axium/spokes/.</p> <p>Scans the spokes directory for subdirectories containing spoke.yaml. For each valid Spoke: 1. Parse spoke.yaml manifest 2. Import the entrypoint module 3. Call register(app, events) with CLI app and EventBus 4. Emit spoke_loaded event</p> <p>Parameters:</p> Name Type Description Default <code>parent_app</code> <code>Any</code> <p>Typer application instance to pass to Spoke register functions</p> required Spoke Discovery <ul> <li>Searches ~/.config/axium/spokes/</li> <li>Each subdirectory is checked for spoke.yaml</li> <li>Manifest must contain 'name' and 'entrypoint'</li> <li>Entrypoint format: \"spoke.module:function\" (e.g., \"aws.main:register\")</li> </ul> Register Signature <p>def register(app: Typer, events: EventBus) -&gt; None</p> Example <pre><code>&gt;&gt;&gt; from typer import Typer\n&gt;&gt;&gt; app = Typer()\n&gt;&gt;&gt; load_spokes(app)\n# All Spokes in ~/.config/axium/spokes/ are now loaded\n</code></pre> Note <ul> <li>Spokes are loaded in alphabetical order by directory name</li> <li>Errors in individual Spokes are logged but don't stop loading</li> <li>The spoke directory is added to sys.path for imports</li> <li>Returns silently if spokes directory doesn't exist</li> </ul> Source code in <code>axium/core/spokes.py</code> <pre><code>def load_spokes(parent_app: Any) -&gt; None:\n    \"\"\"\n    Discover and load all Spokes from ~/.config/axium/spokes/.\n\n    Scans the spokes directory for subdirectories containing spoke.yaml.\n    For each valid Spoke:\n    1. Parse spoke.yaml manifest\n    2. Import the entrypoint module\n    3. Call register(app, events) with CLI app and EventBus\n    4. Emit spoke_loaded event\n\n    Args:\n        parent_app: Typer application instance to pass to Spoke register functions\n\n    Spoke Discovery:\n        - Searches ~/.config/axium/spokes/\n        - Each subdirectory is checked for spoke.yaml\n        - Manifest must contain 'name' and 'entrypoint'\n        - Entrypoint format: \"spoke.module:function\" (e.g., \"aws.main:register\")\n\n    Register Signature:\n        def register(app: Typer, events: EventBus) -&gt; None\n\n    Example:\n        ```python\n        &gt;&gt;&gt; from typer import Typer\n        &gt;&gt;&gt; app = Typer()\n        &gt;&gt;&gt; load_spokes(app)\n        # All Spokes in ~/.config/axium/spokes/ are now loaded\n        ```\n\n    Note:\n        - Spokes are loaded in alphabetical order by directory name\n        - Errors in individual Spokes are logged but don't stop loading\n        - The spoke directory is added to sys.path for imports\n        - Returns silently if spokes directory doesn't exist\n    \"\"\"\n    if not SPOKES_DIR.exists():\n        return\n\n    # Load metadata to track load status\n    metadata_data = _load_metadata_file()\n    metadata_updated = False\n\n    for spoke_dir in sorted(SPOKES_DIR.iterdir()):\n        if not spoke_dir.is_dir():\n            continue\n        manifest = spoke_dir / \"spoke.yaml\"\n        if not manifest.exists():\n            continue\n\n        spoke_name = spoke_dir.name\n\n        try:\n            data = yaml.safe_load(manifest.read_text())\n            entry = data.get(\"entrypoint\")\n            if not entry:\n                logger.warning(\"Spoke %s missing entrypoint\", spoke_name)\n                continue\n\n            module_path, func_name = entry.split(\":\")\n\n            # Check if this is a local spoke module (format: \"spoke.main\" or \"spoke.module\")\n            # Spokes should use spoke-relative paths like \"creds.main\" not \"main\"\n            if \".\" in module_path:\n                # Extract file path (e.g., \"creds.main\" -&gt; \"main.py\")\n                module_parts = module_path.split(\".\")\n                parent_module_name = module_parts[0]\n                child_module_name = module_parts[-1]\n                module_file = spoke_dir / f\"{child_module_name}.py\"\n\n                # Create fake parent package if it doesn't exist\n                if parent_module_name not in sys.modules:\n                    import types\n\n                    parent_module = types.ModuleType(parent_module_name)\n                    parent_module.__path__ = [str(spoke_dir)]\n                    parent_module.__file__ = str(spoke_dir / \"__init__.py\")\n                    sys.modules[parent_module_name] = parent_module\n                    logger.debug(\"Created parent module: %s\", parent_module_name)\n            else:\n                # Legacy format: \"main\" -&gt; \"main.py\"\n                module_file = spoke_dir / f\"{module_path}.py\"\n\n            if module_file.exists():\n                # Load local module directly from file\n                import importlib.util\n\n                spec = importlib.util.spec_from_file_location(module_path, module_file)\n                if spec is None or spec.loader is None:\n                    raise ImportError(\n                        f\"Cannot load module {module_path} from {module_file}\"\n                    )\n\n                module = importlib.util.module_from_spec(spec)\n                sys.modules[module_path] = module\n                spec.loader.exec_module(module)\n                logger.debug(\n                    \"Loaded local spoke module: %s from %s\", module_path, module_file\n                )\n            else:\n                # Try standard import (for installed packages or .py suffix handling)\n                if module_path.endswith(\".py\"):\n                    sys.path.insert(0, str(spoke_dir))\n                    module_path = Path(module_path).stem\n\n                module = importlib.import_module(module_path)\n                logger.debug(\"Imported spoke module: %s\", module_path)\n\n            register_func = getattr(module, func_name)\n\n            # Snapshot Typer app commands before spoke registers\n            from axium.core import registry\n\n            typer_commands_before = {\n                cmd.name or cmd.callback.__name__\n                for cmd in parent_app.registered_commands\n            }\n\n            # Call register with (app, events) signature\n            register_func(parent_app, _event_bus)\n\n            # Find NEW commands added by this spoke\n            typer_commands_after = {\n                cmd.name or cmd.callback.__name__\n                for cmd in parent_app.registered_commands\n            }\n            new_commands = typer_commands_after - typer_commands_before\n\n            # Only register the NEW commands in the registry with spoke source\n            for cmd in parent_app.registered_commands:\n                cmd_name = cmd.name or cmd.callback.__name__\n                if cmd_name in new_commands:\n                    help_text = cmd.help\n                    if not help_text and cmd.callback.__doc__:\n                        doc_lines = [\n                            line.strip()\n                            for line in cmd.callback.__doc__.split(\"\\n\")\n                            if line.strip()\n                        ]\n                        help_text = doc_lines[0] if doc_lines else \"\"\n\n                    registry.register_command(\n                        name=cmd_name,\n                        help=help_text or \"\",\n                        source=spoke_name,\n                        group=None,\n                        callback=cmd.callback,\n                    )\n\n            logger.info(\n                \"Loaded Spoke: %s (%d commands registered)\",\n                spoke_name,\n                len(new_commands),\n            )\n\n            # Emit spoke_loaded event\n            _event_bus.emit(\"spoke_loaded\", spoke_name)\n\n            # Load permissions into daemon (if daemon is running)\n            try:\n                from axium.core.ipc import send_request_sync\n\n                resp = send_request_sync(\n                    {\n                        \"cmd\": \"load_spoke_permissions\",\n                        \"spoke\": spoke_name,\n                        \"spoke_yaml_path\": str(manifest),\n                    }\n                )\n                if resp.get(\"ok\"):\n                    logger.debug(\"Loaded permissions for spoke: %s\", spoke_name)\n                else:\n                    logger.warning(\n                        \"Failed to load permissions for spoke %s: %s\",\n                        spoke_name,\n                        resp.get(\"error\", \"unknown error\"),\n                    )\n            except Exception as e:\n                # Daemon not running or IPC failed - non-fatal\n                logger.debug(\n                    \"Could not load permissions for spoke %s (daemon may not be running): %s\",\n                    spoke_name,\n                    e,\n                )\n\n            # Update metadata: set last_loaded and status=active\n            if spoke_name in metadata_data[\"spokes\"]:\n                now = datetime.now(timezone.utc).isoformat().replace(\"+00:00\", \"Z\")\n                metadata_data[\"spokes\"][spoke_name][\"last_loaded\"] = now\n                metadata_data[\"spokes\"][spoke_name][\"status\"] = \"active\"\n                metadata_updated = True\n\n        except Exception as e:\n            logger.error(\"Failed to load spoke %s: %s\", spoke_name, e)\n\n            # Update metadata: set status=error\n            if spoke_name in metadata_data[\"spokes\"]:\n                metadata_data[\"spokes\"][spoke_name][\"status\"] = \"error\"\n                metadata_updated = True\n\n    # Save updated metadata if any changes were made\n    if metadata_updated:\n        _save_metadata_file(metadata_data)\n</code></pre>"},{"location":"reference/api/spokes/#axium.core.spokes.list_spokes","title":"<code>list_spokes()</code>","text":"<p>List all installed Spokes to stdout.</p> <p>Scans ~/.config/axium/spokes/ and displays Spoke names with their directory paths. Validates spoke.yaml exists and parses the name.</p> Output Format <p>Installed Spokes:   - aws (~/.config/axium/spokes/aws)   - k8s (~/.config/axium/spokes/k8s)   (none found)  # if directory empty/missing</p> Example <pre><code>&gt;&gt;&gt; list_spokes()\nInstalled Spokes:\n  - aws (~/.config/axium/spokes/aws)\n  - k8s (~/.config/axium/spokes/k8s)\n</code></pre> Note <ul> <li>Displays \"(none found)\" if no Spokes are installed</li> <li>Shows \"(invalid manifest: ...)\" for Spokes with malformed YAML</li> <li>Does not attempt to load Spokes, only lists them</li> </ul> Source code in <code>axium/core/spokes.py</code> <pre><code>def list_spokes() -&gt; None:\n    \"\"\"\n    List all installed Spokes to stdout.\n\n    Scans ~/.config/axium/spokes/ and displays Spoke names with their\n    directory paths. Validates spoke.yaml exists and parses the name.\n\n    Output Format:\n        Installed Spokes:\n          - aws (~/.config/axium/spokes/aws)\n          - k8s (~/.config/axium/spokes/k8s)\n          (none found)  # if directory empty/missing\n\n    Example:\n        ```bash\n        &gt;&gt;&gt; list_spokes()\n        Installed Spokes:\n          - aws (~/.config/axium/spokes/aws)\n          - k8s (~/.config/axium/spokes/k8s)\n        ```\n\n    Note:\n        - Displays \"(none found)\" if no Spokes are installed\n        - Shows \"(invalid manifest: ...)\" for Spokes with malformed YAML\n        - Does not attempt to load Spokes, only lists them\n    \"\"\"\n    print(\"Installed Spokes:\")\n    if not SPOKES_DIR.exists():\n        print(\"  (none found)\")\n        return\n    for spoke_dir in sorted(SPOKES_DIR.iterdir()):\n        if not spoke_dir.is_dir():\n            continue\n        manifest = spoke_dir / \"spoke.yaml\"\n        if not manifest.exists():\n            continue\n        try:\n            data = yaml.safe_load(manifest.read_text())\n            print(f\"  - {data.get('name')} ({spoke_dir})\")\n        except Exception as e:\n            print(f\"  - {spoke_dir.name} (invalid manifest: {e})\")\n</code></pre>"}]}